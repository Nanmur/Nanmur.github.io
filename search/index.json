[{"content":"一、创建版本库 1.配置git环境 在git安装好以后，需要配置环境变量，命令行中输入以下命令： git config --global user.name \u0026quot;Your Name\u0026quot; git config \u0026ndash;global user.email \u0026ldquo;email@example.com\u0026rdquo; git config --list：查看当前的git配置；\n配置好环境后，使用git init，即可将当前目录变成一个git可以管理的仓库；\ngit顺序：工作区 \u0026ndash;\u0026gt; add \u0026ndash;\u0026gt; 暂存区 \u0026ndash;\u0026gt; commit \u0026ndash;\u0026gt; 版本库 \u0026ndash;\u0026gt; push \u0026ndash;\u0026gt; 远程版本库。\n2.时光机穿梭 1.版本回退 git status：查看仓库的当前状态； git diff：查看上次修改的内容； git log：显示所有提交日志，可以增加--pretty=oneline参数减少输出，可以使用--graph --pretty=oneline --abbrev-commit参数使输出更加直观； git reset --hard HEAD^：回退到上一版本，在git中，HEAD表示当前版本，HEAD^表示上一版本，HEAD^^表示上上个版本，HEAD~10表示往前第10个版本； git reset --hard \u0026lt;commit_id\u0026gt;：回退到指定的commit_id版本，commit_id可以不用输完整，输前几位就能找到； git reflog：查看历史命令，可以用来找回commit_id。\n二、撤销修改 git restore \u0026lt;file_name\u0026gt;：撤销对文件的修改（工作区）； git restore --staged \u0026lt;file_name\u0026gt;：撤销已经git add放到暂存区的文件； git reset --hard HEAD：撤销已经git commit到版本库的修改，即回退到上一版本。--hard表示之前的修改直接丢掉，--mixed(default)表示之前的修改保留在工作区，--soft表示之前的修改保留在暂存区。\n三、删除文件 git rm \u0026lt;file_name\u0026gt;：删除版本库中的文件，需要再使用git commit提交删除到版本库； 若删除了工作区的文件，想从版本库中恢复到工作区，可以使用git restore \u0026lt;file_name\u0026gt;；\n四、分支管理 1.创建与合并分支 git checkout -b dev：-b参数表示创建并切换到dev分支，该命令同git switch -c dev； git merge dev：合并dev分支到当前分支； git merge --no-ff dev：合并但禁用快速合并（推荐），因为dev分支上可能会有很多零碎的提交，这种方式能够避免搅乱master的分支提交历史； git branch -d dev：删除dev分支，参数-D表示强制删除，用来删除还未合并的分支。\n2.解决冲突 若合并时存在冲突，使用git status查看冲突文件； 然后手动编辑文件解决冲突。\n五、Bug分支 修复Bug时，通常我们会创建新的Bug分支进行修复，然后合并，最后删除； 当手头工作没有完成，需要先把工作现场git stash储藏起来，改完Bug后再用git stash pop还原工作现场，可以使用git stash list查看储藏列表； 在master分支上修复的Bug，可以通过git cherry-pick \u0026lt;commit_id\u0026gt;复制到当前分支。\n六、多人协作 git remote -v：查看远程分支详细信息； git push origin \u0026lt;branch_name\u0026gt;：推送到远程指定的分支上； git checkout -b dev origin/dev：创建远程的dev分支到本地； git pull：从远程获取最新版本并merge到本地，自动合并或修改当前的工作； git fetch：从远程拉取到本地仓库，不会自动合并或修改当前的工作； git --set-upstream-to=origin/dev dev：设置dev分支与远程origin/dev分支的链接，链接完成后，在dev分支中git pull就会直接从origin/dev上拉取了。\n在dev分支上执行git rebase master：若此时master上有新的提交，则用master上的新提交来作为dev的新基底，若master上没有提交，则类似于进行了merge操作。一般公司里会禁用rebase，统一使用merge，因为rebase会整合分支提交记录，不清楚主线上谁合了代码以及他们合代码的先后顺序。\n注意：总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作。\n","date":"2024-12-14T00:00:00Z","image":"https://Nanmur.github.io/p/git/Gitlogo_hu2783557759348303388.png","permalink":"https://Nanmur.github.io/p/git/","title":"Git入门"},{"content":"1.前缀和差分 输入输出 scanf 和 printf 优点：格式化输入、输出 %.nlf可以保留n位输出浮点数（一般竞赛中只用double 因为float能做的double都能做）\ncin 和 cout 优点：简洁，在取消同步流的情况下一般比scanf更快 取消同步流（一定要把三个语句写完整）：\n1 ios:: sync_with_stdio(0),cin.tie(0),cout.tie(0); 当取消了同步流之后，应该避免使用 endl，因为它会导致缓冲区立即刷新，引起不必要的系统调用，降低程序的执行效率。相反，推荐使用 \u0026lsquo;\\n\u0026rsquo; 来替代 endl，它只插入一个换行符，不会刷新缓冲区\n推荐写法： 1.确定数组N的大小，用const int不要用define 2.建议开全局数组。注意，全局的数组自动初始化为0。函数里面的数组使用的是栈空间（很小），且不会初始化。 3.输入要单独做，如果开循环的话，只在循环里做输入或输出，其他的操作不要在这个循环内做。\n前缀和数组 前缀和数组是一种在算法中常用的数据结构，用于存储一个序列（通常是数组）的前缀（即从开始到当前位置的所有元素的和）。这种数据结构可以快速地计算某个序列的任何一段区间的和，而不需要重复计算。\n其实这种思想不一定非要是前缀和，前缀积，前缀异或都可以，只要是满足可加性的运算都可以使用 前缀和数组在算法中非常有用，尤其是在处理区间和、连续子数组和等问题时。它可以将时间复杂度从 O(n^2) 降低到 O(n)。 其递推式为：prefix[i] = p[i-1] - a[i] 伪代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Input: nums[] (数组) Output: prefix_sum[] (前缀和数组) 1. 初始化: prefix_sum[0] = 0 2. 计算前缀和: for i = 1 to len(nums): prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1] 3. 查询任意区间 [l, r] 的和: function range_sum(l, r): return prefix_sum[r + 1] - prefix_sum[l] 4. 示例: range_sum(1, 3) 表示 nums[1] + nums[2] + nums[3] 1 2 3 4 5 using ll = long long; const N = 1e5 + 9; ll a[N],prefix[N];//a用来存最初的数组，prefix即是前缀和数组 for(int i = 1; i \u0026lt;= n;++i)cin \u0026gt;\u0026gt; a[i]; for(int i = 1; i \u0026lt;= n;++i)prefix[i] = prefix[i - 1] + a[i];//利用前缀和数组的可加性 简便计算 二维前缀和 二维前缀和是一种用于快速计算二维数组中任意子矩阵区域和的数据结构。它通过构建一个与原矩阵大小相同的二维前缀和数组来实现，其中每个元素存储了原数组中从左上角起点 (0, 0) 到当前位置 (i, j) 的子矩阵区域内所有元素的和。 其递推式为：prefix[i][j] = prefix[i-1][j] + prefix[i][j-1] +a[i][j]-p[i-1][j-1] 伪代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 Input: matrix[n][m] (二维矩阵) Output: prefix_sum[n+1][m+1] (二维前缀和数组) 1. 初始化: 创建一个大小为 (n+1) x (m+1) 的二维数组 prefix_sum，所有元素初始化为 0 2. 计算二维前缀和: for i = 1 to n: for j = 1 to m: prefix_sum[i][j] = matrix[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1] 3. 查询任意子矩阵和: function range_sum(x1, y1, x2, y2): # 矩阵区域 [(x1, y1), (x2, y2)]，注意这里是1-based下标 return prefix_sum[x2][y2] - prefix_sum[x1-1][y2] - prefix_sum[x2][y1-1] + prefix_sum[x1-1][y1-1] 4. 示例: 输入: 矩阵 [[1, 2], [3, 4]] prefix_sum: [[0, 0, 0], [0, 1, 3], [0, 4, 10]] range_sum(1, 1, 2, 2) = 10 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 using ll = long long; const N = 1e5 + 9; ll a[N],prefix[N]; int n,m,q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q; for(int i = 1; i \u0026lt;= n; ++i) { for(int j = 1; j \u0026lt;= m; ++j) { cin \u0026gt;\u0026gt; a[i][j]; } } for(int i = 1; i \u0026lt;= n; ++i) { for(int j = 1; j \u0026lt;= m; ++j) { prefix[i][j] = prefix[i-1][j] + prefix[i][j-1] +a[i][j]-p[i-1][j-1]//至此已经构造出二维前缀和数组 } } while(q--) { int x1,y1,x2,y2; cin \u0026gt;\u0026gt; x1 \u0026gt;\u0026gt; y1 \u0026gt;\u0026gt; x2 \u0026gt;\u0026gt; y2; int area; area = prefix[x2][y2] - prefix[x2][y1-1] -prefix[x1-1][y2] + prefix[x1-1][y1-1]; } 差分数组 差分数组是一种处理序列动态修改问题的数据结构，它通过记录每个元素与其前一个元素的差值来表示原始数组的变化。这种数据结构的主要用途是简化对原数组的频繁更新和查询操作，从而提高算法效率。 差分数组的主要优点是能够高效地处理大量区间修改操作。通过修改差分数组，可以间接实现原数组的区间修改，而不需要直接操作原数组，从而极大地提高了算法效率。 其递推式为：diff[i] = a[i] - a[i-1] 伪代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Input: nums[] (原数组) Output: diff[] (差分数组) 1. 初始化差分数组: diff[0] = nums[0] for i = 1 to len(nums) - 1: diff[i] = nums[i] - nums[i-1] 2. 区间修改: function update_range(l, r, val): diff[l] += val if r + 1 \u0026lt; len(diff): diff[r + 1] -= val 3. 计算修改后的数组: for i = 1 to len(nums) - 1: nums[i] = nums[i - 1] + diff[i] 4. 示例: 初始数组: nums = [0, 0, 0, 0, 0] 修改区间 [1, 3], 增加值 2: diff = [0, 2, 0, 0, -2] nums = [0, 2, 2, 2, 0] 1 2 3 4 5 using ll = long long; const N = 1e5 + 9; ll a[N],diff[N],prefix[N];//a用来存最初的数组，prefix即是前缀和数组,diff即是差分数组 for(int i = 1; i \u0026lt;= n;++i)cin \u0026gt;\u0026gt; a[i]; for(int i = 1; i \u0026lt;= n;++i)diff[i] = a[i] - a[i-1]; 二维差分数组 二维差分数组是一种用于处理二维数组中区间更新的数据结构。它通过记录每个元素与其相邻元素（左、上、右、下）的差值来表示原始数组的变化。这种数据结构的主要用途是简化对原数组的频繁更新操作，从而提高算法效率。 二维差分数组 diff 由原数组 arr 衍生而来，其中 diff[i][j] 表示原数组中元素 arr[i][j] 与其左侧元素 arr[i][j-1]、上侧元素 arr[i-1][j] 的差值。 具体来说： diff[i][j] = arr[i][j] - arr[i][j-1]（如果 j \u0026gt; 0） diff[i][j] = arr[i][j] - arr[i-1][j]（如果 i \u0026gt; 0） 这样，原数组中任意位置 (i, j) 的值可以通过累加前面所有差分值来恢复： arr[i][j] = diff[i][j] + arr[i][j-1]（如果 j \u0026gt; 0） arr[i][j] = diff[i][j] + arr[i-1][j]（如果 i \u0026gt; 0） 伪代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Input: matrix[n][m] (二维矩阵) Output: diff[n+1][m+1] (二维差分数组) 1. 初始化差分数组: 创建大小为 (n+1) x (m+1) 的二维数组 diff，所有元素初始化为 0 2. 区域修改: function update_range(x1, y1, x2, y2, val): diff[x1][y1] += val diff[x1][y2+1] -= val diff[x2+1][y1] -= val diff[x2+1][y2+1] += val 3. 计算修改后的矩阵: for i = 1 to n: for j = 1 to m: diff[i][j] += diff[i-1][j] + diff[i][j-1] - diff[i-1][j-1] matrix[i-1][j-1] = diff[i][j] 4. 示例: 初始矩阵: [[0, 0], [0, 0]] 修改区域 [(1, 1), (2, 2)], 增加值 2: diff: [[2, -2], [-2, 2]] 结果矩阵: [[2, 2], [2, 2]] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 using ll = long long; const N = 1e5 + 9; ll a[N],diff[N],prefix[N]; int n,m,q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q; for(int i = 1; i \u0026lt;= n; ++i) { for(int j = 1; j \u0026lt;= m; ++j) { cin \u0026gt;\u0026gt; a[i][j]; } } for(int i = 1; i \u0026lt;= n; ++i) { for(int j = 1; j \u0026lt;= m; ++j) { d[i][j] += a[i][j]; d[i+1][j] -= a[i][j]; d[i][j+1] -= a[i][j]; d[i+1][j+1] += a[i][j]; }//至此已经构建出二维差分数组 } while(q--) { int x1,y1,x2,y2,v; cin \u0026gt;\u0026gt; x1 \u0026gt;\u0026gt; y1 \u0026gt;\u0026gt;x2 \u0026gt;\u0026gt; y2 \u0026gt;\u0026gt; v; d[x1][y1] += v; d[x1][y2+1] -= v; d[x2+1][y1] -= v; d[x2+1][y2+1] += v; } for(int i = 1; i \u0026lt;= n; ++i) { for(int j = 1; j \u0026lt;= m; ++j) { a[i][j] = a[i-1][j] + a[i][j-1] -a[i-1][j-1] +d[i][j]; prefix[i][j] = p[i-1][j] + p[i][j-1] -p[i-1][j-1] +a[i][j]; } } while(q--) { int x1,y1,x2,y2; cin \u0026gt;\u0026gt; x1 \u0026gt;\u0026gt; y1 \u0026gt;\u0026gt; x2 \u0026gt;\u0026gt; y2; int area; area = prefix[x2][y2] - prefix[x2][y1-1] -prefix[x1-1][y2] + prefix[x1-1][y1-1]; } eg： 题目描述：在一个叫做酱西功爷枝叶鸡树学院的地方有 ( n ) 只小动物，要么是鼠鼠，要么是鸭鸭，从1到 ( n ) 编号，每只小动物有个体重 ( a_i )。在这个学校里，存在一种神奇的魔法，可以将编号位于某个区间 ([l, r]) 内的所有鼠鼠都变为鸭鸭，鸭鸭都变为鼠鼠（魔法并不会改变体重）。现在你可以施放这个魔法至多1次。（也可以不施放）问最终鸭鸭的总重量最多是多少？ 输入格式：第一行一个整数 ( T ) 表示样例个数。 ( (1 \\leq T \\leq 10) )对于每个样例:第一行一个整数 ( n ) 表示小动物的个数。 ( \\left(1 \\leq n \\leq 10^5\\right) )第二行 ( n ) 个整数，表示第 ( i ) 个小动物的类型。 0 表示鼠鼠， 1 表示鸭鸭。第三行 ( n ) 个整数，表示第 ( i ) 个小动物的体重 ( a_i )。 ( \\left(1 \\leq a_i \\leq 10^9\\right) ) 输出格式：对于每个样例一行一个整数表示答案。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e5 + 9; ll a[N], w[N], prefix[N]; // 分别存原动物类型、重量、和前缀和数组 void solve() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; w[i]; for (int i = 1; i \u0026lt;= n; ++i) { prefix[i] = prefix[i - 1] + ((a[i] == 1) ? -1 : 1) * w[i]; // 看a[i] 如果原来是鼠(0)，变完就是鸭子(1)，结果会相较于基础结果加上w[i]；反之减少w[i]。 } ll ess = 0; // 基础结果 for (int i = 1; i \u0026lt;= n; ++i) ess += w[i] * a[i]; ll mi = 0, Fix = 0; // mi表示 min(prefix[j]) 0 \u0026lt;= j \u0026lt; i for (int i = 1; i \u0026lt;= n; ++i) { Fix = max(Fix, prefix[i] - mi); mi = min(mi, prefix[i]); } cout \u0026lt;\u0026lt; ess + Fix \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _; cin \u0026gt;\u0026gt; _; while (_--) solve(); return 0; } 2.位运算、双指针、排序二分 位运算（都建立在二进制的基础上） 与运算 \u0026amp; a + b = 2(a \u0026amp; b) + (a ^ b)\n或运算 | 非运算 ! 异或运算 ^ 当 0 \u0026lt; a, b 时，有 a + b \u0026gt;= a ^ b 结合律： a ^ (b ^ c) = (a ^ b) ^ c 交换律： a ^ b = b ^ a 没有分配律 a ^ a = 0 a ^ 0 = a\neg:题目描述：给定两个正整数 ( a, b )，你可以写出一些非负整数数组，使得该数组的 MEX 和 XOR 值分别为 ( a ) 和 ( b )。你需要求出满足条件的非负整数数组的最小长度。 **提示:**MEX 值是指：最小的不存在于该数组之中的非负整数。例如，数组 ( (0,3,2,2) ) 的 MEX 值为 1。XOR 值是指：数组中的所有元素做异或运算的结果。例如，数组 ( (3,5,5) ) 的 XOR 值为 ( 3 \\oplus 5 \\oplus 5 = 3 )。 输入描述：第一行：一个整数 ( t )，表示测试用例的数量。 ( \\left(1 \\leq t \\leq 10^5\\right) ) 接下来 ( t ) 行，每行两个整数 ( a, b )。 ( \\left(1 \\leq a \\leq 2 \\times 10^5, 0 \\leq b \\leq 2 \\times 10^5\\right) ) 输出描述：共 ( t ) 行：第 ( i ) 行为第 ( i ) 个测试用例的答案。 整数a一定可以由b和c通过异或构造出来 （b，c \u0026gt; a）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2e5 + 9; int prexor[N];//构造异或前缀和 防止时间超限 void solve() { int a,b;cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; int y = prexor[a - 1] ^ b; //y是使XOR=b的那个缺少的值（除了0~a-1之外） if(y == a) cout \u0026lt;\u0026lt; a + 2 \u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; //缺少a 则需要两个比a大的数字来构造出a 所以最小 a+2 else if(y == 0) cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; //缺少0 0已经包含在0~a-1内 所以最小数字集合就是a else cout \u0026lt;\u0026lt; a + 1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; //其余情况 只要在0~a-1加上这个数字就行 所以 a+1 } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); for(int i = 1; i \u0026lt;= 2e5; ++i) prexor[i] = prexor[i - 1] ^ i; int _; cin \u0026gt;\u0026gt; _; while(_--) solve(); return 0; } 移位运算 \u0026laquo; \u0026raquo; 左移高位溢出直接丢掉，右移低位溢出直接丢掉。 左移相当于 ×2 右移相当于 /2 一般不对负数移位，移位时会把符号位也移出去。\n取反运算 ~ 按位取反\n双指针 特征：1.两个指针在同一个容器内 2.一快一慢 3.只往同一个方向走 4.区间内维护某种条件 伪代码实现(求和为目标值的数)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Input: nums[] (升序数组), target (目标值) Output: pairs (所有满足条件的数对) 1. 初始化: left = 0, right = len(nums) - 1 pairs = [] 2. 开始移动指针: while left \u0026lt; right: sum = nums[left] + nums[right] if sum == target: pairs.append((nums[left], nums[right])) left += 1 right -= 1 else if sum \u0026lt; target: left += 1 # 需要更大的值 else: right -= 1 # 需要更小的值 3. 返回结果: return pairs eg: 题目描述:本题有 ( T ) 组测试样例，对于每组样例：给定一个长度为 ( n ) 的数组，求其中最长的连续且无重复数字的子序列的长度。 输入格式:第一行一个整数 ( T )，表示样例数。 ( (1 \\leq T \\leq 10) ) 第一行一个整数 ( n )。 ( \\left(1 \\leq n \\leq 10^5\\right) ) 第二行 ( n ) 个整数 ( a_i )。 ( \\left(1 \\leq a_i \\leq 10^5\\right) ) 数据保证 ( \\sum n \\leq 10^5 )。 输出格式:一个整数表示答案。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2e5 + 9; int a[N], c[N]; // a[N]是读入的数组 c[N]用来记录数组中每个数的出现次数，其实是采用了桶的思想 void solve() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n; ++i) c[a[i]] = 0; ll ans = 0; for (int i = 1, j = 0; i \u0026lt;= n; ++i) { while (j \u0026lt; n \u0026amp;\u0026amp; !c[a[j + 1]]) c[a[++j]]++; // 若当前数字 a[j+1]在窗口内没有重复（c[a[j+1]] == 0），右移 j，并将 c[a[j+1]] 计数增加，表示该数字进入窗口。 ans = max(ans, j - i + 1ll); c[a[i]]--; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _; cin \u0026gt;\u0026gt; _; while (_--) solve(); return 0; } 二分 二分法（Binary Search）是一种在有序数组中查找特定元素的高效算法。它通过将目标值与数组中间元素进行比较，从而将搜索范围缩小一半，这使得二分法的时间复杂度为 O(log n)，其中 n 是数组的长度。二分法也可以扩展到查找最小值、最大值、满足特定条件的第一个或最后一个元素等。 二分里重要的两个函数： lower_bound（起始位置，结束位置，给定值） lower_bound 函数返回一个迭代器，指向容器中第一个不小于给定值的元素。如果所有元素都小于给定值，则返回指向容器末尾的迭代器。 upper_bound（起始位置，结束位置，给定值） upper_bound 函数返回一个迭代器，指向容器中第一个大于给定值的元素。如果所有元素都不大于给定值，则返回指向容器末尾的迭代器。 二分思路： 1.确定二分范围，即l和r 2.循环条件一定是while(l + 1 != r) 3.mid = (l + r) / 2 4.if(check()) l == mid (或者 r == mid) 5.else r == mid (或者 l == mid) 伪代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Input: nums[] (升序数组), target (查找的目标值) Output: index (找到的目标值下标，若不存在则返回 -1) 1. 初始化: left = 0, right = len(nums) - 1 2. 开始查找: while left \u0026lt;= right: mid = left + (right - left) / 2 if nums[mid] == target: return mid # 找到目标值 else if nums[mid] \u0026lt; target: left = mid + 1 # 排除左半部分 else: right = mid - 1 # 排除右半部分 3. 未找到: return -1 事实上 要记住 mid即是你想要的答案，所做的每一步就是把mid夹逼到题目所问的位置 eg: 二分查找模板 题目描述:给定一个大小为 ( n ) 的单调不减的非负整数序列 ( a )（下标从 1 开始），再给出 ( q ) 个询问。对于每个询问，给出一个整数 ( x )，你需要回答出，( x ) 第一次在给定序列 ( a ) 中出现的下标。 输入描述:第一行：两个整数 ( n, q )。 ( \\left(1 \\leq n, q \\leq 2 \\times 10^5\\right) ) 第二行：( n ) 个整数，表示 ( a_1, a_2, \\cdots, a_n )。 ( \\left(0 \\leq a_i \\leq 10^9, 1 \\leq i \\leq n\\right) ) 第三行：( q ) 个整数，表示询问的具体数字。 ( \\left(0 \\leq x \\leq 10^9\\right) ) 输出描述:共一行，( q ) 个整数，表示每个询问数字在序列中第一次出现的下标，若不存在，则为 -1。请注意，每个整数后为空格，而不是换行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2e5 + 9; int a[N]; void solve() { int n, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; while (q--) { int x; cin \u0026gt;\u0026gt; x; int l = 0, r = n; // 注意这里的初始值应该是 1 和 n，因为数组是从 1 开始索引的 while (l + 1 != r) { int mid = (l + r) / 2; if (a[mid] \u0026lt; x) l = mid; else r = mid; } if (a[r] == x) cout \u0026lt;\u0026lt; r \u0026lt;\u0026lt; \u0026#39; \u0026#39;; else cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } eg:题目描述：Farmer John建造了一个有 ( N )（( 2 \\leq N \\leq 10^5 )）个隔间的牛棚，这些隔间分布在一条直线上，坐标是 ( x_1, x_2, \\cdots, x_N )（( 0 \\leq x_i \\leq 10^9 )）。他的 ( C )（( 2 \\leq C \\leq N )）头牛不满于隔间的位置分布，它们为牛棚里其他的牛的存在而愤怒。为了防止牛之间的互相打斗，Farmer John想把这些牛安置在指定的隔间，所有牛中相邻两头的最近距离越大越好。那么，这个最大的最近距离是多少呢？ 输入格式：第 1 行：两个用空格隔开的数字 ( N ) 和 ( C )。第 2 至 ( N+1 ) 行：每行一个整数，表示每个隔间的坐标。 输出格式：输出只有一行，即相邻两头牛最大的最近距离。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2e5 + 9; int a[N], n, c; int f(int mid) // 在mid的条件下 能放的牛的最大数量 （放的牛数量越大，相邻两头的最近距离越小） { int res = 0; int pre = -1e9; // res是贪心算法算出的可以放置牛的最大数量 pre表示上一个放了牛的点的位置 for (int i = 1; i \u0026lt;= n; ++i) { if (a[i] - pre \u0026gt;= mid) { res++; pre = a[i]; } } return res; } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; c; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; sort(a + 1, a + 1 + n); int l = 0; int r = 1e9 + 10; while (l + 1 != r) { int mid = (l + r) / 2; if (f(mid) \u0026gt;= c) l = mid; else r = mid; } cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 排序 排序并去重模板 sort(a.begin(),a.end()); a.erase(unique(a.begin(),a.end()),a.end()); sort(a,b)是一个左闭右开的区间 从小到大排序 若要从大到小 则再reverse(a,b)即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1005; vector\u0026lt;int\u0026gt; a; int main() { ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); int n; cin \u0026gt;\u0026gt; n; a.resize(n+1); for(int i = 1; i \u0026lt;= n; ++i) { int x; cin \u0026gt;\u0026gt; x; a.push_back(x); } sort(a.begin(),a.end()); a.erase(unique(a.begin(),a.end(),a.end())); return 0; } 结构体排序模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2e5 + 9; struct A { int a,b,c; //函数重载： bool operator \u0026lt; (const A \u0026amp;u) const { if (a == u.a \u0026amp; b == u.b) return c \u0026lt;u.c; else if (a == u.a) return b \u0026lt;u.b; return a \u0026lt; u.a; } }p[N]; int main() { ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); int n; cin \u0026gt;\u0026gt; n; for(int i = 1;i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; p[i].a \u0026gt;\u0026gt; p[i].b \u0026gt;\u0026gt; p[i].c; sort(p+1,p+1+n); for(int i = 1;i \u0026lt;= n; ++i) cout \u0026lt;\u0026lt;p[i].a \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; p[i].b \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;p[i].c \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; ; return 0; } 桶排序模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2e5 + 9; int c[N]; int main() { ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); int n; cin \u0026gt;\u0026gt; n; for(int i = 1; i \u0026lt;= n;++i) { int x;cin\u0026gt;\u0026gt;x; c[x] ++; } for(int i = 0;i \u0026lt;= 2e5; ++i) { for(int j = 0; j \u0026lt; c[i]; ++j) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt;\u0026#39; \u0026#39;; } } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 3.栈、优先队列、map、set、bitset 栈 栈：先进后出的数据结构（一个放在地上的桶） 维护栈的时候只维护栈顶\n题目描述：现在有 ( n ) 部火车，每一部火车都有一个1~( n ) 的编号且各不相同（火车编号构成一个排列）。现在他们按照给定的顺序排列在一条轨道上，只能按照箭头所指方向移动，问他们能否通过一个车站，且每部火车至多进站一次，使得出站口的编号顺序变为升序（即出站顺序为 1, 2, 3,\u0026hellip;）？如果可以输出 \u0026ldquo;Yes\u0026rdquo;，如果不行输出 \u0026ldquo;No\u0026rdquo;。（不带引号） 输入格式：第一行一个整数 ( n )。 ( (1 \\leq n \\leq 10^5) ) 第二行 ( n ) 个整数 ( a_i ) 表示在进站口的编号。 ( (1 \\leq a_i \\leq n, a_i \\neq a_j) ) 输出格式：如果可以变为升序输出 \u0026ldquo;Yes\u0026rdquo;，反之输出 \u0026ldquo;No\u0026rdquo;。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e5 + 9; int a[N], pos; void solve() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; // 右边待进站列车 stack\u0026lt;int\u0026gt; stk; pos = 1; // 表示当前是第几辆车 // i表示左边轨道所需的列车编号 for (int i = 1; i \u0026lt;= n; ++i) { // 如果不是想要的（目标列车存在且车站是空的或者栈顶不是目标列车） 就一直找（右侧进站） while (pos \u0026lt;= n \u0026amp;\u0026amp; (stk.empty() || stk.top() != i)) stk.push(a[pos++]); // 找到了目标列车 则弹出（目标列车进入左侧轨道） if (stk.top() == i) stk.pop(); else { cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return; } } cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 优先队列/堆(priority_queue) 是一种二叉树状结构，只对堆顶(top)进行维护，堆顶元素是最大/最小的（由比较函数决定）默认是大根堆 eg:题目描述：你有一个菜篮子。 接下来 ( Q ) 次操作，每次操作如下：\n\u0026ldquo;1 x\u0026rdquo;，将一个重量为 ( x ) 的菜放入到菜篮子中。 \u0026ldquo;2\u0026rdquo;，将菜篮子中重量最大的菜丢掉（如果菜篮子为空，则跳过）。 问 ( Q ) 次操作后，菜篮子中剩下的菜的总重量。 输入描述： 第一行一个整数 ( Q )，表示操作次数。 ( \\left(1 \\leq Q \\leq 10^5\\right) ) 接下来 ( Q ) 行，每行一条操作。 ( \\left(1 \\leq x \\leq 10^9\\right) ) 输出描述:一个整数表示答案。 注意，优先队列里没有对于队列里所有元素求和sum的内置函数，需要自己维护\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e5 + 9; void solve() { int q; cin \u0026gt;\u0026gt; q; priority_queue\u0026lt;ll\u0026gt; pq; ll sum = 0; while (q--) { int op; cin \u0026gt;\u0026gt; op; if (op == 1) { ll x; cin \u0026gt;\u0026gt; x; pq.push(x); sum += x; } else if (pq.size()) { sum -= pq.top(); pq.pop(); } } cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 小根堆模板1\n1 priority_queue\u0026lt;ll,vector\u0026lt;ll\u0026gt;,greater\u0026lt;ll\u0026gt;\u0026gt; pq; 小根堆模板2\n1 2 3 4 5 6 7 8 struct cmp { bool oprator()(const ll \u0026amp;u,const ll \u0026amp;v)const { return u \u0026gt; v; } } priority_queue\u0026lt;ll,vector\u0026lt;ll\u0026gt;,cmp\u0026gt; pq; map map 是一个关联容器，它存储了键值对（key-value pairs）。std::map 中的元素是按键排序的，通常是根据键的顺序自动排序的，这意味着它是一个有序的容器。std::map 基于红黑树实现，这确保了即使在最坏情况下，基本操作（如查找、插入和删除）的时间复杂度也是对数级的（O(log n)）。 map可用[]运算符像数组一样操作,只不过下表变成了键值，也可以像普通STL一样用内置函数操作。一般不做erase只做insert之后进行查找即通过key去找value。 常用专门函数: count(key) 返回key所对应的value的个数（0/1）。 find(key) 返回key所对应的iterator,若iterator = end()，说明没有这个key。 eg:题目描述：空中有 ( n ) 个气球，第 ( i ) 个气球有一个颜色 ( col_i )（用一个字符串表示）。请你求出每种气球的个数，按照气球出现的顺序进行排序输出。 输入描述：第一行一个整数 ( T ) 表示样例个数。 ( (1 \\leq T \\leq 10) ) 对于每个样例，第一行一个整数 ( n ) 表示气球个数。 ( (1 \\leq n \\leq 100) ) 接下来 ( n ) 行，每行一个字符串表示 ( col_i )。 ( \\left(1 \\leq |col_i| \\leq 50\\right) ) 字符串仅包含小写英文字母。 输出描述：对于每个样例，输出所有气球的种类和个数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e5 + 9; int a[N], pos; void solve() { map\u0026lt;string, int\u0026gt; mp; // mp[s]表示s的数量 vector\u0026lt;string\u0026gt; v; // 表示字符串出现的顺序 int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) { string s; cin \u0026gt;\u0026gt; s; if (mp.count(s)) mp[s]++; else v.push_back(s), mp[s] = 1; } for (auto \u0026amp;i : v) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; mp[i] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _; cin \u0026gt;\u0026gt; _; while (_--) solve(); return 0; } set set是一个基于平衡二叉搜索树（通常是红黑树）实现的关联容器，它存储唯一的元素，并且元素会按照特定的顺序自动排序（默认升序）。set中的元素是唯一的，这意味着不允许有重复的元素。插入、删除、查找效率都很高。 eg: 题目描述:给定一个大小为 ( n ) 的整型数组 ( a )，你需要对其按照升序排序并进行去重。 输入描述:第一行：一个整数 ( n )。 ( (1 \\leq n \\leq 2 \\times 10^5) ) 第二行：( n ) 个整数，表示数组 ( a ) 的所有元素。 ( \\left(-10^9 \\leq a_i \\leq 10^9, 1 \\leq i \\leq n\\right) ) 输出描述:共一行，( n ) 个整数，表示进行升序排序并进行去重后的数组。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e5 + 9; int a[N]; void solve() { int n; cin \u0026gt;\u0026gt; n; set\u0026lt;int\u0026gt; st; for (int i = 1; i \u0026lt;= n; ++i) { int x; cin \u0026gt;\u0026gt; x; st.insert(x); } for (auto \u0026amp;i : st) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } bitset bitset 是一个固定大小的位集合容器，它提供了一种高效的方式来存储和操作二进制位。bitset 模板的参数指定了位集合中位的数量，并且所有的位最初都被设置为 0。可以理解为一个很长二进制数，右边是低位左边是高位，每位都只能0/1。只支持位运算不支持算术运算。 可以当作一个bool[]来用。 常用函数：count()返回1的个数;reset()各位全部置零 eg:题目描述：给定 ( n ) 个整数，问由这些整数通过“加法”操作，可以组成多少种数字？ 输入格式：第一行一个整数 ( n )。 ( \\left(1 \\leq n \\leq 5 \\times 10^3\\right) ) 第二行 ( n ) 个整数。 ( \\left(1 \\leq a_i \\leq 100\\right) ) 输出格式：一个整数表示答案。 需要借助dp（动态规划的思想）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e5 + 9, M = 5e5 + 9; int a[N]; void solve() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; bitset\u0026lt;M\u0026gt; bs; bs[0] = 1; for (int i = 1; i \u0026lt;= n; ++i) bs |= (bs \u0026lt;\u0026lt; a[i]); // 先把上一轮的左移a[i]位（相当于上一轮的每个数都加上a[i]），再与上一轮的相或（相当于复制上一轮结果）。 cout \u0026lt;\u0026lt; bs.count() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 4.单调栈、单调队列 单调栈 单调栈是一种单调递增或单调递减的栈。它只允许在栈的顶部插入和删除元素，但插入和删除的操作受到栈的单调性限制。 一般用单调栈不直接存元素 而是去存这个元素的下标 因为如果用元素是无法反推得到下标的 且，一般用数组来实现单调栈而不是stl里的stack\neg:题目描述:给定一个长度为 ( n ) 的整数数组 ( a )，你需要求出每个元素的左边离它最近且比它小的元素。 输入描述:第一行：一个整数 ( n )。 ( \\left(1 \\leq n \\leq 2 \\times 10^5\\right) ) 第二行：( n ) 个整数，表示整数数组 ( a )。 ( \\left(1 \\leq a_i \\leq 10^9\\right) ) 输出描述:共一行，( n ) 个整数，表示每个元素的左边第一个比它小的元素，若不存在则为 -1。 单调栈模板题 1.用stl实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2e5 + 9; int a[N], l[N]; // l[N]就是求每个元素的左边第一个比它小的元素 void solve() { int n; cin \u0026gt;\u0026gt; n; stack\u0026lt;int\u0026gt; st; // 这里题目要求的就是元素值 因此不用下标，直接存value for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n; ++i) { while (st.size() \u0026amp;\u0026amp; st.top() \u0026gt;= a[i]) { st.pop(); } // st.size() 用于确保在调用 st.top() 之前栈是非空的。 // st.empty() 用于在循环内部检查栈是否为空，并根据情况更新 l[i] 的值。 if (st.empty()) l[i] = -1; // 栈为空 else l[i] = st.top(); // 栈非空 st.push(a[i]); } for (int i = 1; i \u0026lt;= n; ++i) cout \u0026lt;\u0026lt; l[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); } 单调栈模板题 2.用数组实现 清除效率更高，可以lazyclear(脏数据留下不用管他 直接清除top即可)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2e5 + 9; int a[N], l[N], stk[N], top; // 在单调栈stk里存放的是下标 void solve() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n; ++i) { while (top \u0026amp;\u0026amp; a[stk[top]] \u0026gt;= a[i]) top--; if (top) l[i] = a[stk[top]]; else l[i] = -1; stk[++top] = i; } for (int i = 1; i \u0026lt;= n; ++i) cout \u0026lt;\u0026lt; l[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); } 单调队列 单调队列是一种单调递增或单调递减的队列。它允许在队列的前端和后端插入和删除元素，但插入和删除的操作受到队列的单调性限制。 普通的queue只能对头进行弹出 因此构造单调队列是一般用双端队列deque 其中front是头，back是尾 deque = deque()或while(dq.size())dq.pop_back();可以清空 队列里存的也是下标 而不是值 eg：x1 x2 x3 x4 而所说的单调是指 f(x)单调的 即 f(x1) \u0026gt; f(x2) \u0026gt; f(x3) \u0026gt; f(x4) 思路： 1.for()进入循环 2.检测队头合法性：while(队列非空且头不合法)弹出队头 pop_front 3.检测队尾优越性：while(队列非空且当前的i的值优于队尾) 弹出队尾 pop_back 4.push_back(i) 5.输出队头即为最优\neg:题目描述:给定一个长度为 $n$ 的数组 $a$。有一个大小为 $k$ 的滑动窗口（窗口中只能看到 $k$ 个元素），它从数组的最左边，每次向右移动一个位置，直到移动到最右边。你需要回答出滑动窗口在每个位置时，窗口中的最大值和最小值。 输入描述:第一行：两个整数 $n, k$。 ($1 \\leq k \\leq n \\leq 2 \\times 10^5$)第二行：$n$ 个整数，代表数组 $a$。 ($-10^6 \\leq a_i \\leq 10^6, 1 \\leq i \\leq n$) 输出描述:第一行：从左到右，滑动窗口在每个位置的最大值。第二行：从左到右，滑动窗口在每个位置的最小值。 单调队列作滑动窗口模板题 1.用stl实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2e5 + 9; int a[N]; void solve() { int n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; deque\u0026lt;int\u0026gt; dq; for (int i = 1; i \u0026lt;= n; ++i) // 找最大值 { // 以i为右端点 区间大小为k 即[i-k+1,i] // 1.队头合法性： while (dq.size() \u0026amp;\u0026amp; dq.front() \u0026lt;= i - k) dq.pop_front(); // 2.队尾优越性： while (dq.size() \u0026amp;\u0026amp; a[dq.back()] \u0026lt;= a[i]) dq.pop_back(); dq.push_back(i); if (i \u0026gt;= k) cout \u0026lt;\u0026lt; a[dq.front()] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; dq = deque\u0026lt;int\u0026gt;(); // 清空dq for (int i = 1; i \u0026lt;= n; ++i) // 找最小值 { // 以i为右端点 区间大小为k 即[i-k+1,i] while (dq.size() \u0026amp;\u0026amp; dq.front() \u0026lt;= i - k) dq.pop_front(); while (dq.size() \u0026amp;\u0026amp; a[dq.back()] \u0026gt;= a[i]) dq.pop_back(); dq.push_back(i); if (i \u0026gt;= k) cout \u0026lt;\u0026lt; a[dq.front()] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); } 单调队列作滑动窗口模板题 2.用数组实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2e5 + 9; int a[N],dq[N],head,tail; void solve() { int n,k;cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for(int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; int head = 1, tail = 0; //求最大： for(int i = 1; i \u0026lt;= n; ++i) { while(head \u0026lt;= tail \u0026amp;\u0026amp; dq[head] \u0026lt;= i - k) head ++; while(head \u0026lt;= tail \u0026amp;\u0026amp; a[dq[tail]] \u0026lt;= a[i]) tail --; dq[++ tail] = i; if(i \u0026gt;= k) cout \u0026lt;\u0026lt;a[dq[head]] \u0026lt;\u0026lt;\u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; head = 1; tail = 0; //求最小： for(int i = 1; i \u0026lt;= n; ++i) { while(head \u0026lt;= tail \u0026amp;\u0026amp; dq[head] \u0026lt;= i - k) head ++; while(head \u0026lt;= tail \u0026amp;\u0026amp; a[dq[tail]] \u0026gt;= a[i]) tail --; dq[++ tail] = i; if(i \u0026gt;= k) cout \u0026lt;\u0026lt;a[dq[head]] \u0026lt;\u0026lt;\u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); int _ = 1 ; while(_--) solve(); } eg:给定一个大小为n的整数序列a（下标从1开始），你需要求出该序列所有子区间最小值的和，即 $$ \\sum_{i=1}^{n}\\sum_{j=i}^{n}\\operatorname{min}\\left(a_{i}, a_{i+1},\\cdots, a_{j}\\right) $$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2e5 + 9; ll a[N],l[N],r[N]; //l[N] : i左边最近的\u0026lt;= a[i]的位置 r[N]：i右边最近的\u0026lt;a[i]的位置 int stk[N],top; //数组模拟单调栈 void solve() { int n;cin \u0026gt;\u0026gt; n; for(int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; //先求l[] \u0026lt; a[i] for(int i = 1; i \u0026lt;= n; ++i) { while(top \u0026amp;\u0026amp; a[stk[top]] \u0026gt;= a[i]) top--; //此时栈顶就是l[i] if(!top) l[i] = 0; else l[i] = stk[top]; stk[++top] = i; } top = 0; for(int i = n; i \u0026gt;= 1; -- i) { //上面是\u0026gt;=这里就是\u0026lt; 左闭右开 while(top \u0026amp;\u0026amp; a[stk[top]] \u0026gt; a[i]) top--; if(!top) r[i] = n + 1; else r[i] = stk[top]; stk[++top] = i; } ll ans = 0; for(int i = 1; i \u0026lt;= n; ++i) ans += a[i]*(r[i] - i) *(i - l[i]); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); int _ = 1 ; while(_--) solve(); } 5.树状数组和离散化 树状数组 树状数组（Binary Indexed Tree，简称 BIT 或 Fenwick Tree）是一种数据结构，用于高效地处理数组上的累积和（前缀和）问题，特别是对于区间求和(O(logn))和单点更新(O(1))操作。它通过构建一个辅助数组来实现对原始数组的快速查询和更新。 树状数组并不是树结构，而是通过一个一维数组实现的。它利用了二进制表示的特性，将原始数组中的每个元素映射到树状数组中的多个位置，从而实现区间和的快速计算。 注意：1.一定不能用0当下标 2.开数组的时候的大小与原数组一样 lowbit 操作：对于一个整数 x，lowbit(x) 表示 x 的二进制表示中最低位的 1。例如，lowbit(10) = 2，因为 10 的二进制表示为 1010，最右边的 1 位于第 2 位（从 0 开始计数） ！！！相当于 （x \u0026amp; -x）！！！ 树状数组的原理： 树状数组的核心思想是将原始数组的每个元素映射到一个新的数组（树状数组）中的多个位置，从而实现快速的区间求和。这个映射是基于二进制表示的，特别是基于一个数的二进制表示中最低位的 1（即 lowbit）。 优势：单点修改 区间求和 单点修改： 更新操作涉及到将一个值加到原始数组的某个位置上，然后更新树状数组中所有受到这个更新影响的位置。具体来说，从 i 开始，每次将i加上 lowbit(i)，直到 i 超过数组的大小。 区间求和： 查询操作涉及到计算原始数组中从索引 1 到 i 的所有元素的累积和。这可以通过遍历树状数组中所有 i 的 lowbit(i)位置来实现，将这些位置上的值累加起来。 伪代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 Input: n (数组大小), arr[] (初始数组) Output: fenwick[] (树状数组) 1. 初始化: fenwick[i] = 0 (大小为 n + 1，因为从 1 开始存储) 2. 单点更新: function update(index, delta): while index \u0026lt;= n: fenwick[index] += delta index += index \u0026amp; (-index) # 移动到下一个父节点 3. 查询前缀和: function query(index): sum = 0 while index \u0026gt; 0: sum += fenwick[index] index -= index \u0026amp; (-index) # 移动到前一个节点 return sum 4. 构建树状数组: for i = 1 to n: update(i, arr[i]) 5. 查询任意区间 [l, r]: function range_query(l, r): return query(r) - query(l - 1 eg:题目描述:给定一个大小为 ( n ) 的数组 ( a ) 和 ( q ) 次操作。每次操作分为下面两种：\n\u0026ldquo;1 ( k ) ( v )\u0026quot;：给 ( a_k ) 加上 ( v )。 \u0026ldquo;2 ( l ) ( r )\u0026quot;：查询区间 ([l, r]) 的和。 对于每次2操作，输出结果。 输入格式:第一行两个整数 ( n, q )。 ( \\left(1 \\leq n, q \\leq 2 \\times 10^5\\right) ) 第二行 ( n ) 个整数表示数组 ( a )。 ( \\left(-10^5 \\leq a_i \\leq 10^5\\right) ) 接下来 ( q ) 行，每行一个操作。 ( (1 \\leq l \\leq r \\leq n, -10^5 \\leq v \\leq 10^5) ) 输出格式:对于每次2操作，在一行内输出结果。 树状数组单点修改模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2e5 + 9; int a[N], t[N]; // t数组即树状数组 int n, q; int lowbit(int x){ return x \u0026amp; -x;} void update(int k, ll x) { for (int i = k; i \u0026lt;= n; i += lowbit(i))t[i] += x; // a_k加多少，所有覆盖到a_k的树状数组也要加多少 // 通过每一个+lowbit找到下一个覆盖a_k的树状数组 } ll getsum(int k) { ll res = 0; for (int i = k; i \u0026gt; 0; i -= lowbit(i))res += t[i]; //通过每一个-lowbit找到与当前树状数组无缝衔接的上一个 return res; } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n; ++i)update(i, a[i]); while (q--) { int op; cin \u0026gt;\u0026gt; op; if (op == 1) { ll k, v; cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; v; update(k, v); } else { ll l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; cout \u0026lt;\u0026lt; getsum(r) - getsum(l - 1) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } eg：题目描述:给定一个大小为 ( n ) 个数组 ( a )，( q ) 次操作。每次操作分为下面两种：\n\u0026ldquo;1 ( l ) ( r ) ( v )\u0026quot;：给区间 ([l, r]) 中的数组加上 ( v )。 \u0026ldquo;2 ( l ) ( r )\u0026quot;：查询区间 ([l, r]) 中数字的和。 对于每次2操作，输出结果。 输入格式:第一行两个整数 ( n, q )。 ( \\left(1 \\leq n, q \\leq 2 \\times 10^5\\right) ) 第二行 ( n ) 个整数表示数组 ( a )。 ( \\left(-10^5 \\leq a_i \\leq 10^5\\right) ) 接下来 ( q ) 行，每行一个操作。 ( \\left(1 \\leq l \\leq r \\leq n, -10^5 \\leq v \\leq 10^5\\right) ) 输出格式:对于每次2操作，在一行内输出结果。 思路： 用树状数组来维护差分d[]。 a[1]=d[1];a[2]=d[1]+d[2];a[3]=d[1]+d[2]+d[3]…… 而[ \\sum_{i=1}^{r} a_i = \\sum_{i=1}^{r} (r+1)d_i - \\sum_{i=1}^{r} id_i ] 可以把原数组拆成两个数组，分别叫做t1（来表示式子中的di的累加）,t2（来表示式子中的i*di的累加）。每一次的区间修改，就转化成了在t1和t2这两个数组上的单点修改，就可以化为模型1。 树状数组区间修改模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2e5 + 9; ll a[N], td[N], itd[N]; int lowbit(int x) { return x \u0026amp; -x; } int n, q; void update(int k, ll x) { for (int i = k; i \u0026lt;= n; i += lowbit(i)) td[i] += x, itd[i] += k * x; } ll getsum(int k) { ll res = 0; for (int i = k; i \u0026gt; 0; i -= lowbit(i)) res += (k + 1) * td[i] - itd[i]; return res; } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n; ++i) { // 用差分数组的逻辑来进行区间修改 update(i, a[i]); update(i + 1, -a[i]); } while (q--) { int op; cin \u0026gt;\u0026gt; op; if (op == 1) { ll l, r, v; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; v; update(l, v); ; update(r + 1, -v); } else { ll l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; cout \u0026lt;\u0026lt; getsum(r) - getsum(l - 1) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } eg:题目描述:给定一个长度为 ( n ) 的数组 ( a )，求 ( a ) 的逆序对个数。逆序对的定义是一个二元组 ( (a_i, a_j) )，满足：( i \u0026lt; j ) 且 ( a_i \u0026gt; a_j )。 输入格式:一个整数 ( n )。 ( \\left(1 \\leq n \\leq 2 \\times 10^5\\right) ) 接下来一行 ( n ) 个整数表示数组 ( a )。 ( \\left(1 \\leq a_i \\leq 10^9\\right) ) 输出格式:一行输出一个结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2e5 + 9; ll a[N], t[N]; int n, q; vector\u0026lt;int\u0026gt; X; // 用来做离散化数组 int bin(int x) // 通过元素找下标 { return lower_bound(X.begin(), X.end(), x) - X.begin() + 1; } int lowbit(int x) { return x \u0026amp; -x; } void update(int k, int x) { for (int i = k; i \u0026lt;= X.size(); i += lowbit(i)) t[i] += x; } int getsum(int k) { int res = 0; for (int i = k; i \u0026gt; 0; i -= lowbit(i)) res += t[i]; return res; } void solve() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) { cin \u0026gt;\u0026gt; a[i]; X.push_back(a[i]); } sort(X.begin(), X.end()); X.erase(unique(X.begin(), X.end()), X.end()); ll ans = 0; for (int i = 1; i \u0026lt;= n; ++i) { ans += getsum(X.size()) - getsum(bin(a[i])); // 因为已经排序 所以：所有的 - 小于等于a[i]的 = 严格比a[i]大的 update(bin(a[i]), 1); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 离散化 离散化（Discretization）是一种处理连续数据的技术，它将连续的数值或区间映射到离散的整数上。这种方法在算法设计和数据分析中非常有用，尤其是在处理区间问题、范围查询、几何问题和优化问题时。离散化的目的是简化问题，使其能够在整数上高效地处理。 思路： 1.找出所有与结果有关的相关点 用离散化数组存下来 2.将相关点排序并去重（模板） 3.把原数组映射至离散化数组上 离散化数组也要能映射至原数组中（找下标） 4.把原本在原数组上的操作改到离散化数组中来做，实现数据量降维 伪代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Input: nums[] (需要离散化的数组) Output: discrete_map (原值到离散值的映射) 1. 去重并排序: sorted_nums = sort(unique(nums)) 2. 构建映射: discrete_map = {} for i = 0 to len(sorted_nums) - 1: discrete_map[sorted_nums[i]] = i + 1 3. 转换数组: for i = 0 to len(nums) - 1: nums[i] = discrete_map[nums[i]] 4. 返回结果: return nums, discrete_map eg:题目描述:小e有一个很长很长的数组，数组的下标范围为 (\\left[0,10^9\\right])，初始时每个元素均为0。现在，他想进行 ( n ) 次操作，每次操作将某个下标 ( i ) 处的元素加上 ( x )。然后他给出了 ( q ) 次询问，每个询问格式为 ( l, r )，你需要回答出下标在区间 ([l, r]) 内的所有元素的和。 输入描述:第一行：两个整数 ( n, q )。 ( (1 \\leq n, q \\leq 10^5) ) 接下来 ( n ) 行：每行两个整数 ( i, x )。 ( \\left(0 \\leq i \\leq 10^9, 0 \\leq x \\leq 10^4\\right) ) 再接下来 ( q ) 行：每行两个整数 ( l, r )。 ( \\left(0 \\leq l \\leq r \\leq 10^9\\right) ) 输出描述:共 ( q ) 行，每行输出相应询问的答案。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 3e5 + 9; ll a[N]; // 存离散化数组对应的数组 vector\u0026lt;int\u0026gt; X; // 离散化数组（存的是下标） struct Q // 创建结构体存放操作和询问 { ll a, b; } op[N], query[N]; int getidx(ll x) // 找下标 { // lower_bound：找出数组中第一个 \u0026gt;= x 的迭代器 return lower_bound(X.begin(), X.end(), x) - X.begin() + 1; // 返回值的范围是[1,X.size()] } void solve() { int n, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; ++i) { ll x, w; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; w; // x是题中下标i，w是元素加的那个x X.push_back(x); // 记录所有用得到的下标 op[i] = {x, w}; } for (int i = 1; i \u0026lt;= q; ++i) { ll l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; X.push_back(l), X.push_back(r); query[i] = {l, r}; } // 排序去重 sort(X.begin(), X.end()); X.erase(unique(X.begin(), X.end()), X.end()); for (int i = 1; i \u0026lt;= n; ++i) { int x = getidx(op[i].a); ll w = op[i].b; a[x] += w; } for (int i = 1; i \u0026lt;= X.size(); ++i) a[i] += a[i - 1]; // 更新a[i]直接作前缀和 for (int i = 1; i \u0026lt;= q; ++i) { int l = getidx(query[i].a); int r = getidx(query[i].b); cout \u0026lt;\u0026lt; a[r] - a[l - 1] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 6.图的存储、DFS、BFS 图的存储 邻接矩阵 邻接矩阵是一种用于表示图的数据结构，它使用一个二维数组来存储图中顶点之间的连接关系。在邻接矩阵中，行和列分别代表图中的顶点，而矩阵中的元素表示顶点之间的边。 表示无向图和有向图：邻接矩阵可以表示无向图和有向图。对于无向图，邻接矩阵是对称的；对于有向图，如果存在从顶点 i 到顶点 j 的边，则 matrix[i][j] 包含边的权重或存在性，而 matrix[j][i] 通常为 0 或不包含边。 一般用的比较少\n深度优先搜索（DFS） 特点：一条路走到黑 DFS 从起始节点开始，沿着图的边尽可能深地探索，直到到达一个没有未访问邻居的节点，然后回溯到上一个节点，继续探索其他分支。DFS 使用栈（可以是显式的栈或递归调用的隐式栈）来管理已经访问但尚未探索完的节点。DFS 是递归实现的，可以很容易地处理图中的递归结构。 注意 如果可能出现环的话 需要多开一个布尔或bitset vis[i]数组 表示是否已经走过i了。当所查找的点vis[i]=ture，则跳出递归，接着找其他的子节点。 伪代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 Input: n (点数), edges[] (边表), start (起点) Output: visited[] (标记是否访问过) 1. 初始化: visited[i] = false (所有点未访问) graph[i] = [] (使用邻接表表示图) 2. 构建图: for each (u, v) in edges: graph[u].append(v) (无向图需加 graph[v].append(u)) 3. DFS 函数: function dfs(node): visited[node] = true for neighbor in graph[node]: if not visited[neighbor]: dfs(neighbor) 4. 遍历所有点: for i = 1 to n: if not visited[i]: dfs(i) eg: 题目描述:给定一个 $n$ 个点 $m$ 条边的有向图，图中可能存在重边和自环，点的编号为 $1\\sim n$。 你需要求出从点1出发，能够到达的所有点。 输入描述:第一行：两个整数 $n, m$，分别表示有向图的点数、边数。($1 \\leq n, m \\leq 10^5$) 接下来 $m$ 行：每行两个整数 $u_i, v_i$，表示存在一条从 $u_i$ 到 $v_i$ 的有向边。 ($1 \\leq u_i, v_i \\leq n$) 输出描述:共一行，从小到大输出1号点能够到达的点的编号。 dfs模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 60; vector\u0026lt;int\u0026gt; g[N]; int n, m; bitset\u0026lt;N\u0026gt; vis; void dfs(int x) { if (vis[x]) return; // 若走过则跳过 vis[x] = true; for (auto \u0026amp;y : g[x]) dfs(y); } void solve() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; while (m--) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; if (u != v) g[u].push_back(v); // 若不是一个点，则放入邻接表 } dfs(1); for (int i = 1; i \u0026lt;= n; ++i) if (vis[i]) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 全排列 全排列是指从给定的一组元素中，生成所有可能的排列组合。对于一个包含 n 个不同元素的集合，它的全排列数量是 n 的阶乘（n!），即 1 到 n 所有正整数的乘积。 eg:题目描述:给定一个数字 $n$，请按照字典序输出排列 $[1,2,\\ldots,n]$ 的全排列。 输入格式:一个整数 $n$。 ($1 \\leq n \\leq 10$) 输出格式 :一行输出一个结果，按照字典序从小到大排列。 用dfs实现全排列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 19; int a[N], n; bitset\u0026lt;N\u0026gt; vis; void dfs(int dep) // dep表示此时所处的深度 { if (dep == n + 1) // 说明已经走到叶子节点最下面了 需输出 { for (int i = 1; i \u0026lt;= n; ++i) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[i == n]; return; } for (int i = 1; i \u0026lt;= n; ++i) { if (vis[i]) continue; vis[i] = true; a[dep] = i; dfs(dep + 1); // 去下一层 // 出来之后恢复现场： a[dep] = 0; vis[i] = false; } } void solve() { cin \u0026gt;\u0026gt; n; dfs(1); } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 全排列函数模板 按字典序从小到大\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 19; int n, a[N]; void solve() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) a[i] = i; bool go = true; while (go) { for (int i = 1; i \u0026lt;= n; ++i) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; go = next_permutation(a + 1, a + 1 + n); } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 全排列函数模板 按字典序从小到大\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 19; int n, a[N]; void solve() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) a[i] = n + 1 - i; bool go = true; while (go) { for (int i = 1; i \u0026lt;= n; ++i) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; go = prev_permutation(a + 1, a + 1 + n); } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 广度优先搜索（BFS） 特点:像洋葱一样一层一层拨开你的心 BFS 从起始节点开始，首先探索所有邻接的节点，然后对每个邻接节点的未访问邻接节点进行探索，以此类推。BFS 使用队列来管理待访问的节点。BFS 保证找到的是从起点到目标节点的最短路径（如果所有边的权重相同）。 伪代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 Input: n (点数), edges[] (边表), start (起点) Output: dist[] (起点到其他点的最短距离) 1. 初始化: visited[i] = false (所有点未访问) graph[i] = [] (使用邻接表表示图) dist[i] = -1 (所有点初始距离为 -1，表示不可达) queue = [] (空队列) 2. 构建图: for each (u, v) in edges: graph[u].append(v) (无向图需加 graph[v].append(u)) 3. BFS 函数: function bfs(start): queue.push(start) visited[start] = true dist[start] = 0 while queue is not empty: current = queue.pop_front() for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = true dist[neighbor] = dist[current] + 1 queue.push(neighbor) 4. 调用 BFS: bfs(start) eg:题目描述:给定一个 $n$ 个点 $m$ 条边的有向图，图中可能存在重边和自环，点的编号为 $1\\sim n$。 你需要求出从点1出发，能够到达的所有点。 输入描述:第一行：两个整数 $n, m$，分别表示有向图的点数、边数。($1 \\leq n, m \\leq 10^5$) 接下来 $m$ 行：每行两个整数 $u_i, v_i$，表示存在一条从 $u_i$ 到 $v_i$ 的有向边。 ($1 \\leq u_i, v_i \\leq n$) 输出描述:共一行，从小到大输出1号点能够到达的点的编号。 bfs模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e5 + 9; vector\u0026lt;int\u0026gt; g[N]; int n, m; bitset\u0026lt;N\u0026gt; vis; void bfs(int st) { queue\u0026lt;int\u0026gt; q; q.push(st); while (q.size()) { int x = q.front(); q.pop(); if (vis[x]) continue; vis[x] = true; for (auto \u0026amp;y : g[x]) { if (vis[y]) continue; q.push(y); } } } void solve() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; while (m--) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; if (u != v) g[u].push_back(v); // 若不是一个点，则放入邻接表 } bfs(1); for (int i = 1; i \u0026lt;= n; ++i) if (vis[i]) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } eg:题目描述:给定一个大小为 $n \\times m$ 的矩阵，用来表示一个迷宫，矩阵中：0，表示空白处，可以行走；1，表示障碍物，不可通过。最初，小e位于迷宫的左上角 (1,1) 处，每秒钟，他可以向上、左、下、右任意一个方向移动一个位置。现在他想走到迷宫的右下角 $(n, m)$ 处，你能否告诉他，他能否到达目的地，以及若能到达，所需要的最短时间为多少呢？ 输入描述:第一行：两个整数 $n$ 和 $m$ ($1 \\leq n, m \\leq 1000$)，分别表示矩阵的行数和列数。接下来 $n$ 行：每行为 $m$ 个整数 (0 或 1)，表示迷宫矩阵，数据保证 (1,1) 和 $(n,m)$ 均为 0。 输出描述:若无法到达 $(n,m)$，输出 -1；否则，输出所需要的最短时间。 BFS+迪杰斯特拉 求最短路径模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e3 + 9; int mp[N][N]; // 存地图 int d[N][N]; // 表示从起点走到(i,j)所需的最小时间/距离 int n, m; bitset\u0026lt;N\u0026gt; vis[N]; int dx[] = {0, 0, 1, -1}; // 表示上下左右分别对x的变化 int dy[] = {1, -1, 0, 0}; // 表示上下左右分别对y的变化 bool inmp(int x, int y) { return 1 \u0026lt;= x \u0026amp;\u0026amp; x \u0026lt;= n \u0026amp;\u0026amp; 1 \u0026lt;= y \u0026amp;\u0026amp; y \u0026lt;= m; } void bfs(int sx, int sy) { queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q; memset(d, 0x3f, sizeof d); // 初始化为无穷 d[sx][sy] = 0; q.push({sx, sy}); while (q.size()) { int x = q.front().first, y = q.front().second; q.pop(); if (vis[x][y]) continue; // 表示是否已经更新过 vis[x][y] = true; for (int i = 0; i \u0026lt; 4; ++i) { int nx = x + dx[i], ny = y + dy[i]; if (inmp(nx, ny) \u0026amp;\u0026amp; !mp[nx][ny] \u0026amp;\u0026amp; d[nx][ny] \u0026gt; d[x][y] + 1) // 下一步在地图内 且 下一步可走 { d[nx][ny] = d[x][y] + 1; q.push({nx, ny}); } } } } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; ++i) for (int j = 1; j \u0026lt;= m; ++j) cin \u0026gt;\u0026gt; mp[i][j]; bfs(1, 1); if (!vis[n][m]) cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else cout \u0026lt;\u0026lt; d[n][m] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 邻接表 邻接表是图的另一种常用数据结构，用于表示图中顶点之间的关系。与邻接矩阵不同，邻接表更节省空间，尤其是对于稀疏图（边的数量远小于顶点对的数量）。邻接表通过为每个顶点维护一个列表来记录其相邻的顶点，从而表示图的结构。 g[i]表示顶点i的所有出点（由i能够到达的点）编号 在存树时，不需要知道每个点的出入点，只需要知道每个点的父节点就行了。用fa[i]即可表示。 一般用vector来实现 eg:题目描述:给定一棵大小为 $n$，根为 1 的树，求出其 dfs 序、bfs 序。请将所有出点按照编号从小到大排序后进行遍历。解释：dfs 为深度优先搜索，bfs 为宽度优先搜索。 输入格式:一个整数 $n$，表示点的个数。 ($1 \\leq n \\leq 50$)接下来一行 $n-1$ 个整数，第 $i$ 个数字 $fa_i$ 表示点 $i$ 的父亲。($1 \\leq fa_i \\leq n$) 输出格式:第一行输出 dfs 序，第二行输出 bfs 序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 60; int n; int fa[N]; // 存放父节点 vector\u0026lt;int\u0026gt; g[N]; // 存放邻接表 存放每个点的出点 void dfs(int x) // p即双亲 { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; for (auto \u0026amp;y : g[x]) { dfs(y); } } void bfs(int st) { queue\u0026lt;int\u0026gt; q; q.push(st); while (q.size()) { int x = q.front(); //x就是现在所在的节点，开始走他的子节点 q.pop(); cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; for (auto \u0026amp;y : g[x]) q.push(y); //遍历全部子节点放进队列 } } void solve() { cin \u0026gt;\u0026gt; n; for (int i = 2; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; fa[i]; for (int i = 2; i \u0026lt;= n; ++i) g[fa[i]].push_back(i); for (int i = 1; i \u0026lt;= n; ++i) sort(g[i].begin(), g[i].end()); dfs(1); cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; bfs(1); } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 7.并查集、最短路 并查集 并查集（Union-Find）是一种用于处理一些不交集的合并及查询问题的数据结构。它在许多算法问题中都非常有用，特别是在那些需要动态维护元素集合的并集和查询两个元素是否属于同一集合的场景中。 并查集主要有两个操作：查找（Find）：确定两个元素是否属于同一个集合。（原理是去找节点的根，如果两个节点的根是同一个节点，则他们属于有同一个连通块）合并（Union）：将两个元素所在的集合合并。（原理是把一个元素的根连到另一个元素的根，使他们根节点相同） 所以 所有操作都在根上，并不关心某一个具体的节点，而只关心一个连通块的根。 路径压缩（Path Compression）是一种优化技术，用于加速查找（Find）操作。在没有路径压缩的情况下，查找操作可能需要遍历很长的路径才能到达根节点，这会导致查找操作的时间复杂度较高。路径压缩通过在查找过程中将查找路径上的所有节点直接连接到根节点，从而减少未来的查找操作的时间。 伪代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Input: n (元素数量) Output: parent[] (每个点的父节点), size[] (每个集合的大小) 1. 初始化: parent[i] = i (每个点初始化为自己的父节点) size[i] = 1 (每个集合的初始大小为 1) 2. 查找根节点（路径压缩）: function find(x): if parent[x] != x: parent[x] = find(parent[x]) (递归找根节点并路径压缩) return parent[x] 3. 合并两个点所在的集合（按秩合并）: function union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if size[rootX] \u0026lt; size[rootY]: swap(rootX, rootY) (确保 rootX 是较大集合) parent[rootY] = rootX (将 rootY 合并到 rootX) size[rootX] += size[rootY] 4. 判断两个点是否在同一集合: function isConnected(x, y): return find(x) == find(y) eg:题目描述：给定一个无向图，包含 $n$ 个点，$m$ 条边（没有重边和自环）。求图中所有联通块的大小。 输入格式：第一行：两个整数 $n$，$m$，表示点数和边数。（$1 \\leq n, m \\leq 2 \\times 10^5$）接下来 $m$ 行：每行两个整数 $u_i$，$v_i$，表示在 $u_i$ 和 $v_i$ 之间存在一条无向边。 输出格式：从小到大输出所有联通块的大小。 并查集模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e5 + 9; int pre[N], cnt[N];//pre[i]表示i所在的连通块 int root(int x) // 找x所在联通块的根节点 { return pre[x] = (pre[x] == x ? x : root(pre[x])); } void merge(int x, int y) // 做连通块合并 { pre[root(x)] = root(y); } bool isConnected(int x, int y) // 判断是否在同意连通块 { return root(x) == root(y); } void solve() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; ++i) pre[i] = i; for (int i = 1; i \u0026lt;= m; ++i) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; merge(u, v); //每输入一条边 就相当于把两个节点合并 } for (int i = 1; i \u0026lt;= n; ++i) cnt[root(i)]++; vector\u0026lt;int\u0026gt; v; for (int i = 1; i \u0026lt;= n; ++i) { if (cnt[i]) v.push_back(cnt[i]); } sort(v.begin(), v.end()); for (auto \u0026amp;y : v) cout \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 最短路 最短路径问题是图论中的一个经典问题，目的是找到图中两个顶点之间的最短路径。根据图的类型（有向图或无向图）和边的权重（正权重或负权重），最短路径问题的解决方法也有所不同。\n常见的最短路径算法#### Dijkstra 算法 单源最短路径，适用于有向图或无向图，且边的权重必须非负。使用贪心策略，从源点开始，逐步扩展到距离源点最近的顶点。时间复杂度：使用优先队列时为 O((V+E)logV)，其中 V 是顶点数，E 是边数。 思路：创建一个距离数组 dist[]，其中 dist[i] 表示从源点到顶点 i 的最短距离。初始时，将源点到自身的距离设为0，其他所有顶点的距离设为无穷大（INF）。遍历源点的每一条边，用每一条边去更新最短路径。然后在所有点里找距离源点最近的点，遍历它的每一条边，用每一条边去更新最短路径。不断递归，直到遍历了全部的点。 伪代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 朴素数组实现； Input: n (点的数量), graph[n][n] (邻接矩阵, 不存在边时值为 ∞), start (起点) Output: dist[] (从起点到每个点的最短距离) 1. 初始化: dist[] = {∞, ∞, ..., ∞} (长度为 n，所有点的初始距离为无穷大) visited[] = {false, false, ..., false} (长度为 n，标记是否访问过) dist[start] = 0 (起点到自身的距离为 0) 2. 对每个点循环 n 次: a. 从未访问的点中找到距离起点最近的点 u: min_dist = ∞ u = -1 for i = 1 to n: if not visited[i] and dist[i] \u0026lt; min_dist: min_dist = dist[i] u = i b. 如果 u == -1 或 min_dist == ∞，退出循环 (剩余点不可达) c. 标记点 u 为已访问: visited[u] = true d. 更新从 u 到其他点的最短距离: for v = 1 to n: if not visited[v] and graph[u][v] != ∞: dist[v] = min(dist[v], dist[u] + graph[u][v]) 3. 返回 dist[] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 优先队列实现： Input: n (点的数量), graph (邻接表, 每个点存它的边), start (起点) Output: dist[] (从起点到每个点的最短距离) 1. 初始化: dist[] = {∞, ∞, ..., ∞} (所有点的初始距离为无穷大) visited[] = {false, false, ..., false} (标记是否访问过) dist[start] = 0 创建优先队列 pq，初始时插入 (0, start) (距离为 0 的起点) 2. 当队列 pq 不为空时: a. 从队列中弹出当前距离最近的点 (du, u): (du, u) = pq.pop() if visited[u]: continue 标记 u 为已访问: visited[u] = true b. 遍历 u 的所有相邻点 v: if not visited[v]: 新距离 = dist[u] + weight(u, v) if 新距离 \u0026lt; dist[v]: dist[v] = 新距离 pq.push((dist[v], v)) (将更新后的点加入队列) 3. 返回 dist[] eg:题目描述：给定一个 $n$ 个点、$m$ 条边的有向图，要求计算出点 1 到点 $n$ 的最短距离。 输入描述：第一行：两个整数 $n, m$。 ($1 \\leq n \\leq 10^3, 1 \\leq m \\leq 10^5$)接下来 $m$ 行：每行三个整数 $u_i, v_i, w_i$，表示存在一条从 $u_i$ 到 $v_i$，权值为 $w_i$ 的有向边。 ($1 \\leq u_i, v_i \\leq n, 1 \\leq w_i \\leq 10^6$) 输出描述：一个整数，表示点 1 到点 $n$ 的最短距离；若不存在从点 1 到点 $n$ 的路径，则输出 -1。 朴素dijkstra模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e3 + 9; struct Edge { int x, w; // x表示出点，w表示权值 }; vector\u0026lt;Edge\u0026gt; g[N]; ll d[N], n, m; void dijkstra(int st) { memset(d, 0x3f, sizeof(ll) * (n + 1)); d[st] = 0; bitset\u0026lt;N\u0026gt; vis; // 表示已经到达过的点 for (int i = 1; i \u0026lt;= n; ++i) { // 找出距离源点最近的点 int u = 1; for (int j = 1; j \u0026lt;= n; ++j) { if (vis[u] || (!vis[j] \u0026amp;\u0026amp; d[j] \u0026lt; d[u])) u = j; } vis[u] = true; // 此时d[u]就是最近的点 for (auto \u0026amp;[v, w] : g[u]) { if (!vis[v] \u0026amp;\u0026amp; d[v] \u0026gt; d[u] + w) d[v] = d[u] + w; } } } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; ++i) { int u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; if (u != v) g[u].push_back({v, w}); } dijkstra(1); cout \u0026lt;\u0026lt; (d[n] \u0026gt;= 0x3f3f3f3f ? -1 : d[n]) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 优先队列版dijkstra模板 效率更高\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2e5 + 9; struct Edge { int x, w; // x表示出点，w表示权值 bool operator\u0026lt;(const Edge \u0026amp;v) const { return w == v.w ? x \u0026lt; v.x : w \u0026gt; v.w; // 优先比较权值 权值越大，则越\u0026lt; 则越优先 } }; vector\u0026lt;Edge\u0026gt; g[N]; ll d[N], n, m; void dijkstra(int st) { memset(d, 0x3f, sizeof(ll) * (n + 1)); d[st] = 0; bitset\u0026lt;N\u0026gt; vis; // 表示已经到达过的点 priority_queue\u0026lt;Edge\u0026gt; pq; pq.push({st, d[st]}); //将起点作为待到达的点 while (pq.size())//只要队列里还有等待拓展的点 { int x = pq.top().x; pq.pop(); if (vis[x]) continue;//取出的x点已经得到了最短距离d[x] vis[x] = true; for (auto \u0026amp;[y, w] : g[x]) { if (!vis[y] \u0026amp;\u0026amp; d[y] \u0026gt; d[x] + w) { //若vix[y]说明y的最短距离已经计算过，无需更新 d[y] = d[x] + w; pq.push({y, d[y]}); } } } } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; ++i) { int u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; if (u != v) g[u].push_back({v, w}); } dijkstra(1); cout \u0026lt;\u0026lt; (d[n] \u0026gt;= 0x3f3f3f3f ? -1 : d[n]) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 重点语句分析\n1 return w == v.w ? x \u0026lt; v.x : w \u0026gt; v.w; 对于 w != v.w 的情况：\n如果 w \u0026gt; v.w，返回 true：当前 Edge 被认为“较小”。在大顶堆中，它优先级较低，排后。 如果 w \u0026lt; v.w，返回 false：当前 Edge 被认为“较大”。在大顶堆中，它优先级较高，排前。 优先队列默认是大根堆。 Floyd-Warshall 算法 多源最短路径算法，适用于有向图或无向图，可以处理负权重边，但不能有负权重环。通过动态规划方法计算图中所有顶点对的最短路径。时间复杂度：O(V^3)。\n伪代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 Input: n (点的数量), graph[n][n] (邻接矩阵, 不存在边时值为 ∞) Output: dist[n][n] (任意两点之间的最短距离) 1. 初始化: dist[i][j] = graph[i][j] (直接使用输入图作为初始距离矩阵) dist[i][i] = 0 (自己到自己距离为0,自环时注意) 2. 三重循环: for k = 1 to n: (枚举中间点 k) for i = 1 to n: (枚举起点 i) for j = 1 to n: (枚举终点 j) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]) 3. 返回 dist eg:题目描述：给定一个 $n$ 个点、$m$ 条边的有向图。再给出 $q$ 次询问，每个询问为两个整数 $u_i, v_i$，你需要回答从 $u_i$ 到 $v_i$ 的最短距离。 输入描述：第一行：三个整数 $n, m, q$。 ($1 \\leq n \\leq 300, 1 \\leq m, q \\leq 10^5$)。接下来 $m$ 行：每行三个整数 $u_i, v_i, w_i$，表示存在一条从 $u_i$ 到 $v_i$，权值为 $w_i$ 的有向边。 ($1 \\leq u_i, v_i \\leq n, 0 \\leq w_i \\leq 10^6$)可能存在重边和自环。再接下来 $q$ 行，每行两个整数 $u_i, v_i$，表示查询从 $u_i$ 到 $v_i$ 的最短距离。 输出描述：共 $q$ 行：每行一个整数，表示查询的最短距离；若不存在路径，则输出 -1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 300 + 5; const ll inf = 4e18; ll d[N][N], n, m, q; void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q; memset(d, 0x3f, sizeof d); for (int i = 1; i \u0026lt;= m; ++i) { ll u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; d[u][v] = min(d[u][v], w); // 处理重边 } // 初始化： for (int i = 1; i \u0026lt;= n; ++i) d[i][i] = 0; for (int k = 1; k \u0026lt;= n; ++k) for (int i = 1; i \u0026lt;= n; ++i) for (int j = 1; j \u0026lt;= n; ++j) d[i][j] = min(d[i][j], d[i][k] + d[k][j]); while (q--) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; cout \u0026lt;\u0026lt; (d[u][v] \u0026gt;= inf ? -1 : d[u][v]) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 算法对比 算法 适用场景 时间复杂度 优点 缺点 Dijkstra 朴素数组 小规模稠密图 (边多) (O(n^2)) 实现简单 对稀疏图性能较差 Dijkstra 优先队列 大规模稀疏图 (边少) (O((n+m)\\log n)) 性能优异，适合稀疏图 实现稍复杂 Floyd-Warshall 任意两点的最短路径 (小规模图) (O(n^3)) 直接求解任意两点最短路径矩阵 仅适合小规模图 (点多边少时劣势) 8.最小生成树、质因数分解 最小生成树 最小生成树（MST，Minimum Spanning Tree）是图论中的一个重要问题，它指的是在一个连通加权无向图中选择一些边，使得：图中所有节点都被连接。总边权和最小。不会形成环。\n基于点的最小生成树prim算法 Prim算法是一种贪心算法，它从一个起始点开始，不断将未加入的点以最小代价连接到生成树中，直到所有点都被加入。 思想： 使用一个数组 dist[] 存储生成树到每个点的最小代价。 每次选择 dist[] 中代价最小的点加入生成树。 更新 dist[]，表示当前生成树到未加入点的最小代价。 伪代码实现：无优化的朴素prim\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 Input: 图的邻接矩阵 graph[n][n] (无向图) Output: 最小生成树的权值 sum 1. 初始化: dist[] = {INF, INF, ..., INF} (长度为 n，所有元素为无穷大) intree[] = {false, ..., false} (长度为 n，表示点是否在生成树中) dist[0] = 0 (从节点 0 开始) 2. Prim 算法: sum = 0 (最小生成树的权值) for i = 0 to n-1: u = -1 # 找到未加入生成树的点中，dist 最小的点 for v = 0 to n-1: if !intree[v] and (u == -1 or dist[v] \u0026lt; dist[u]): u = v # 将 u 加入生成树 if dist[u] == INF: return -1 (图不连通) intree[u] = true sum += dist[u] # 更新 dist for v = 0 to n-1: if !intree[v] and graph[u][v] != 0: dist[v] = min(dist[v], graph[u][v]) 3. 返回 sum eg:题目描述：给定一个 $n$ 个点、$m$ 条边的无向带权图，图中可能存在重边和自环。求该图的最小生成树的边权之和，若不存在最小生成树则输出 -1。生成树：对于一个无向图，若它的一个子图是包含该无向图全部顶点的树，那么该子图是该无向图的一个生成树。最小生成树：当连接顶点之间的边有权重时，权重之和最小的生成树则为最小生成树。 输入描述：第一行：两个整数 $n, m$。 ($1 \\leq n \\leq 10^5, 1 \\leq m \\leq 10^5$)。接下来 $m$ 行：每行三个整数 $u_i, v_i, w_i$，表示点 $u_i$ 和点 $v_i$ 之间存在一条权重为 $w_i$ 的无向边。 ($1 \\leq u_i, v_i \\leq n, 0 \\leq w_i \\leq 10^6$) 输出描述：共一行，若存在最小生成树，则输出一个整数，表示最小生成树的边权之和；否则，输出 -1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e3 + 9; ll a[N][N], d[N]; // a是邻接矩阵，d是到i点的最短距离 bitset\u0026lt;N\u0026gt; intree; // 表示i节点是否放入树内 void solve() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; memset(d, 0x3f, sizeof d); memset(a, 0x3f, sizeof a); for (int i = 1; i \u0026lt;= n; ++i) a[i][i] = 0; for (int i = 1; i \u0026lt;= m; ++i) { ll u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; a[u][v] = min(a[u][v], w); a[v][u] = min(a[v][u], w); } ll ans = 0; d[1] = 0; intree[1] = true; // 起始点1，开始更新不在树内的点距离树内起始点1的最短距离 for (int j = 1; j \u0026lt;= n; ++j) { if (intree[j]) continue; d[j] = min(d[j], a[1][j]); } for (int i = 1; i \u0026lt; n; ++i) { int u = 1; // u是我们要找的距离树内任意一点最近的点 for (int j = 1; j \u0026lt;= n; ++j) { if (intree[u] || (!intree[j] \u0026amp;\u0026amp; d[j] \u0026lt; d[u])) u = j; } ans += d[u]; intree[u] = true; d[u] = 0; for (int j = 1; j \u0026lt;= n; ++j) { // 更新当前不在树内的点距离树内任意一点的最短距离 if (intree[j]) continue; d[j] = min(d[j], a[u][j]); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 伪代码实现：堆优化的prim 使用最小堆代替朴素算法中遍历 dist[] 的操作，加速最小代价点的选择过程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 Input: 图的邻接表 graph Output: 最小生成树的权值 sum 1. 初始化: dist[] = {INF, INF, ..., INF} (长度为 n，所有元素为无穷大) visited[] = {false, ..., false} dist[0] = 0 (从节点 0 开始) 创建最小堆 pq，插入 (0, 0) (格式为 (代价, 节点)) 2. Prim 算法: sum = 0 while pq 不为空: (cost, u) = pq.top() pq.pop() # 如果 u 已经在生成树中，跳过 if visited[u]: continue # 将 u 加入生成树 visited[u] = true sum += cost # 更新邻接点 for (v, weight) in graph[u]: if !visited[v] and dist[v] \u0026gt; weight: dist[v] = weight pq.push((dist[v], v)) 3. 返回 sum eg:题目描述：给定一个 $n$ 个点、$m$ 条边的无向带权图，图中可能存在重边和自环。求该图的最小生成树的边权之和，若不存在最小生成树则输出 -1。生成树：对于一个无向图，若它的一个子图是包含该无向图全部顶点的树，那么该子图是该无向图的一个生成树。最小生成树：当连接顶点之间的边有权重时，权重之和最小的生成树则为最小生成树。 输入描述：第一行：两个整数 $n, m$。 ($1 \\leq n \\leq 10^5, 1 \\leq m \\leq 10^5$)。接下来 $m$ 行：每行三个整数 $u_i, v_i, w_i$，表示点 $u_i$ 和点 $v_i$ 之间存在一条权重为 $w_i$ 的无向边。 ($1 \\leq u_i, v_i \\leq n, 0 \\leq w_i \\leq 10^6$) 输出描述：共一行，若存在最小生成树，则输出一个整数，表示最小生成树的边权之和；否则，输出 -1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e3 + 9; ll d[N]; // d是到i点的最短距离 struct Edge { ll x, w; bool operator\u0026lt;(const Edge \u0026amp;u) const { return w == u.w ? x \u0026lt; u.x : w \u0026gt; u.w; } }; vector\u0026lt;Edge\u0026gt; g[N]; // 用结构体来存图 bitset\u0026lt;N\u0026gt; intree; // 表示i节点是否放入树内 void solve() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; memset(d, 0x3f, sizeof d); for (int i = 1; i \u0026lt;= m; ++i) { ll u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; g[u].push_back({v, w}); g[v].push_back({u, w}); } ll ans = 0; priority_queue\u0026lt;Edge\u0026gt; pq; // 用优先队列来判断距离intree最近的点 pq.push({1, 0}); d[1] = 0; while (pq.size()) { int x = pq.top().x; pq.pop(); if (intree[x]) continue; intree[x] = true; ans += d[x]; // 枚举所有出边 for (auto \u0026amp;[y, w] : g[x]) if (!intree[y] \u0026amp;\u0026amp; w \u0026lt; d[y]) { d[y] = w; pq.push({y, w}); } } for (int i = 1; i \u0026lt;= n; ++i) if (!intree[i]) ans = -1; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 基于边的最小生成树kruskal算法 Kruskal算法是一种基于边的贪心算法，每次选择权值最小的边加入生成树，同时避免形成环。 一般情况下用的最多的是kruskal 思想： 将所有边按权值升序排序。 遍历排序后的边，使用并查集判断当前边是否会形成环。 如果不会形成环，就将该边加入生成树。 伪代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 Input: 边列表 edges[]，节点数 n Output: 最小生成树的权值 sum 1. 初始化: 使用并查集: parent[] = {0, 1, 2, ..., n-1} (每个点的父节点初始化为自己) size[] = {1, 1, 1, ..., 1} (每个点所在连通块的大小) 定义 find(x): 查找 x 的根 if parent[x] != x: parent[x] = find(parent[x]) return parent[x] 定义 union(x, y): 合并 x 和 y 所在连通块 root_x = find(x) root_y = find(y) if root_x != root_y: if size[root_x] \u0026lt; size[root_y]: swap(root_x, root_y) parent[root_y] = root_x size[root_x] += size[root_y] 2. Kruskal 算法: sum = 0 (最小生成树的权值) edge_count = 0 (生成树中边的数量) 将 edges[] 按权值升序排序 for (u, v, weight) in edges: if find(u) != find(v): union(u, v) sum += weight edge_count += 1 if edge_count == n - 1: break 3. 如果 edge_count \u0026lt; n - 1: return -1 (图不连通) 否则: return sum eg:题目描述：给定一个 $n$ 个点、$m$ 条边的无向带权图，图中可能存在重边和自环。求该图的最小生成树的边权之和，若不存在最小生成树则输出 -1。生成树：对于一个无向图，若它的一个子图是包含该无向图全部顶点的树，那么该子图是该无向图的一个生成树。最小生成树：当连接顶点之间的边有权重时，权重之和最小的生成树则为最小生成树。 输入描述：第一行：两个整数 $n, m$。 ($1 \\leq n \\leq 10^5, 1 \\leq m \\leq 10^5$)。接下来 $m$ 行：每行三个整数 $u_i, v_i, w_i$，表示点 $u_i$ 和点 $v_i$ 之间存在一条权重为 $w_i$ 的无向边。 ($1 \\leq u_i, v_i \\leq n, 0 \\leq w_i \\leq 10^6$) 输出描述：共一行，若存在最小生成树，则输出一个整数，表示最小生成树的边权之和；否则，输出 -1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e3 + 9; ll d[N]; // d是到i点的最短距离 struct Edge { ll u, v, w; bool operator\u0026lt;(const Edge \u0026amp;m) const { if (w != m.w) return w \u0026lt; m.w; if (u != m.u) return u \u0026lt; m.u; return v \u0026lt; m.v; } }; int pre[N]; int root(int x) { return pre[x] = (pre[x] == x ? x : root(pre[x])); } void solve() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; memset(d, 0x3f, sizeof d); vector\u0026lt;Edge\u0026gt; es; for (int i = 1; i \u0026lt;= m; ++i) { ll u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; es.push_back({u, v, w}); } sort(es.begin(), es.end()); ll ans = 0; for (int i = 1; i \u0026lt;= n; ++i) pre[i] = i; // 并查集初始化 for (auto \u0026amp;[u, v, w] : es) { if (root(u) == root(v)) continue; ans += w; pre[root(u)] = root(v); } for (int i = 1; i \u0026lt; n; ++i) if (root(i) != root(i + 1)) ans = -1; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 质因数分解 质数（素数）判断 模板\n1 2 3 4 5 6 7 8 9 10 11 12 int n;//待判断目标 checkPrime(n) { if (n \u0026lt; 2) return false; for (int i = 2i; i \u0026lt;= n / i; ++i) { if (n % i == 0) return false; } return true; } 求N的所有因数 分析：设a,b是N的因子则 [ N = a \\times b \\quad (设a \\leq b) ] 所以： [ a \\leq \\sqrt{N} \\leq b ] 则令： [b = \\frac{N}{a} ] 枚举a即可 模板题 eg：题目描述： 给定一个数字 $n$，请从小到大输出 $n$ 的所有因子。 输入描述：一个整数 $n$。 ($1 \\leq n \\leq 10^{12}$) 输出描述：一行从小到大输出 $n$ 的所有因子。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e12; void solve() { ll n; cin \u0026gt;\u0026gt; n; vector\u0026lt;ll\u0026gt; v; for (ll i = 1; i \u0026lt;= n / i; ++i) { if (n % i) continue; v.push_back(i); if (i != n / i) v.push_back(n / i); } sort(v.begin(), v.end()); for (auto \u0026amp;i : v) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 求N的所有质因子 模板题 eg：题目描述： 给定一个数字 $n$，请从小到大输出 $n$ 的所有质因子。 输入描述：一个整数 $n$。 ($1 \\leq n \\leq 10^{12}$) 输出描述：一行从小到大输出 $n$ 的所有质因子。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e12; void solve() { ll n; cin \u0026gt;\u0026gt; n; vector\u0026lt;ll\u0026gt; v; for (ll i = 2; i \u0026lt;= n / i; ++i) { if (n % i) continue; v.push_back(i); while (n % i == 0) n /= i; // 将i除干净 } if (n \u0026gt; 1) v.push_back(n); sort(v.begin(), v.end()); for (auto \u0026amp;i : v) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 9.埃氏筛法、gcd和lcm、快速幂、乘法逆元 埃氏筛法 埃氏筛法（Sieve of Eratosthenes）是一种高效计算范围内所有素数的经典算法。其基本思想是通过标记合数来筛选出素数，用于找出一个指定整数范围内的所有素数。这个算法的基本思想是：从最小的素数2开始，逐步标记其倍数为非素数，然后找到下一个未被标记的数，继续标记其倍数为非素数，如此反复，直到处理完所有小于或等于给定数的平方根的数。 埃氏筛法的步骤： 创建一个列表：包含从2到n的所有整数，其中n是要找出素数的范围。 初始化：将2标记为素数。 筛选：从2的下一个数开始，如果该数未被标记为非素数，则将其标记为素数，并将其所有倍数标记为非素数。 重复：重复步骤3，直到处理完所有小于或等于n的平方根的数。 输出：所有未被标记为非素数的数即为素数。 伪代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 埃氏筛法(n): # 创建一个布尔数组，长度为 n+1 初始化布尔数组 is_prime[0..n] 为 true # 0 和 1 不是素数 is_prime[0] = false is_prime[1] = false # 从 2 开始，逐步筛选 for i 从 2 到 √n: 如果 is_prime[i] 为 true: # 将 i 的所有倍数标记为非素数 for j 从 i*i 到 n，步长为 i: is_prime[j] = false # 遍历布尔数组，输出所有素数 for k 从 2 到 n: 如果 is_prime[k] 为 true: 输出 k 模板题 eg:题目描述:给定一个整数 $n$，求 $[1, n]$ 的所有质数。 输入格式:一个整数 $n$。 ($1 \\leq n \\leq 2 \\times 10^6$) 输出格式按照从小到大的顺序输出答案。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2e6 + 9; int n; bitset\u0026lt;N\u0026gt; vis; void solve() { cin \u0026gt;\u0026gt; n; vis[0] = vis[1] = true; for (ll i = 2; i \u0026lt;= n; ++i) { if (!vis[i]) for (ll j = 2 * i; j \u0026lt;= n; j += i) { vis[j] = true; } } for (int i = 1; i \u0026lt;= n; ++i) { if (!vis[i]) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } gcd和lcm 理论基础： 唯一分解定理，也称为算术基本定理，是数论中的一个基本定理。它指出，任何一个大于1的自然数 n 都可以写成素数的乘积形式，并且这种分解方式是唯一的，不考虑因子的顺序。 GCD与唯一分解定理 最大公约数是两个或多个整数共有的最大的能整除它们的正整数。根据唯一分解定理，任何整数都可以唯一地分解为素数的乘积。因此，两个数的GCD可以通过比较它们的素因子来确定：\n分解：将两个数分别分解为素数的乘积。 公共素因子：找出两个分解中相同的素因子。 计算GCD：将这些公共素因子的指数取最小值，然后将它们相乘。 LCM与唯一分解定理 最小公倍数是两个或多个整数的最小的公共倍数。利用唯一分解定理，我们可以类似地计算LCM： 分解：将两个数分别分解为素数的乘积。 公共素因子和独有素因子：找出两个分解中相同的素因子和不同的素因子。 计算LCM：将所有素因子的最高指数相乘。 欧几里得算法 给定两个正整数 $a, b \\in \\mathbb{N}$，且 $a \\leq b$，则它们的最大公约数可以表示为： $$ \\gcd(a, b) = \\gcd(a, b - a) $$ 伪代码实现(gcd的原理/手写gcd函数) 1 2 function gcd(a, b): { return b == 0 ? a : gcd(b, a % b); } 注：c++库函数里有__gcd(a,b)函数 即上述实现 贝祖等式: 它表明两个整数 (a) 和 (b) 的乘积等于它们的最大公约数（GCD）和最小公倍数（LCM）的乘积，这个性质可以用以下的数学公式表示： [ a \\times b = \\gcd(a, b) \\times \\text{lcm}(a, b) ] 伪代码实现（lcm的原理/手写lcm函数）\n1 2 function lcm(a,b): { return a / __gcd(a, b) * b; } eg:题目描述：给定两个正整数 $a, b$，求 $gcd(a, b)$ 和 $lcm(a, b)$。$gcd(a, b)$ 表示 $a, b$ 的最大公因数。$lcm(a, b)$ 表示 $a, b$ 的最小公倍数。 输入描述：第一行输入一个整数 $T$，表示样例的个数。 ($1 \\leq T \\leq 10^5$)。对于每个样例，两个整数 $a, b$。 ($1 \\leq a, b \\leq 2 \\times 10^9$) 输出描述：对于每一个样例，在一行输出两个整数表示 $gcd$ 和 $lcm$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e5 + 9; ll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); } ll lcm(ll a, ll b) { return a / gcd(a, b) * b; } void solve() { int q; cin \u0026gt;\u0026gt; q; while (q--) { ll a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; cout \u0026lt;\u0026lt; gcd(a, b) \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; lcm(a, b) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 快速幂 快速幂（也称为快速指数或幂运算）是一种用于高效计算指数运算的算法，其中 a 是底数，b 是指数。这个算法特别适用于指数 b 非常大时的情况。快速幂算法利用了指数的二进制表示，通过将指数分解为2的幂的和，从而减少乘法的次数。 快速幂算法的原理 快速幂算法基于以下数学原理：\n指数分解：任何正整数 $b$ 都可以表示为 2 的幂的和，即 $b = 2^0 + 2^1 + 2^2 + \\ldots + 2^k$。 幂的乘法： $a^b = a^{2^0} \\times a^{2^1} \\times a^{2^2} \\times \\ldots \\times a^{2^k}$。 步骤\n初始化结果： $res = 1$。 平方和乘法：当 $b \u0026gt; 0$ 时，执行以下步骤： 如果 $b$ 是奇数，将当前的 $a$ 值乘以结果 $res$。 将 $a$ 平方（即 $a = a \\times a$）。 将 $b$ 右移一位（即 $b = b / 2$）。 伪代码实现\n1 2 3 4 5 6 7 8 function fast_pow(a, b): res = 1 while b \u0026gt; 0: if b % 2 == 1: res = res * a a = a * a b = b / 2 return res eg:题目描述：本题有 $T$ 组测试样例。给定三个整数 $a, b, c$，求： [ a^b \\mod c ] 输入格式：第一行输入一个整数 $T$。 ($1 \\leq T \\leq 1000$) 对于每组样例一行给出三个整数 $a, b, c$。 ($1 \\leq a, b, c \\leq 10^9$) 输出格式：一个整数表示答案。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e9 + 9; ll fast_pow(ll a, ll b, ll c) { ll res = 1; while (b) { if (b % 2) res *= a % c; a *= a % c; b \u0026gt;\u0026gt;= 1; } // 这部分其实和伪代码是相同语义 只是位运算更快一点 return res; } void solve() { ll a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; cout \u0026lt;\u0026lt; fast_pow(a, b, c) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _; cin \u0026gt;\u0026gt; _; while (_--) solve(); return 0; } 乘法逆元 看到取模就有可能用逆元 用来控制数据规模 理论基础： 乘法逆元是数论中的一个概念，指的是在模运算中，一个数 $a$ 的乘法逆元是一个数 $b$，使得 $a \\times b \\mod{m}\\equiv 1 $。换句话说，$b$ 是 $a$ 在模 $m$ 下的逆，当且仅当 $a$ 和 $b$ 的乘积对 $m$ 取模后等于 1。 费马小定理 费马小定理指出，如果 $p$ 是一个质数，$a$ 是一个整数，(p是质数且a不是p的倍数)并且 $a$ 不能被 $p$ 整除，那么 $a^{p-1} \\equiv 1 \\pmod{p}$。这个定理可以推广到 $a^p \\equiv a \\pmod{p}$。 费马小定理与乘法逆元的关系 根据费马小定理，我们可以得出 $a^{p-2} \\equiv a^{-1} \\pmod{p}$，这意味着 $a^{p-2}$ 实际上是 $a$ 模 $p$ 的乘法逆元。因此，如果 $p$ 是质数，且 $a$ 不能被 $p$ 整除，那么 $a$ 模 $p$ 的乘法逆元就是 $a^{p-2}$。而 $a^{p-2}$可以通过之前学习过的快速幂来求得。 伪代码实现：费马小定理求逆元\n1 2 3 4 5 function mod_inverse(a, p): if gcd(a, p) != 1: return \u0026#34;No inverse exists\u0026#34; // a 和 p 不互质，没有逆元 else: return fast_pow(a, p - 2, p) // 使用快速幂算法计算 a^(p-2) mod p eg： 题目描述：给定一个函数形式:[ f(x) = \\frac{ax + b}{cx} ] 本题有 $T$ 组测试样例，对于每组样例：给定三个整数表示 $a, b, c$ 用于确定函数，然后有 $q$ 次询问，每次询问一个点的函数值。结果对 998244353 取模。 输入格式：第一行一个整数 $T$，表示样例数。 ($1 \\leq T \\leq 10$)。对于每个样例：第一行四个整数 $a, b, c, q$。 ($1 \\leq a, b, c \\leq 10^9, 1 \\leq q \\leq 10^4$)。接下来 $q$ 行，每行一个整数表示询问点 $x_i$。 ($1 \\leq x \\leq 10^9$) 输出格式：对于每次询问，一个整数表示取模后的结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e9 + 9; const ll p = 998244353; ll fast_pow(ll a, ll b) { ll res = 1; while (b) { if (b % 2) res = res * a % p; a = a * a % p; b \u0026gt;\u0026gt;= 1; } return res; } ll inv(ll x) // 费马小定理求逆元 { return fast_pow(x, p - 2); } ll f(ll a, ll b, ll c, ll x) { return (a * x % p + b) % p * inv(c * x % p) % p; //%p是为了缩小数据量 若不模已经到1e18了 而在数学角度上对于 } void solve() { ll a, b, c, q; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; q; while (q--) { ll x; cin \u0026gt;\u0026gt; x; cout \u0026lt;\u0026lt; f(a, b, c, x) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _; cin \u0026gt;\u0026gt; _; while (_--) solve(); return 0; } 10.组合数、01背包、完全背包 组合数 组合数，也称为二项式系数，表示为 $C(n, m)$ 或 $\\binom{n}{m}$，是指从 $n$ 个不同元素中选取 $m$ 个元素的组合方式数量，不考虑选取的顺序。组合数的计算公式是： [ C(n, m) = \\frac{n!}{m!(n-m)!} ] 伪代码实现上公式\n1 2 3 4 5 6 7 8 9 long long combination(int n, int m) { if (m \u0026gt; n) return 0; if (m \u0026gt; n - m) m = n - m; long long result = 1; for (int i = 1; i \u0026lt;= m; ++i) { result = result * (n - i + 1) / i; } return result; } 组合数的性质\n对称性：$C(n, m) = C(n, n-m)$。从 $n$ 个元素中选取 $m$ 个元素的方式数与选取 $n-m$ 个元素的方式数相同。 边界条件：$C(n, 0) = C(n, n) = 1$。选取 0 个或全部 $n$ 个元素的方式只有一种。 帕斯卡恒等式：$C(n, m) = C(n-1, m) + C(n-1, m-1)$。这个恒等式表明，从 $n$ 个元素中选取 $m$ 个元素的方式数等于从 $n-1$ 个元素中选取 $m$ 个元素的方式数加上从 $n-1$ 个元素中选取 $m-1$ 个元素的方式数。 eg:题目描述：给定两个整数 $n, m$，求一个大小 $n \\times m$ 的矩阵，其中第 $i$ 行，第 $j$ 列的元素为 $C(i, j)$。 $C(i, j)$ 表示从 $i$ 个不同的物品中选出 $j$ 个的方案数。 注意，这里的行列均为 0-index，即下标从 0 开始计数。结果对 $1e9 + 7$ 取模。 输入格式：两个整数 $n, m$。 ($1 \\leq n, m \\leq 10^3$) 输出格式：一个 $n \\times m$ 的整数矩阵表示答案。 朴素方法（递归求解）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int p = 1e9 + 7; const int N = 1e3 + 5; ll c[N][N]; void solve() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; n; ++i) c[i][0] = 1ll; for (int i = 1; i \u0026lt; n; ++i) for (int j = 1; j \u0026lt;= i \u0026amp;\u0026amp; j \u0026lt; m; ++j) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % p; for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; m; ++j) { cout \u0026lt;\u0026lt; c[i][j] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 又因为[ C(n, m) = \\frac{n!}{m!(n-m)!} ] 所以在进行取模情境下，可以对分母部分转化为逆元进行处理，结合快速幂和求逆元来做，如下题所示。 伪代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 function mod_inverse(a, p):// 使用扩展欧几里得算法求逆元 gcd, x, _ = extended_gcd(a, p) if gcd != 1: return -1 // 无逆元 else: return x % p // 模 p 下的逆元 function fast_pow(a, b, p):// 快速幂 result = 1 a = a % p while b \u0026gt; 0: if b % 2 == 1: result = (result * a) % p a = (a * a) % p b = b // 2 return result function combination(n, m, p)://组合数 if m \u0026gt; n: return 0 分母 = 1 for i from 1 to m: 分子 = (分子 * (n - i + 1)) % p 分母 = (分母 * i) % p 逆元分母 = 求逆元(分母, p) 返回 (分子 * 逆元分母) % p eg: 题目描述：有 $q$ 次询问，每次给出两个整数 $n, m$，求 $C(n, m)$。$C(n, m)$ 表示从 $n$ 个不同的物品中选出 $m$ 个的方案数。结果对 $1e9 + 7$ 取模。 输入格式：第一行一个整数 $q$。 ($1 \\leq \\leq 10^5$) 对于每个询问，两个整数 $n, m$。 ($1 \\leq m \\leq n \\leq 10^7$) 输出格式：对于每次询问，输出一个整数表示答案。 模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int p = 1e9 + 7; const int N = 1e7 + 3; ll fac[N]; ll quickMi(ll a, ll b) // 快速幂 { ll res = 1; while (b) { if (b % 2) res = res * a % p; a = a * a % p; b = b / 2; } return res; } ll inv(ll x) { return quickMi(x, p - 2); } // 快速幂求逆元 void init(int n) // 求阶乘 { fac[0] = 1; for (int i = 1; i \u0026lt;= n; ++i) fac[i] = fac[i - 1] * i % p; } ll C(ll n, ll m) { if (n \u0026lt; 0 || m \u0026lt; 0 || n \u0026lt; m) return 0; return fac[n] * inv(fac[n - m] * fac[m] % p) % p; } void solve() { init(1e7); ll n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; cout \u0026lt;\u0026lt; C(n, m) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _; cin \u0026gt;\u0026gt; _; while (_--) solve(); return 0; } 0-1背包 问题描述 给定:\n$n$ 个物品，每个物品有重量 $w_i$ 和价值 $v_i$。 背包的容量为 $W$。 要求: 选择一些物品放入背包，使得背包中物品的总重量不超过 $W$，且总价值最大。 步骤： 1.状态定义：定义 $dp[i][j]$ 为考虑前 $i$ 个物品，背包容量为 $j$ 时的最大价值。确定边界 2.初始化\n$dp[0][j] = 0$ 对于所有 $j$，因为没有物品时价值为 0。 $dp[i][0] = 0$ 对于所有 $i$，因为容量为 0 时无法放置任何物品。 3.找状态转移方程： 对于每个物品 $i$ 和每个容量 $j$:\n[ dp[i][j] = \\max(dp[i-1][j], dp[i-1][j-w_i] + v_i) ]\n如果不选择第 $i$ 个物品，则最大价值为 $dp[i-1][j]$。 如果选择第 $i$ 个物品，则最大价值为 $dp[i-1][j-w_{i}] + v_{i}$，前提是 $j \\geq w_{i}$。 4.按顺序计算：按物品 $i$ 和容量 $j$ 从小到大的顺序计算 $dp[i][j]$。\n伪代码实现\n1 2 3 4 5 6 7 8 9 function knapsack(W, w[], v[], n): 创建二维数组 dp，大小为 (n+1) x (W+1)，初始值为 0 for i from 1 to n: for j from 1 to W: if w[i-1] \u0026gt; j: dp[i][j] = dp[i-1][j] else: dp[i][j] = max(dp[i-1][j], dp[i-1][j - w[i-1]] + v[i-1]) return dp[n][W] eg： 题目描述：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。” 你能完成这个任务吗？ 输入描述：输入的第一行有两个整数 $T (1 \\leq T \\leq 1000)$ 和 $M (1 \\leq M \\leq 100)$，$T$ 代表总共能够用来采药的时间，$M$ 代表山洞里的草药的数目。 接下来的 $M$ 行每行包括两个在 1 到 100 之间（包括 1 和 100）的整数，分别表示采摘某株草药的时间和这株草药的价值。 输出描述：可能有多组测试数据，对于每组数据：输出只包括一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。\n滚动数组优化 滚动数组优化，也称为空间优化，是动态规划中的一种技术，用于减少算法的空间复杂度。在0-1背包问题中，因为实际每次参与计算的只有当前的这行和它的上一行我们可以通过只存储当前行和上一行的值来优化空间复杂度，从而降低空间复杂度。 伪代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 函数 solve(): // 初始化 dp 数组 将 dp 的所有元素初始化为 0 // 输入每株草药的时间和价值 对于 i 从 1 到 M: 读取 t[i] 和 v[i] // 动态规划 对于 i 从 1 到 M: // 遍历每一株草药 current = i \u0026amp; 1 // 当前行 previous = 1 - current // 上一行 对于 j 从 0 到 T: // 遍历每个时间限制 如果 j \u0026gt;= t[i]: // 如果当前时间能采这株草药 dp[current][j] = max(dp[previous][j], dp[previous][j - t[i]] + v[i]) 否则: // 当前时间不足以采这株草药 dp[current][j] = dp[previous][j] return dp[M \u0026amp; 1][T] // 最终结果存储在最后一行对应的列中 eg:同上题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e3 + 5; ll T, M; ll t[N], v[105]; ll dp[2][1010]; void solve() { memset(dp, 0, sizeof(dp)); // 初始化 for (int i = 1; i \u0026lt;= M; ++i) cin \u0026gt;\u0026gt; t[i] \u0026gt;\u0026gt; v[i]; for (int i = 1; i \u0026lt;= M; ++i) { int current = i \u0026amp; 1; // 表示当前行 1-current即零一行 for (int j = 0; j \u0026lt;= T; ++j) {//滚动数组优化： if (j \u0026gt;= t[i]) dp[current][j] = max(dp[1 - current][j], dp[1 - current][j - t[i]] + v[i]); else dp[current][j] = dp[1 - current][j]; } } cout \u0026lt;\u0026lt; dp[M \u0026amp; 1][T] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); while (cin \u0026gt;\u0026gt; T \u0026gt;\u0026gt; M) { if (T == 0 \u0026amp;\u0026amp; M == 0) break; solve(); } return 0; } 无穷/完全背包 问题描述给定:\n$n$ 个物品，每个物品有重量 $w_i$ 和价值 $v_i$。 背包的容量为 $W$。 要求:\n选择一些物品放入背包，使得背包中物品的总重量不超过 $W$，且总价值最大。 步骤：\n1.状态定义：定义 $dp[j]$ 为背包容量为 $j$ 时的最大价值。 2.初始化： $dp[0] = 0$：背包容量为0时，价值为0。 3.状态转移方程：对于每个物品 $i$ 和每个容量 $j$:\n[ dp[j] = \\max(dp[j], dp[j - w_i] + v_i) ]\n这个状态转移方程意味着，对于每个物品，你可以选择不放它、放1个、放2个……直到背包容量允许的最大数量。因此，你需要检查所有可能的数量，更新 $dp[j]$ 的值。 4.计算：按物品 $i$ 和容量 $j$ 从小到大的顺序计算 $dp[j]$。 为代码实现：\n1 2 3 4 5 6 function unbounded_knapsack(W, w[], v[], n): 创建一维数组 dp，大小为 W + 1，初始值为 0 for i from 1 to n: for j from w[i - 1] to W: dp[j] = max(dp[j], dp[j - w[i - 1]] + v[i - 1]) return dp[W] eg：题目描述:小e的背包容量为 $m$，现在商店里有 $n$ 种商品。由于在梦境中，他可以零元购，商店里的每种商品都有无穷件，每件商品有一个价值 $w_i$ 和体积 $v_i$。问小e最多可以带走多少价值的商品？ 输入格式:第一行两个整数表示 $m, n$。 ($1 \\leq m \\leq 10^5, 1 \\leq n \\leq 500$)接下来 $n$ 行，每行两个整数表示 $w_i, v_i$。 ($1 \\leq w_i \\leq 10^9, 1 \\leq v_i \\leq m$) 输出格式:一行一个整数表示答案。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 505; const int M = 1e5 + 5; ll m, n; ll dp[M]; ll w[N], v[N]; void solve() { memset(dp, 0, sizeof(dp)); cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; w[i] \u0026gt;\u0026gt; v[i]; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 0; j \u0026lt;= m; ++j) { dp[j] = max(dp[j], dp[j - v[i] + w[i]]); } } cout \u0026lt;\u0026lt; dp[m] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 分析背包问题的时候要注意状态转换是从当前行还是上一行\n11.多重背包的二进制优化、单调栈二分dp 多重背包的二进制优化 多重背包 多重背包问题是一种经典的动态规划问题，它与0-1背包问题类似，但区别在于多重背包问题中每种物品可以选取多次，而0-1背包问题中每种物品只能选取一次或不选取。\neg： 题目描述：小e的背包容量为 $m$，现在商店里有 $n$ 种商品。由于在梦境中，他可以零元购，但商品的数量有限，第 $i$ 种商品最多可以购买 $s_i$ 件，每件商品有一个价值 $w_i$ 和体积 $v_i$。请问小e最多可以带走多少价值的商品？ 输入描述：第一行：两个整数 $m, n$，表示背包容量、商品种数。 ($1 \\leq m, n \\leq 100$)接下来 $n$ 行：每行三个整数 $s_i, w_i, v_i$，表示第 $i$ 种商品的件数、价值、体积。 ($0 \\leq s_i, w_i, v_i \\leq 100$) 输出描述：一个整数，表示小e能带走的最大价值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 100 + 9; ll dp[N * N]; int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); ll m, n; cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) { ll s, w, v; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; w \u0026gt;\u0026gt; v; while (s--) // 跑s次0-1背包 { for (int j = m; j \u0026gt;= v; --j) dp[j] = max(dp[j], dp[j - v] + w); } } cout \u0026lt;\u0026lt; dp[m] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 上题解在数据量较小时可以满足要求，数据量变大后由于for（while（for））的时间复杂度太高，会超时。\n多重背包的二进制优化 多重背包问题的二进制优化是一种将问题转化为 01 背包问题的方法，其核心思想是利用二进制表示法将每个物品的数量拆分成多个 1 的倍数，从而减少状态的数量，提高算法效率。 多重背包问题二进制优化的原理 对于一个物品，如果它有 $s$ 个，我们可以将其拆分成 1, 2, 4, 8, \u0026hellip; 直到 $2^k - 1$（其中 $k$ 是满足 $2^k - 1 \\leq s$ 的最大整数），这样就能表示出 0 到 $s$ 的所有数量。这种方法可以减少物品数量的表示范围，从而将多重背包问题转化为 01 背包问题。 算法步骤\n二进制拆分：对于每个物品，根据其数量 $s$，使用二进制表示法将其拆分成多个 1 的倍数。例如，如果一个物品有 10 个，可以拆分成 1+2+4+3。 状态转移：将拆分后的物品视为 01 背包问题中的不同物品，使用动态规划求解。对于每个物品，从背包的最大容量向下遍历，更新 dp 数组。 代码实现：在代码中，首先对每个物品进行二进制拆分，然后使用 01 背包的状态转移方程求解。 题目描述：小e的背包容量为 $m$，现在商店里有 $n$ 种商品。由于在梦境中，他可以零元购，但商品的数量有限，第 $i$ 种商品最多可以购买 $s_i$ 件，每件商品有一个价值 $w_i$ 和体积 $v_i$。请问小e最多可以带走多少价值的商品？ 输入描述：第一行：两个整数 $m, n$，表示背包容量、商品种数。 ($1 \\leq m, n \\leq 2000$)接下来 $n$ 行：每行三个整数 $s_i, w_i, v_i$，表示第 $i$ 种商品的件数、价值、体积。 ($0 \\leq s_i, w_i, v_i \\leq 2000$) 输出描述：一个整数，表示小e能带走的最大价值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2000 + 9; ll dp[N]; int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); ll m, n; cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) { ll s, w, v; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; w \u0026gt;\u0026gt; v; vector\u0026lt;ll\u0026gt; vec; int x = 1; while (s \u0026gt;= x) // 进行二进制优化： { vec.push_back(x); s -= x; x \u0026lt;\u0026lt;= 1; } if (s) vec.push_back(s); for (auto \u0026amp;k : vec) { for (int j = m; j \u0026gt;= k * v; --j) dp[j] = max(dp[j], dp[j - k * v] + k * w); } } cout \u0026lt;\u0026lt; dp[m] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 12.DP分类与精讲线性dp、区间dp、树形dp 动态规划（DP）是算法中一种常见且重要的思想，应用广泛。以下是常见的动态规划分类以及其特点和典型应用：\n1. 线性 DP** 特点：\n问题可以分解为一个线性顺序的子问题，状态之间按照序列关系转移。 主要处理具有顺序性和前后依赖关系的问题。 状态定义：\n一般定义为 dp[i]，表示前 i 个状态的最优解，或者以第 i 个元素为结尾/起点的子问题最优解。 典型问题： 最长上升子序列（LIS）、最长公共子序列（LCS）、背包问题（0-1 背包、完全背包、分组背包）、股票交易问题、最大子序和\n最长上升子序列模板\n1 2 3 4 5 6 7 for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt; i; ++j) { if (nums[j] \u0026lt; nums[i]) { dp[i] = max(dp[i], dp[j] + 1); } } } eg: 题目描述:给定一个长度为 $n$ 的数组 $a$，求其最长上升（非降）子序列的长度。 注意：子序列不一定是连续的。 输入描述: 第一行：一个整数 $n$。 ($1 \\leq n \\leq 10^3$) 第二行：$n$ 个整数，表示 $a_1, a_2, \\ldots, a_n$。 ($1 \\leq a_i \\leq 10^9$) 输出描述:一个整数，表示答案。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e3 + 9; int n; ll a[N], dp[N]; void solve() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n; ++i) { dp[i] = 1; for (int j = 1; j \u0026lt; i; ++j) { if (a[j] \u0026lt;= a[i]) dp[i] = max(dp[i], dp[j] + 1); } } ll ans = 0; for (int i = 1; i \u0026lt;= n; ++i) ans = max(ans, dp[i]); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 数组单调栈二分优化： 实际上栈中的每个元素是一个索引 i，它表示数组 nums[i] 是当前最长上升子序列的一个结尾元素。 单调栈优化LIS的原理:\n单调栈维护：使用一个栈来维护当前找到的最长上升子序列。栈内的元素是递增的，即栈底到栈顶是严格递增的序列。 遍历数组：遍历给定的数组，对于每个元素，有两种情况：如果当前元素大于栈顶元素，说明当前元素可以接在栈顶元素后面形成更长的上升子序列，因此将当前元素入栈;如果当前元素小于或等于栈顶元素，说明需要在栈中找到一个合适的位置来替换栈顶元素，使得栈仍然保持单调递增。这可以通过二分查找来实现，找到栈中第一个大于当前元素的位置，并用当前元素替换该位置的元素。 更新栈：通过上述步骤，栈的长度即为最长上升子序列的长度。 eg: 题目描述:给定一个长度为 $n$ 的数组 $a$，求其最长上升（非降）子序列的长度。 注意：子序列不一定是连续的。 输入描述: 第一行：一个整数 $n$。 ($1 \\leq n \\leq 2×10^5$) 第二行：$n$ 个整数，表示 $a_1, a_2, \\ldots, a_n$。 ($1 \\leq a_i \\leq 10^9$) 输出描述:一个整数，表示答案。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2e5 + 9; int n; ll a[N], stk[N], top; void solve() { cin \u0026gt;\u0026gt; n; ll ans = 0; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n; ++i) { // 找最后一个 \u0026lt;= a[i]的位置+1 也就是首个 \u0026gt; a[i]的位置 int pos = upper_bound(stk + 1, stk + 1 + top, a[i]) - stk; //用upper_bound来实现二分 if (pos == top + 1) top++; stk[pos] = a[i]; ans = max(ans, top); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } eg： 题目描述：某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。输入导弹依次飞来的高度（雷达给出的高度数据是不大于30000的正整数），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。 输入描述：每笔测资一行：输入导弹依次飞来的高度，空格分隔，导弹数不超过1000。 输出描述：对于每笔测资，输出两行：第1行：1个整数，表示最多能拦截的导弹数。第2行：1个整数，表示要拦截所有导弹最少要配备的系统数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2e5 + 9; ll a[N], stk[N], top; void solve() { // 不知道有多少输入的时候可以这样记录: int n = 0; while (cin \u0026gt;\u0026gt; a[++n]) ; n--; ll ans = 0; for (int i = 1; i \u0026lt;= n; ++i) { // 找第一个小于a[i]的位置 记录在pos中 int pos = upper_bound(stk + 1, stk + 1 + top, a[i], [](const int \u0026amp;u, const int \u0026amp;v) { return u \u0026gt; v; }) - stk; if (pos == top + 1) top++; stk[top] = a[i]; ans = max(ans, top); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 最长不升子序列的长度计算完成 // 根据狄尔沃斯定理，最少的最长不升子序列来覆盖整个数组的个数，是最长上升子序列的长度 // 因此需要再求一个最长上升子序列 ll ans2 = 0; top = 0; for (int i = 1; i \u0026lt;= n; ++i) { // 找第一个大于等于a[i]的位置 记录在pos中 int pos = lower_bound(stk + 1, stk + 1 + top, a[i]) - stk; if (pos == top + 1) top++; stk[top] = a[i]; ans2 = max(ans2, top); } cout \u0026lt;\u0026lt; ans2 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 最长不升子序列的长度计算完 } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } eg: 题目描述：小明的花店新开张，为了吸引顾客，他想在花店的门口摆上一排花，共 $m$ 盆。通过调查顾客的喜好，小明列出了顾客最喜欢的 $n$ 种花，从 1 到 $n$ 标号。为了在门口展出更多种花，规定第 $i$ 种花不能超过 $a_i$ 盆，摆花时同一种花放在一起，且不同种类的花需按标号的从小到大的顺序依次摆列。试编程计算，一共有多少种不同的摆花方案。 输入格式：第一行包含两个正整数 $n$ 和 $m$，中间用一个空格隔开。第二行有 $n$ 个整数，每两个整数之间用一个空格隔开，依次表示 $a_1, a_2, \\ldots, a_n$。 输出格式：一个整数，表示有多少种方案。注意：因为方案数可能很多，请输出方案数对 $10^6 + 7$ 取模的结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e3 + 9; const int p = 1e6 + 7; ll a[N]; ll dp[N][N]; void solve() { ll n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; for (int i = 0; i \u0026lt;= a[1]; ++i) dp[1][i] = 1; // 初始化 for (int i = 2; i \u0026lt;= n; ++i) // 到第i种花为止且以i结尾（也可能无i）的方案数 { for (int j = 0; j \u0026lt;= m; ++j) // 共放了j盆花的方案数 { for (int k = 0; k \u0026lt;= a[i] \u0026amp;\u0026amp; k \u0026lt;= j; ++k) // 最后第i种花放了k盆的方案数 { dp[i][j] = dp[i][j] + dp[i - 1][j - k]; } } } cout \u0026lt;\u0026lt; dp[n][m] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 2.区间DP 区间DP（动态规划）是一种处理涉及区间问题的动态规划方法。它通过将问题分解为更小的区间，并求解这些小区间的最优解，然后将这些解合并以得到整个大区间的最优解。以下是区间DP的一些关键点： 定义：区间DP是线性DP的一种，它以“区间长度”划分阶段，并以两个坐标（区间的左右端点）作为状态的维度。一个状态通常由被它包含且比它更小的区间状态转移而来。 核心思路：区间DP的核心思想是将一个大区间分割成多个小区间，分别求解每个小区间的最优解，然后合并这些解以得到整个大区间的最优解。 应用：区间DP常用于解决最长公共子序列、最长回文子串等问题。在区间DP中，通常需要定义一个二维数组来表示子区间的状态，并构建状态转移方程。\neg： 题目描述：有 ( n ) 堆石子排队一排，编号为 ( 1, 2, 3, \\cdots, n )，每堆石子有一个质量 ( a_i )。我们每次可以合并相邻的两堆石子，且合并需花费代价为这两堆石子的质量之和，现在要将这 ( n ) 堆石子合并成一堆。合并时由于顺序不同，合并的总代价也会有区别，请你计算出所需的最小总代价。 输入描述：第一行：一个整数 ( n )，表示石子的堆数。( ( 1 \\leq n \\leq 300 ) )第二行：( n ) 个整数，表示每堆石子的质量 ( a_i )。( ( 1 \\leq a_i \\leq 1000 ) ) 输出描述：一个整数，表示合并成一堆所需的最小总代价。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 500 + 9; const ll inf = 4e18; ll a[N], dp[N][N], prefix[N]; void solve() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n; ++i) prefix[i] = prefix[i - 1] + a[i]; // 枚举区间长度k for (int len = 2; len \u0026lt;= n; ++len) { // 枚举区间起点i 也就得到了终点j for (int i = 1, j = i + len - 1; j \u0026lt;= n; ++i, ++j) { // 初始化： dp[i][j] = inf; // 枚举区间中间的点 for (int k = i; k \u0026lt;= j; ++k) { dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + prefix[j] - prefix[i - 1]); } } } cout \u0026lt;\u0026lt; dp[1][n] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 3.树形DP 特点：\n定义在树结构上，利用子树递归求解。 常用在求树的某些性质，例如直径、最长路径、节点权值优化等。 状态定义：\n通常定义为 dp[u]，表示以节点 u 为根的子树中某种性质的最优解。 典型问题： 树的直径、树上背包问题、树的染色问题\n例子：\n树的直径：\n1 2 3 4 5 6 7 8 void dfs(int u, int parent) { for (int v : tree[u]) { if (v != parent) { dfs(v, u); dp[u] = max(dp[u], dp[v] + 1); } } } 用归属法，把一棵子树的权值和归属到根节点上 eg: 题目描述：给定一棵 ( n ) 个节点的树，每个节点 ( i (1 \\leq i \\leq n) ) 都有一个权值 ( w_i )。我们规定一个连通块的权值为，连通块中所有节点的权值之和，请你求出最大的连通块权值。注意：连通块需包含至少一个节点。 输入描述：第一行，一个整数 ( t )，表示案例个数。对于每个案例:第一行，一个整数 ( n )，表示节点数。 ( \\left(1 \\leq n \\leq 10^5\\right) ) 第二行，( n ) 个整数，表示节点权值 ( w_i )。 ( \\left(-10^4 \\leq w_i \\leq 10^4\\right) ) 接下来 ( n-1 ) 行，每行两个整数 ( u, v )，表示存在一条连接节点 ( u ) 和 ( v ) 的边。 ( (1 \\leq u, v \\leq n, u \\neq v) ) 输入保证：所有案例的 ( n ) 之和不超过 ( 2 \\times 10^5 )，即 ( 1 \\leq \\sum n \\leq 2 \\times 10^5 )。 输出描述：一个整数，表示最大连通块权值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e5 + 9; ll dp[N]; // 表示以i为根的子树的权值和 vector\u0026lt;int\u0026gt; g[N]; ll w[N]; void dfs(int x, int pre) { dp[x] = w[x]; for (auto \u0026amp;y : g[x]) // 遍历儿子节点 { if (y == pre) continue; dfs(y, x); dp[x] = max(dp[x], dp[y] + dp[x]); } } void solve() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; w[i]; for (int i = 1; i \u0026lt;= n; ++i) { dp[i] = 0; g[i].clear(); // 初始化 } for (int i = 1; i \u0026lt; n; ++i) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; g[u].push_back(v); g[v].push_back(u); } dfs(1, -1); cout \u0026lt;\u0026lt; *max_element(dp + 1, dp + 1 + n) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _; cin \u0026gt;\u0026gt; _; while (_--) solve(); return 0; } 4. 状态压缩 DP（状压 DP）\n特点：\n用一个整数（通常是位掩码）表示一个状态，从而压缩复杂度。 常用于组合问题，涉及子集、排列等情况。 状态定义：\n一般是 dp[mask]，表示状态为 mask 时的最优解。 典型问题： 旅行商问题（TSP）、最小路径覆盖问题、集合覆盖问题、多人游戏博弈问题\n例子：\n旅行商问题\n1 2 3 4 5 6 7 8 9 10 11 for (int mask = 0; mask \u0026lt; (1 \u0026lt;\u0026lt; n); ++mask) { for (int i = 0; i \u0026lt; n; ++i) { if (mask \u0026amp; (1 \u0026lt;\u0026lt; i)) { for (int j = 0; j \u0026lt; n; ++j) { if (mask \u0026amp; (1 \u0026lt;\u0026lt; j)) { dp[mask][i] = min(dp[mask][i], dp[mask ^ (1 \u0026lt;\u0026lt; i)][j] + dist[j][i]); } } } } } 5. 期望 DP\n特点：\n用于计算随机过程中的期望值。 通常需要将状态转移公式调整为期望形式，例如概率加权和。 状态定义：\n一般定义为 dp[i]，表示从状态 i 开始的期望值。 典型问题： 游戏中的胜率期望、骰子问题、分数期望\n例子：\n骰子问题：\n给定一个骰子，求掷出某个总点数所需的最少次数。\n1 2 3 4 5 6 for (int i = target; i \u0026gt;= 0; --i) { dp[i] = 1; for (int j = 1; j \u0026lt;= 6; ++j) { dp[i] += dp[min(target, i + j)] / 6.0; } } 6. 存在性 DP\n特点：\n判断某种状态是否可行，而非求具体值。 结果通常是 true/false 或 \u0026ldquo;Yes/No\u0026rdquo;。 状态定义：\n一般定义为 dp[i]，表示是否能达到某个状态。 典型问题： 子集和问题、判断是否可以分割成两个子集（等和划分）、游戏中的必胜或必败状态\n例子：\n子集和问题：\n给定一组数，判断是否可以选出一个子集，使其和等于某个值。\n1 2 3 4 5 6 dp[0] = true; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = target; j \u0026gt;= nums[i]; --j) { dp[j] = dp[j] || dp[j - nums[i]]; } } 7. 数位 DP 特点：\n解决与数字有关的计数问题，通常涉及某些限制条件（如不包含某个数字）。 利用数字的逐位分解，将问题转化为状态转移。 状态定义：\n一般定义为 dp[pos][state]，表示在第 pos 位时，状态为 state 的计数或方案数。 典型问题： 统计满足某些条件的数字个数、数字是否包含某些数字、数字按位奇偶分布问题\n例子：\n不含数字 4 的数的个数：\n1 2 3 4 5 6 7 8 for (int pos = 0; pos \u0026lt; length; ++pos) { for (int state = 0; state \u0026lt; 2; ++state) { for (int digit = 0; digit \u0026lt; 10; ++digit) { if (digit == 4) continue; dp[pos + 1][new_state] += dp[pos][state]; } } } 总结 分类 主要特点 典型问题 线性 DP 按序列递推 LIS, 背包问题 状压 DP 状态用位压缩表示 TSP, 子集问题 期望 DP 概率权重计算 骰子期望，随机博弈 存在性 DP 判断是否可行 子集和, 游戏决策问题 树形 DP 定义在树结构上 树直径, 树染色, 树背包 数位 DP 与数字相关的计数问题 统计数字满足的个数 动态规划本质上是通过定义状态和找出状态转移关系解决问题。掌握每种类型的核心思想和应用场景是学习动态规划的关键。\n","date":"2024-12-14T00:00:00Z","image":"https://Nanmur.github.io/p/test-chinese/Starcode-logo_hu7427521384709435736.png","permalink":"https://Nanmur.github.io/p/test-chinese/","title":"Starcode算法基础班笔记"}]