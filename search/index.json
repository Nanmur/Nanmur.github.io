[{"content":"基础算法 练习题：Acwing T785-T803\n排序 快速排序 时间复杂度：O(nlogn) 思想：基于分治 设区间最左侧位置为l，最右侧为r。流程如下：\n确定分界点 q[l] 或 q[(l+r)/2] 或q[r] 或区间内随机一个点。 重新调整划分区间： 小于等于分界点的值的数全部放在分界点左侧，大于等于分界点的值的数全部放在分界点右侧 优美的实现方法：双指针 分别从l和r开始向中间遍历，当l遍历到大于等于分界点的数的时候停止，当r遍历到小于等于分界点的数的时候停止，交换两数（swap）后继续向中间遍历重复以上步骤直至两指针相遇。 在新区间的左右两半进行递归。 模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e6 + 10; int n, q[N]; void quick_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int x = q[(l + r) / 2]//最好别取到左边界; int i = l - 1, j = r + 1; while (i \u0026lt; j) { do i++; while (q[i] \u0026lt; x); do j--; while (q[j] \u0026gt; x); if (i \u0026lt; j) swap(q[i], q[j]); } quick_sort(q, l, j); quick_sort(q, j + 1, r); } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 0; i \u0026lt; n; ++i) scanf(\u0026#34;%d\u0026#34;, \u0026amp;q[i]); quick_sort(q, 0, n - 1); for (int i = 0; i \u0026lt; n; ++i) printf(\u0026#34;%d \u0026#34;, q[i]); return 0; } 归并排序 时间复杂度：O(nlogn) 思想：基于分治 以整个数组的中间位置来分为左右两个区间，步骤如下：\n确定分界点：mid = (l+r)/2 递归排序左侧区间和右侧区间 归并左右两个区间合为一个(重点) 优美的实现方法：双指针 分别从两个区间的起点开始遍历，因为两个区间分别有序（由小到大），所以比较两个指针所处位置的大小，较小的那个一定是两个区间的当前最小值，放进结果数组中，然后将指针右移，继续比较，直至两个区间里的数全部放入结果数组。若一个区间里的数已经全部放入结果数组，直接将剩下的区间里的剩下的数按顺序放入数组即可。 模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e6 + 10; int n, q[N], temp[N]; void merge_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int mid = (l + r) / 2; merge_sort(q, l, mid), merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) { if (q[i] \u0026lt;= q[j]) temp[k++] = q[i++]; else temp[k++] = q[j++]; } while (i \u0026lt;= mid) temp[k++] = q[i++]; while (j \u0026lt;= r) temp[k++] = q[j++]; for (i = l, j = 0; i \u0026lt;= r; ++i, ++j) { q[i] = temp[j]; } } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 0; i \u0026lt; n; ++i) scanf(\u0026#34;%d\u0026#34;, \u0026amp;q[i]); merge_sort(q, 0, n - 1); for (int i = 0; i \u0026lt; n; ++i) printf(\u0026#34;%d \u0026#34;, q[i]); return 0; } 二分 整数二分 思想：如果一种性质可以把区间分成两个部分，一部分满足该性质而另一部分不满足该性质，就可以用二分找出这两部分的端点。因此引出两种情况：\n找不满足该性质的区间端点 找满足该性质的区 间端点 注意实际解决问题时 对这种性质的确定 关系到选择哪个模板 同时 在二分时无需考虑是否有解 二分一定能得到边界 根据边界再去判断针对题目是否有解 对于问题1，步骤如下：\n先找一个中间值mid =(l + r + 1)/2，判断该中间值是否满足该性质。注意，这种方法的 mid 必须要补那个 + 1 来防止死循环 若满足该性质，则所求端点在[mid,r]之间（左右都是闭区间），则用l = mid进行更新。 若不满足该性质，则所求端点在[l.mid - 1]之间（左右都是闭区间）,则用r = mid - 1 更新。 对于问题1，模板如下：\n1 2 3 4 5 6 7 8 9 10 11 //区间[l,r]被分成[l,mid]与[mid+1,r]： int bsearch_1(int l, int r) { while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) r = mid; else l = mid + 1; }//循环结束时 l == r 输出哪个都行 return 1; } 对于问题2，步骤如下:\n先找一个中间值mid =(l + r )/2，判断该中间值是否满足该性质。 若满足该性质，则所求端点在[l,mid]之间（左右都是闭区间），则用r = mid进行更新。 若不满足该性质，则所求端点在[mid + 1,r]之间（左右都是闭区间）,则用l = mid + 1 更新。 对于问题2，模板如下：\n1 2 3 4 5 6 7 8 9 10 11 //区间[l,r]被分成[l,mid-1]与[mid,r]： int bsearch_2(int l, int r) { while (l \u0026lt; r) { int mid = l + r + 1 \u0026gt;\u0026gt; 1; if (check(mid)) l = mid; else r = mid - 1; }//循环结束时 l == r 输出哪个都行 return 1; } 浮点数二分 思想： 与整数二分一样。不同点在于，取中间点时不需要整除,也没有两种情况，直接判断段边界即可。且对于答案的判断是：当r - l这个区间足够小，则可以取出l或r作为答案。 模板:\n1 2 3 4 5 6 7 8 9 10 11 double bsearchfordouble(double l,double r) { while(r - l \u0026gt; 1e-6 )//精度一般比题目要求小数位数+2 { double mid = (l + r) / 2; if(check(mid)) r = mid; else l = mid; } printf(\u0026#34;%lf\\n\u0026#34;,l); return 1; } 高精度 高精度是什么范围： 若A + B或A - B，则A与B的位数小于等于1e6；若A * B，则A的位数小于等于1e6，而B的大小小于等于1e5。 大整数的存储：先写进string然后再导进数组来存，每一位都是数组的一个元素，注意要倒着存。a[0]存个位，a[1]存十位，以此类推方便进位直接pushback到数组末尾即可。记得输出的时候也要倒过来输出\n1 2 string a; for(int i = a.size() - 1;i \u0026gt;= 0;i--) A.push_back(a[i]- \u0026#39;0\u0026#39;); 高精度加法 模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e6 + 10; int n, q[N], temp[N]; vector\u0026lt;int\u0026gt; add(vector\u0026lt;int\u0026gt; \u0026amp;A, vector\u0026lt;int\u0026gt; \u0026amp;B) { vector\u0026lt;int\u0026gt; C; int t = 0; // t存放A+B（包括进位） for (int i = 0; i \u0026lt; A.size() || i \u0026lt; B.size(); i++) { if (i \u0026lt; A.size()) t += A[i]; if (i \u0026lt; B.size()) t += B[i]; C.push_back(t % 10); // t % 10即本位 t /= 10; // 进位 } if (t) C.push_back(1); // 若最高位仍有进位则直接放在最后 while(C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0)C.pop_back(); //去掉前导0 return C; } int main() { string a, b; vector\u0026lt;int\u0026gt; A, B; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; for (int i = a.size() - 1; i \u0026gt;= 0; i--) A.push_back(a[i] - \u0026#39;0\u0026#39;); for (int i = b.size() - 1; i \u0026gt;= 0; i--) B.push_back(b[i] - \u0026#39;0\u0026#39;); auto C = add(A, B); for (int i = C.size() - 1; i \u0026gt;= 0; i--) printf(\u0026#34;%d\u0026#34;, C[i]); return 0; } 高精度乘法 与我们手写乘法是不一样的，不是一位一位去乘，而是将一个乘数看作一个整体（模板中为b），用另一个乘数(模板中为A)的每位去乘上这个整体。 模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; mul(vector\u0026lt;int\u0026gt; \u0026amp;A, int b) { vector\u0026lt;int\u0026gt; C; int t = 0; // 存储每一位产生的进位 for (int i = 0; i \u0026lt; A.size() || t; i++) { if (i \u0026lt; A.size()) t += A[i] * b; C.push_back(t % 10); // 留下的本位 t /= 10; // 产生的进位 } while(C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0)C.pop_back(); //去掉前导0 return C; } int main() { string a; int b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; vector\u0026lt;int\u0026gt; A; for (int i = a.size() - 1; i \u0026gt;= 0; i--) A.push_back(a[i] - \u0026#39;0\u0026#39;); auto C = mul(A, b); for (int i = C.size() - 1; i \u0026gt;= 0; i--) printf(\u0026#34;%d\u0026#34;, C[i]); return 0; } 高精度除法 如果只有除法的话，可以将大数正着存，因为除法顺序从高位开始算，但是一般会有混合运算，因此模板依然是倒着存的。 模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; // A/b,商为C，余数为r vector\u0026lt;int\u0026gt; div(vector\u0026lt;int\u0026gt; \u0026amp;A, int b, int \u0026amp;r) { vector\u0026lt;int\u0026gt; C; r = 0; for (int i = A.size() - 1; i \u0026gt;= 0; i--) { r = r * 10 + A[i]; C.push_back(r / b); // 每一位去除以b r %= b; // 对b取余得到剩下的余数 然后在下一轮里乘10继续运算 } reverse(C.begin(), C.end()); while (C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) C.pop_back(); // 去掉前导0 return C; } int main() { string a; int b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; vector\u0026lt;int\u0026gt; A; for (int i = a.size() - 1; i \u0026gt;= 0; i--) A.push_back(a[i] - \u0026#39;0\u0026#39;); int r; // 余数 auto C = div(A, b, r); for (int i = C.size() - 1; i \u0026gt;= 0; i--) printf(\u0026#34;%d\u0026#34;, C[i]); cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; return 0; } 双指针算法 分为两个大类：\n两个指针分别遍历各自管辖区间的双指针（eg：归并排序） 两个指针一起维护一个区间的双指针(eg：快速排序) 核心思想：将原本该用双重循环的朴素算法由O(n^2)优化至O(n) 简易模版形式： 1 2 3 4 5 for (int i = 0, j = 0; i \u0026lt; n;i++) { while(j \u0026lt; i \u0026amp;\u0026amp; check(i,j)) j++; //判断j是否满足某个性质 //每道题目的具体逻辑 } 位运算 如何操作二进制数字里的第k位数字 基本思路：\n先把第k位右移到最后一位 即n \u0026gt;\u0026gt; k 看个位是几也就是最初的第k位数字是几 n \u0026amp; 1 lowbit函数介绍 lowbit(x) ：返回x作为二进制数的最右侧的1以及其右侧的0 eg： lowbit(1010) = 10; lowbit(101000) = 1000; 实现逻辑：是通过x \u0026amp; (-x + 1)来实现的，其中-x即x的取反\n离散化 当数据的值域很大，但数据的个数比较小（范围大但稀疏）的时候可以考虑离散化。将这些不连续的数据，映射到一个连续的区间上。 注意以下问题：\n若原数据中有重复元素，需要去重。原数据乱序，需要排序。 排序并去重模板： 1 2 3 vector\u0026lt;int\u0026gt; alls; sort(alls.begin(),alls.end()); alls.erase(unique(alls.begin(),alls.end()),alls.end()); 如何算出原数据中的数据映射后是多少，即其离散化的值。 二分 1 2 3 4 5 6 7 8 9 10 11 int find(int x) //找到第一个大于等于x的位置 { int l = 0,r = alls.size() - 1; while( l \u0026lt; r ) { int mid = l + r \u0026gt;\u0026gt; 1; if(alls[mid] \u0026gt;= x) r = mid; else l = mid + 1; } return r + 1; //如果有+1则是从1开始映射，没有则是从0开始映射 } 后续对于每个离散化后的位置进行相应操作即可。 区间合并 把有交集的两个区间合并成一个区间 步骤：\n按所有区间的左端点进行排序。 扫描每个区间，进行维护：对于每个区间的下一个区间与此区间之间的关系只有三种情况即{是当前区间子集、与当前区间有交集但不是子集、与当前区间无交集}，分别对应三种处理情况即{两区间合并后仍是当前区间因此不用合并、两区间合并后比当前区间长因此进行合并并更新当前区间长度、两区间无法合并维持当前区间} 模板： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef pair\u0026lt;int,int\u0026gt; PII; const int N = 100010; int n; //待维护区间数目 vector\u0026lt;PII\u0026gt; segs; void merge(vector\u0026lt;PII\u0026gt; \u0026amp;segs)//合并操作 { vector\u0026lt;PII\u0026gt; res;//存储合并后的结果 sort(segs.begin(),segs.end()); int st = -2e9,ed = 2e9; //以数据范围定义开始的边界（这里是正负无穷 也就是所有范围全部扫描维护） for(auto seg:segs) { if (ed \u0026lt; seg.first) //当前维护区间与枚举的区间没有任何交集（右端点小于人家左端点） { //说明 当前维护的区间已经维护结束 应该放入答案里作为合并完的独立区间了 if (st != -2e9) res.push_back({st,ed});//只要不是初始区间，就是一个答案 st = seg.first,ed = seg.second; //更新至下一个区间 } else //此时所维护区间与枚举区间有交集 取并集 { ed = max(ed,seg.second); } } if(st != -2e9) res.push_back({st,ed});//把最后一个区间加入答案 segs = res; //更新答案 } int main() { cin \u0026gt;\u0026gt; n; for(int i = 0;i \u0026lt; n;i++) { int l,r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; segs.push_back({l,r}); } merge(segs); cout \u0026lt;\u0026lt; segs.size() \u0026lt;\u0026lt; endl; } 数据结构 链表与邻接表：树与图的存储 数组实现单链表 用一个数组来记录结点值，一个数组来记录下一结点位置，两个数组之间通过数组下标相关联。 模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点 int head, e[N], ne[N], idx; // 初始化 void init() { head = -1; idx = 0; } // 在链表头插入一个结点idx，值为a void insert(int a) { e[idx] = a, ne[idx] = head, head = idx ++ ; } // 在下标为k的结点后插入一个结点idx，值为a void add(int k,int a) { e[idx] = a;ne[ide] = ne[k];ne[k] = idx; idx++; } // 将头结点删除，需要保证头结点存在 void remove_head() { head = ne[head]; } // 删除下表为k的下一个结点 void remove(int k) { ne[k] = ne[ne[k]]; } 数组实现双链表 模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点 int e[N], l[N], r[N], idx; // 初始化 void init() { //0是左端点，1是右端点 r[0] = 1, l[1] = 0; idx = 2; } // 在节点a的右边插入一个数x void insert(int a, int x) { e[idx] = x; l[idx] = a, r[idx] = r[a]; l[r[a]] = idx, r[a] = idx ++ ; } // 删除节点a void remove(int a) { l[r[a]] = l[a]; r[l[a]] = r[a]; } 栈与队列：单调队列、单调栈 单调栈、单调队列的思想：先用暴力原始的数据结构做，看看过程中哪些元素是绝对用不到的，删去这些元素看看留下的元素会不会有单调性，那么在留下的元素中头尾可取极值，查找可用二分，就可以用各种优化算法优化。\n数组实现栈 栈：先进后出 模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // tt表示栈顶 int stk[N], tt = 0; // 向栈顶插入一个数 stk[ ++ tt] = x; // 从栈顶弹出一个数 tt -- ; // 栈顶的值 stk[tt]; // 判断栈是否为空，如果 tt \u0026gt; 0，则表示不为空 if (tt \u0026gt; 0) { } 单调栈 常见的单调栈题型：给定一个序列，求序列中每个数的左/右侧离他最近且比他的小/大的数是谁。 模板：\n1 2 3 4 5 6 int tt = 0; for (int i = 1; i \u0026lt;= n; i ++ ) { while (tt \u0026amp;\u0026amp; check(stk[tt], i)) tt -- ; stk[ ++ tt] = i; } //这里是左侧最近且比他小的数 数组实现队列 队列：先进先出 模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // hh 表示队头，tt表示队尾 int q[N], hh = 0, tt = -1; // 向队尾插入一个数 q[ ++ tt] = x; // 从队头弹出一个数 hh ++ ; // 队头的值 q[hh]; // 判断队列是否为空，如果 hh \u0026lt;= tt，则表示不为空 if (hh \u0026lt;= tt) { } 单调队列 最常见的题型：滑动窗口中输出每个窗口的最大/小数。 模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 //队列里存的是元素的下标而非元素值 a[]中存的是值 k是滑动窗口长度 int hh = 0, tt = -1; for (int i = 0; i \u0026lt; n; i ++ ) { while (hh \u0026lt;= tt \u0026amp;\u0026amp; i - k + 1 \u0026gt; q[hh]) hh ++ ; //检查队列头部元素是否已滑出窗口。若当前窗口左边界（i - k + 1）超过队头元素的下标q[hh]，则队头元素失效，需将其移出队列 while (hh \u0026lt;= tt \u0026amp;\u0026amp; a[q[tt]] \u0026gt;= a[i]) tt -- ; //新元素a[i]若比队尾元素对应的值更小，则说明队尾元素不可能成为后续窗口的最小值，将其弹出队列。此操作保证队列始终单调递增。 q[ ++ tt] = i; //将当前元素的下标加入队尾。此时队列中元素对应的a[]值严格递增。 if (i \u0026gt;= k - 1) cout \u0026lt;\u0026lt; a[q[hh]]; //当窗口覆盖至少k个元素时（即i \u0026gt;= k-1），队头元素即为当前窗口的最小值。 } kmp 思路：先想暴力算法怎么做，然后去想如何优化 模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // s[]是长文本，p[]是模式串，n是s的长度，m是p的长度 // 求模式串的Next数组： for (int i = 2, j = 0; i \u0026lt;= m; i ++ ) { while (j \u0026amp;\u0026amp; p[i] != p[j + 1]) j = ne[j]; // 回溯至前一个公共前后缀位置 if (p[i] == p[j + 1]) j ++ ; // 匹配成功则扩展公共前后缀长度 ne[i] = j; // 记录当前位置的最长公共前后缀长度 } // 匹配 for (int i = 1, j = 0; i \u0026lt;= n; i ++ ) { while (j \u0026amp;\u0026amp; s[i] != p[j + 1]) j = ne[j]; // 失配时利用next数组回溯 if (s[i] == p[j + 1]) j ++ ; // 匹配成功则继续比较下一个字符 if (j == m) // 完全匹配成功 { j = ne[j]; // 跳转至下一个可能匹配的起始位置 // 匹配成功后的逻辑 } } Trie Trie树（又称字典树、前缀树或单词查找树）是一种专为字符串设计的树形数据结构，用来高效存储和查找字符串集。其核心思想是通过共享公共前缀来高效存储和检索字符串集合。 1.根节点不存储字符，仅作为起始点。2.​内部节点存储单个字符，并通过指针指向子节点（通常用数组或哈希表实现）。3.​叶子节点或特定内部节点标记字符串的结束（如设置isEnd标志位）。4.从根节点到某一节点的路径上所有字符连起来构成对应的字符串。 模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 int son[N][26], cnt[N], idx; // 0号点既是根节点，又是空节点，idx是当前的节点 // son[][]存储树中每个节点的子节点，这里第二层的大小由每个节点最多有几个子节点来确定，这里因为全是小写字母所以最多26个 // cnt[]存储以每个节点结尾的单词数量 // 插入一个字符串 void insert(char *str) { int p = 0; // 从根节点开始 for (int i = 0; str[i]; i++) { int u = str[i] - \u0026#39;a\u0026#39;; // 字符转索引（0-25） if (!son[p][u]) // 若路径不存在则创建新节点 son[p][u] = ++idx; // 分配新节点并更新idx p = son[p][u]; // 移动到子节点 } cnt[p]++; // 标记字符串结束，统计词频 } // 查询字符串出现的次数 int query(char *str) { int p = 0; for (int i = 0; str[i]; i++) { int u = str[i] - \u0026#39;a\u0026#39;; if (!son[p][u]) // 路径中断，字符串不存在 return 0; p = son[p][u]; // 沿路径移动 } return cnt[p]; // 返回词频 } 并查集 基本思想：用树的形式来维护所有的集合，每个集合是一棵树，根节点的编号就是集合的编号，每个节点都存储其父节点是谁。\n问题1：如何判断是否是树根？if(p[x] == x) 问题2：如何求x的集合编号？while(p[x]!=x)x = p[x] 问题3：如何合并两个集合？将一棵树的树根连到另一棵树上成为其子树就行了。 路径压缩优化：每次搜索的时候，都在搜索的过程中将路过的点全部直接连到树根上，那么下次搜索的时候直接O(1)即可 并查集的两个重要操作：1.将两个集合合并 2.询问两个元素是否在一个集合中 朴素并查集模板： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int p[N]; //存储每个点的祖宗节点 // 返回x的祖宗节点(x所在集合的编号) + 路径压缩 int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } if(find(a) == find(b))//两节点是否处于同一集合 // 初始化，假定节点编号是1~n for (int i = 1; i \u0026lt;= n; i ++ ) p[i] = i; // 合并a和b所在的两个集合： p[find(a)] = find(b); 维护集合大小size的并查集：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int p[N], size[N]; //p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量 // 返回x的祖宗节点(x所在集合的编号) + 路径压缩 int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } // 初始化，假定节点编号是1~n for (int i = 1; i \u0026lt;= n; i ++ ) { p[i] = i; size[i] = 1; } // 合并a和b所在的两个集合（将a合并进b的集合）： size[find(b)] += size[find(a)]; p[find(a)] = find(b); ### 堆 堆（Heap）是一种特殊的树形数据结构，通常以完全二叉树形式实现。最大堆：父节点的值恒大于或等于子节点（根节点为最大值）；​最小堆：父节点的值恒小于或等于子节点（根节点为最小值） 小根堆模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // h[N]存储堆中的值, 下标从1开始，h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1 // ph[k]存储第k个插入的点在堆中的位置(下标) // hp[k]存储堆中下标是k的点是第几个插入的 int h[N], ph[N], hp[N], size; // 交换两个点，及其映射关系 void heap_swap(int a, int b) { swap(ph[hp[a]], ph[hp[b]]); // 交换插入顺序对应的堆位置 swap(hp[a], hp[b]); // 交换堆位置对应的插入顺序 swap(h[a], h[b]); // 交换堆中实际值 } void down(int u)//下移节点 { int t = u; if (u*2 \u0026lt;= size \u0026amp;\u0026amp; h[u*2] \u0026lt; h[t]) t = u*2; // 左子节点更小 if (u*2+1 \u0026lt;= size \u0026amp;\u0026amp; h[u*2+1] \u0026lt; h[t]) t = u*2+1; // 右子节点更小 if (u != t) { // 需要调整 heap_swap(u, t); // 交换并维护映射 down(t); // 递归下沉 } } void up(int u)//上移节点 { while (u/2 \u0026amp;\u0026amp; h[u] \u0026lt; h[u/2]) { // 父节点存在且当前节点更小 heap_swap(u, u/2); // 与父节点交换 u \u0026gt;\u0026gt;= 1; // 移动到父节点位置 } } // O(n)建堆 for (int i = n / 2; i; i -- ) down(i); 堆所能执行的操作：\n插入一个数 heap[++size] = x;up(size); 求集合中的最小值 heap1 删除最小值 heap[1] = heap[size];size\u0026ndash;;down(1); 删除任意一个元素 heap[k] = heap[size];size\u0026ndash;;down(k);up(k); 修改任意一个元素 heap[k] = x;down(k);up(k); Hash表 C++STL使用技巧 ","date":"2025-03-19T00:00:00Z","image":"https://Nanmur.github.io/logo.png","permalink":"https://Nanmur.github.io/p/acwing/","title":"Acwing算法基础班笔记（更新中）"},{"content":"第1章ASP.NET运行及开发环境知识点总结 1. ASP.NET概述 1.1静态页面和动态页面 静态页面：仅含HTML元素和CSS样式，扩展名.htm或.html，内容固定，由浏览器解释执行，访问速度快，适用于内容无需通过数据库更新的情况。 动态页面：包含HTML、CSS、JavaScript及服务器端编译执行代码，开发技术多样，内容存储于数据库，需服务器转换为静态页面后在浏览器显示，适用于内容需动态更新的场景。 二者关系：ASP.NET网站可同时存在静态和动态页面。 1.2.NET Framework 定义：是Microsoft应用程序开发框架，提供一致开发模型。 主要组件：公共语言运行库（CLR）和.NET Framework类库。 1.3ASP.NET特性 是.NET Framework组件，与.NET Framework完美整合，属于编译型。 1.4ASP.NET的开发模式 ASP.NET Web窗体：常用模式，包含页面呈现标记和处理事件代码。 ASP.NET MVC：包含模型、视图和控制器，模型处理数据逻辑，视图显示界面，控制器协调两者。 ASP.NET Core：ASP.NET重构版本，可跨平台开发部署。 2. IIS 2.1IIS 7.5的安装 通过“开始”→“控制面板”→“程序”→“打开或关闭Windows功能”安装，若IIS 7.5在VS 2017安装后安装，需以管理员身份运行cmd.exe并输入特定命令注册ASP.NET。 2.2IIS 7.5中的网站、Web应用程序和虚拟目录 网站：Web应用程序容器。 Web应用程序：在应用程序池中运行，通过HTTP提供Web内容。 虚拟目录：映射物理文件夹的别名。三者呈层次关系，通过“Internet信息服务(IIS)管理器”配置，相关信息存储在特定配置文件中。 操作示例：包括添加网站、应用程序池、Web应用程序、虚拟目录及设置默认文档（可通过“功能视图”或Web.config配置文件设置）。 2.3IIS Express 默认用于运行网站，配置信息保存于特定文件，该文件所在文件夹具有隐藏属性且与解决方案文件同处。 3. Visual Studio Community 2017 3.1开发环境概览 提供方便的ASP.NET网站开发环境，免费且功能齐全，与VS 2017商用版创建的Web应用程序兼容，适用于学习和中小企业开发。开发环境中有“调试运行”“编排整个文档的格式”等按钮，可通过相关命令设置环境（如字体、颜色、项目和解决方案、文本编辑器等）。 3.2使用解决方案管理VSC 2017中新建的网站 可新建空白解决方案，再向其中添加不同类型项目（如ASP.NET空网站等），在解决方案资源管理器中管理项目文件结构。 3.3发布Web应用 可部署到Microsoft Azure或IIS，发布方式多样（如Web部署、Web Deploy包、FTP、文件系统等），涉及预编译（将特定文件编译为.dll程序集）和动态编译（页面访问时自动编译并缓存输出），需以管理员身份启动VSC 2017进行发布操作。 3.4复制网站 在当前与另一网站间复制文件，不预编译，支持同步，常用于网站迁移，可组合“发布网站”和“复制网站”保护源代码。 4. 小结 ASP.NET网站含静态和动态页面，.NET Framework是基础，开发模式多样，IIS提供运行环境，VSC 2017方便开发。 第2章ASP.NET网站文件、jQuery和Bootstrap知识点总结 1. HTML文件和XHTML5 1.1HTML文件结构 由DOCTYPE声明、html根元素、head头部和body主体部分组成，head中包含meta元信息、title标题等，body包含页面内容。 1.2常用XHTML5元素 注释、DOCTYPE声明、html元素、head元素、meta元素（设置字符集、提供关键词等）、title元素、style元素、body元素、header、aside、section、article、footer、nav、h1 - h6标题、div层、p段落、br换行、hr水平线、table表格、a超链接等，还有常用实体符号。 2. ASPX文件 2.1单文件页模型 界面和逻辑代码放同一.aspx文件，逻辑代码在\u0026lt;html\u0026gt;之上的\u0026lt;script runat=\u0026quot;server\u0026quot;\u0026gt;中，通过事件名关联执行方法。 2.2代码隐藏页模型 界面代码在.aspx文件，逻辑处理代码在.aspx.cs文件，.aspx文件通过@Page指令引用外部文件，包括AutoEventWireup、CodeFile、Inherits等属性。 3. CSS文件和CSS常识 3.1定义CSS3样式 选择器类型：*选择器（全局设置）、元素选择器（重定义XHTML元素属性）、属性选择器（多种属性条件选择）、类选择器（应用于不同或子集元素）、id选择器（单个元素属性设置）。 样式声明：由属性和值组成。 3.2CSS3样式位置 内联样式（在XHTML元素style属性中，优先级最高）、页面样式（在\u0026lt;head\u0026gt;的\u0026lt;style\u0026gt;元素中）、外部样式表（.css文件，通过\u0026lt;link\u0026gt;元素链接到页面，优先级最低）。 4. JS文件和JavaScript常识 4.1JavaScript代码位置 \u0026lt;head\u0026gt;中（通常为函数，调用时执行）、\u0026lt;body\u0026gt;中（页面载入时执行）、独立.js文件（多个页面调用时使用，通过\u0026lt;script\u0026gt;的src属性引入）。 4.2综合实例 实现图片动态变化（鼠标指向切换图片）、简易时钟（显示客户端时间）等功能，涉及事件触发、函数调用、元素操作等。 5. jQuery 5.1jQuery基础语法 格式$(selector).action()，selector选择对象，action执行操作，常用选择器（*、元素、属性、类、id、first、contains等）和方法（attr、bind、click、css、fadeIn等）。 5.2综合实例 管理XHTML元素（隐藏、显示、更改内容和样式、淡入淡出等）、实现时间数据来源于服务器端的时钟（通过Ajax实现局部刷新）。 6. XML文件和XML常识 用于跨平台交换数据，可自定义标记，与XHTML区别（XML传输存储数据，XHTML显示数据），XML文件结构包含声明、根元素、子元素等，如早餐菜单示例。 7. Web.config XML格式，存储配置信息，有网站根文件夹和子文件夹层级关系，包含连接字符串、身份验证、页面、会话状态等配置节点。 8. Global.asax 全局应用程序类文件，存储应用程序和会话级别事件响应代码，如启动、关闭、错误、会话开始和结束等事件处理方法，必须在根文件夹且唯一。 9. Bootstrap 主流Web前端框架，基于HTML5、CSS3、JavaScript和jQuery，支持响应式设计，通过NuGet安装，引用相关CSS和JS文件（注意依赖jQuery），有预设置样式、可重用组件和自定义插件，如用于设计表单（通过class或CssClass属性调用类选择器）。 10. 小结 ASPX文件内容最终转化为XHTML显示，开发常用代码隐藏页模型，CSS统一风格，JavaScript提供动态功能，jQuery方便控制元素，XML用于数据交换，Web.config存储配置，Global.asax处理全局和会话事件，Bootstrap是主流前端框架。 第3章C##和ASP.NET的结合知识点总结 1. C##概述 为.NET打造，运行于.NET Framework环境，可构建健壮应用，有统一类型系统和组件编程支持，不直接操作内存。 2..NET Framework命名空间 常用命名空间如System（基本类）、System.Configuration（配置文件处理类）、System.Data（ADO.NET类访问）、System.Web（浏览器与服务器通信类）等，涵盖数据访问、Web开发、安全等功能。 3. 编程规范 3.1程序注释 类、方法、属性用XML文档格式注释，在类接口头部、公共方法前、代码块结束、分支语句处应编写注释。 3.2命名规则 Pascal形式（首字母及连接单词首字母大写）用于类、枚举类型、方法等；Camel形式（首字母小写，连接单词首字母大写）用于参数、变量名等，还有常用控件名简写规范。 4. 常量与变量 4.1常量声明 用const声明，需初始化，有访问修饰符，值在编译时不变。 4.2变量声明 先声明后使用，由数字、字母、下划线组成，区分大小写，修饰符决定访问范围，方法中定义的局部变量不能用部分修饰符，有静态变量（类直接访问）和只读变量（初始化后不可改）。 4.3修饰符 包括public、internal、protected、protected internal、private、static、readonly，影响变量访问范围和特性。 4.4局部变量作用范围 块级（if、while等语句内）、方法级（声明方法内）、对象级（类所有方法内，页面结束时删除）。 5. 数据类型 5.1值类型 包含简单类型（整数、布尔、字符、实数）、结构类型、枚举类型，变量直接存数据，操作互不影响。 5.2引用类型 有class类型、object类型、string类型、接口类型、数组类型、委托类型，变量存数据引用，操作可能影响其他引用同一对象的变量。 5.3装箱和拆箱 实现值类型与引用类型转换，装箱是值转对象，拆箱是对象转值。 6. 运算符 总结常用运算符及优先级（表格形式呈现）。 7. 流程控制 7.1选择结构 If语句（两种格式，判断相等用“==”）、switch语句（按控制表达式值匹配执行相应语句序列）。 7.2循环结构 While语句（先判断条件再执行语句序列）、do - while循环（先执行一次语句序列再判断条件）、for语句（按初始化、条件判断、控制表达式执行循环）、foreach语句（枚举数组或集合元素）。 7.3异常处理 异常产生于操作异常，处理方式有throw语句（抛出异常）和try\u0026hellip;catch\u0026hellip;finally结构（捕获并处理异常）。 8. 自定义ASP.NET类 8.1类的常识 ASP.NET面向对象，类是模板，有封装性（隐藏实现方法，暴露属性方法）、继承性（类继承特征）、多态性（继承类有同名方法），创建类用特定语法格式，修饰符有多种。 8.2属性 通过get和set访问器获取或改变私有字段内容，体现封装性，只读属性仅含get访问器。 8.3构造函数 实例化对象时调用，与类名相同且为public，若未定义，编译器自动提供默认构造函数，可用于初始化对象参数。 8.4方法 反映对象行为，有访问修饰符，void修饰符表示无返回值，如银行账户类的存款取款方法（含异常处理）。 8.5事件 用于类间传递消息或触发行为，通过委托声明，有定义、触发、注册和编写处理代码等步骤，如账户金额不足事件。 8.6继承 重用基类数据行为并扩展功能，派生类继承基类，如企业账户类继承账户类并增加属性。 9. ASP.NET页面调试 调试检查代码运行，配置Web.config文件\u0026lt;system.web\u0026gt;元素的\u0026lt;compilation\u0026gt;为调试模式（debug=\u0026ldquo;true\u0026rdquo;），常用操作有断点设置（右击语句选择“断点”→“插入断点”），调试中可用F5启动、“局部变量”窗口查看变量、“监视”窗口监视变量表达式、“即时窗口”计算输出更改变量、F10逐过程、F11逐语句、Shift+F5结束调试。 10. 小结 C##适合ASP.NET开发，遵循.NET Framework命名空间和编程规范，处理异常使程序健壮，自定义类扩展功能，要注重页面调试能力培养。 第4章ASP.NET标准控件知识点总结 1. ASP.NET页面事件处理概述 1.1ASP.NET页面事件 常见页面事件包括Page.PreInit（确定页面处理、创建动态控件等）、Page.Init（初始化控件属性）、Page.Load（读取更新控件属性）、控件事件（如Click、Changed等），事件处理顺序为Page.PreInit、Page.Init、Page.Load和控件事件，Click事件引发页面往返，Changed事件信息暂存客户端，AutoPostBack属性为True时可使Changed事件立即响应服务器，设置逻辑值属性时在.aspx和.aspx.cs文件中有大小写区别。 1.2IsPostBack属性 用于判断页面是否为首次加载，在@Page指令AutoEventWireup属性为true时，ASP.NET自动绑定页面事件，控件事件需设置On事件名属性绑定，可通过判断Page.IsPostBack属性值决定是否执行Page_Load方法代码。 2. ASP.NET服务器控件概述 2.1HTML服务器控件简介 将XHTML元素转换为服务器控件，在“源”视图中为XHTML元素添加runat=\u0026ldquo;server\u0026quot;属性实现转换。 2.2Web服务器控件简介 包括标准控件（按钮、文本框等）、数据控件（数据库操作）、验证控件（用户输入验证）、导航控件（网站导航）、AJAX扩展控件（局部更新）、动态数据控件（创建动态数据页面）、用户自定义控件（扩展功能）。 3. 常用ASP.NET标准控件 3.1Label控件 用于显示文本，Text属性设置显示内容，AssociatedControlID属性可关联其他服务器控件，如通过设置快捷键激活特定文本框。 3.2TextBox控件 文本框类型由TextMode属性设置，AutoPostBack属性为true时内容改变且焦点移出触发TextChanged事件，AutoCompleteType属性指定自动完成类型，Focus方法设置焦点，如在登录页面中实现焦点定位、用户名可用性判断、密码框显示和邮箱自动完成功能（实际应用需连接数据库）。 3.3Button、LinkButton和ImageButton控件 Button为传统按钮外观，LinkButton为超链接外观，ImageButton为图形外观（由ImageUrl属性设置），PostBackUrl属性用于跨页面提交，Click事件执行服务器端代码，ClientClick事件在Click事件前执行客户端代码，LinkButton可通过PostBackUrl属性或Click事件中的Redirect方法实现超链接，如删除数据时弹出确认对话框。 3.4DropDownList控件 数据源由DataSource属性设置，DataTextField和DataValueField属性对应数据源字段用于显示和取值，Items属性为选项集合（可添加、删除项），SelectedItem和SelectedValue属性获取当前选定项，SelectedIndexChanged事件在选择项改变时触发，DataBind方法绑定数据源，如实现日期联动下拉列表（年、月改变时更新日的选项）。 3.5ListBox控件 与DropDownList类似但列表可见且可多选，SelectionMode属性为Multiple时允许选择多项，如实现数据项在两个ListBox控件间移动。 3.6CheckBox和CheckBoxList控件 用于“真/假”等选项选择，CheckBox用Checked属性判断是否选中，CheckBoxList用成员的Selected属性判断，实际工程中CheckBoxList的AutoPostBack属性常为False，配合Button控件提交数据，如选择个人爱好后单击按钮显示提示信息。 3.7RadioButton和RadioButtonList控件 用于单项选择，多个RadioButton通过GroupName属性形成一组，RadioButton用Checked属性判断是否选中，RadioButtonList用SelectedItem属性获取选中项。 3.8Image和ImageMap控件 Image用于显示图片（由ImageUrl属性指定源文件，常与数据源绑定），无Click事件，ImageMap可划分热点区域（通过HotSpot集合编辑器设置），点击热点链接到不同页面，如用ImageMap设计导航条。 3.9HyperLink控件 创建链接，可与数据源绑定，Target属性指定链接页面显示方式（_blank新窗口，_self原窗口），无Click事件，Text和ImageUrl属性同时设置时ImageUrl优先，如组合HyperLink和Image控件实现图片尺寸不同效果。 3.10Table控件 动态创建表格（与用于布局的\u0026lt;table\u0026gt;元素不同），由TableRow对象组成行，TableCell对象组成单元格，添加行、单元格和控件分别使用Rows、Cells、Controls属性，如创建简易成绩录入界面。 3.11Panel和PlaceHolder控件 都为容器控件，用于动态创建控件和根据情况显示不同内容，Panel可在同一页面呈现不同内容（通过设置可见性），PlaceHolder在页面载入时动态添加控件（动态生成控件代码需在Page_Load方法中，不能直接绑定方法代码需手工注册，获取输入信息需用FindControl方法），如用Panel实现简易注册页面和用PlaceHolder动态添加控件。 4. 小结 理解ASP.NET页面事件处理流程及常用事件触发顺序，利用IsPostBack属性控制页面往返时代码执行，可转换XHTML元素为HTML服务器控件，Web服务器标准控件是构建Web窗体的基础。 第5章ASP.NET窗体验证知识点总结 1. 窗体验证概述 1.1验证概念 验证是为收集的数据制定规则，不能确保数据真实性，仅判断是否满足规则，分为客户端（利用JavaScript在数据发送到服务器前验证）和服务器端（将用户输入信息发送到Web服务器验证）两种形式。 1.2配置相关 隐式验证配置：通过NuGet安装jQuery，在Global.asax文件的Application_Start方法中添加代码映射jQuery路径；禁用隐式验证在Web.config文件\u0026lt;configuration\u0026gt;元素中添加配置代码。Page.IsValid属性用于判断页面所有控件是否通过验证（true为通过，false为未通过）。 2. ASP.NET服务器验证控件 2.1通用属性 基本属性：ControlToValidate指定要验证控件ID；Display指定显示方式（Static始终占用、Dynamic验证错误时占用、None在ValidationSummary控件显示）；EnableClientScript设置是否启用客户端验证（默认True）；ErrorMessage设置在ValidationSummary中显示错误信息（Text为空时代替）；SetFocusOnError确定验证无效时是否定位焦点；Text设置验证控件显示信息；ValidationGroup设置分组名；CausesValidation属性值False表示不执行验证。 多规则验证：对一个控件设置多个规则用多个验证控件，ControlToValidate属性相同；分组验证通过设置同一组控件的ValidationGroup属性为相同组名实现。 2.2RequiredFieldValidator控件 用于验证必须输入信息的控件，如用户名、密码等，InitialValue属性指定被验证控件初始文本，输入值与初始值不同时验证才通过，如禁止用户名空数据且不能与初始值相同。 2.3CompareValidator控件 比较一个控件值与另一个控件值或指定值，ControlToCompare指定比较控件ID，Operator设置操作符，Type设置数据类型，ValueToCompare指定比较值（ControlToCompare和ValueToCompare只能选一个），如密码和确认密码是否一致、答案是否为特定值、金额数据类型验证。 2.4RangeValidator控件 验证输入值是否在指定范围，通过MaximumValue和MinimumValue属性设置范围，如成绩在0 - 100之间、日期在特定区间内。 2.5RegularExpressionValidator控件 验证输入值与正则表达式是否匹配，常用于电话号码、邮政编码、Email等验证，ValidationExpression属性确定正则表达式，如验证电子邮件地址格式。 2.6CustomValidator控件 当自带验证控件无法满足需求时使用，通过自定义验证函数调用，客户端验证需设置ClientValidationFunction属性为函数名且EnableClientScript为True，服务器端验证通过ServerValidate事件触发，IsValid属性确定是否通过验证，如验证输入值是否为偶数（有客户端、服务器端和混合验证三种形式）。 2.7ValidationSummary控件 汇总其他验证控件错误信息（ErrorMessage属性值），DisplayMode指定显示格式（BulletList、List、SingleParagraph），ShowMessageBox确定是否在弹出消息框显示错误信息，ShowSummary确定是否启用错误信息汇总，如综合运用多种验证控件时汇总错误信息（可设置焦点定位、错误信息显示方式等）。 3. 小结 窗体验证常同时使用客户端和服务器端验证，ASP.NET提供多种验证功能（必需输入、比较、范围、正则表达式、自定义、错误汇总），实际中同一控件可能使用多个验证控件以达到效果。 第6章HTTP请求、响应及状态管理知识点总结 1. HTTP请求 1.1HttpRequest对象 通过Page类的Request属性访问，封装HTTP请求信息，包含QueryString（读取查询字符串数据）、Cookies（获取客户端Cookie）、ServerVariables（获取服务器或客户端环境变量）、Browser（获取客户端浏览器信息）等数据集合，使用时通过Page类的Request属性调用，如利用QueryString在页面间传递数据、通过ServerVariables和Browser返回服务器端和客户端信息。 2. HTTP响应 2.1HttpResponse对象 通过Page类的Response属性控制输出，实例为HttpResponse类对象，有Cookies属性（添加修改客户端Cookie）、AppendToLog方法（添加自定义日志到IIS日志文件）、End方法（终止页面执行）、Redirect方法（页面重定向，可传数据）、Write方法（输出信息）等，如利用Write方法输出XHTML文本、用Redirect方法重定向页面。 3. HttpServerUtility 3.1对象功能 Page类的Server属性封装服务器端操作，实例为HttpServerUtility类对象，有ScriptTimeOut属性（设置页面执行最长时间）、Execute方法（停止当前页面转去执行新页面后返回）、HtmlEncode方法（转换XHTML元素标记为字符实体）、MapPath方法（获取页面物理路径）、Transfer方法（停止当前页面转去执行新页面后不返回）、UrlEncode方法（转换特殊字符为URL编码）。 3.2重定向方法区别 Redirect方法在客户端重定向（浏览器地址栏变化），Execute和Transfer方法在服务器端重定向（地址栏不变）；Redirect和Transfer方法执行新页面后不返回原页面，Execute方法返回；Redirect可重定向到任意页面，Execute和Transfer只能在同一网站内；Redirect用查询字符串传递数据，Execute和Transfer与Button跨页面提交方式相同，如运用HttpServerUtility对象处理URL地址。 4. 跨页面提交 通过设置Button类型控件的PostBackUrl属性为目标页面路径实现，目标页面需添加@PreviousPageType指令并设置VirtualPath属性为源页面路径，目标页面访问源页面数据可通过PreviousPage.FindControl方法或源页面公共属性，IsCrossPagePostBack属性可区分跨页面提交与调用Server.Execute或Server.Transfer方法，如运用跨页面提交技术实现页面间数据传递。 5. 状态管理 5.1管理方式概述 分为客户端（ViewState、ControlState、HiddenField、Cookie、查询字符串，不耗服务器内存但易泄露数据）和服务器端（Session、Application、数据库，耗服务器内存但安全），如利用Cookie或Session限制页面访问、统计网站在线人数。 5.2ViewState 维护Web窗体状态，封装为隐藏表单域在客户端和服务器端传递，EnableViewState属性可禁用。 5.3HiddenField控件 维护Web窗体状态，不显示在浏览器，有Value属性和ValueChanged事件（需EnableViewState为False触发）。 5.4Cookie 存储在客户端的文本信息，与网站关联，可在客户端修改或禁用，通过System.Web.HttpCookie类处理，有Value和Expires等属性，可在Web.config中设置相关选项，如利用Cookie限制页面访问。 5.5Session 存储用户信息等，服务器端产生，为当前用户服务，以Session ID标识，可通过Cookie或URL传递（明文，可考虑HTTPS保护），有Contents、Mode、SessionID、TimeOut等属性和Abandon、Remove等方法，包含Session_Start和Session_End方法（在Global.asax文件中，仅sessionState模式为InProc时执行Session_End方法），通过多种方式赋值，在Web.config中设置存储方式（常用StateServer，大型网站常用SQLServer）。 5.6Application 应用于所有用户，网站运行时存在，关闭时释放，通过System.Web.HttpApplicationState类实现，修改值需先锁定再解锁，有Application_Start、Application_End、Application_Error等方法，如统计网站在线人数。 6. 小结 HttpRequest对象访问不同数据，HttpResponse对象控制输出，HttpServerUtility对象有多种实用方法（防范SQL注入常用HtmlEncode方法），页面重定向有多种形式且注意区别，状态管理分客户端和服务器端形式且各有特点（Session对应单个用户，Application对应所有用户）。 第7章数据访问知识点总结 1. 数据访问概述 ASP.NET 1.x主要用ADO.NET访问数据，在ASP.NET 2.0中增加多种数据源和数据绑定控件，ASP.NET 3.5引入LINQ技术，ASP.NET 4.0扩展了该技术（新增LINQ to Entities），LINQ to SQL工具需在VSC 2017中手动选中安装。 2. 建立SQL Server 2016 Express数据库 2.1数据库版本 SQL Server 2016 Express免费，适用于学习和中小型企业开发；SQL Server 2016 Express LocalDB更轻量级，开发时无需配置，但发布到IIS 7.5时需更改连接字符串。 2.2连接字符串 存储在Web.config文件`元素中，根据数据库实例类型（SQL Server、SQLEXPRESS、LocalDB）和身份验证形式（Windows验证或SQL Server验证）配置，如访问MyPetShop数据库的连接字符串配置。 2.3MyPetShop数据库 包含多个数据表，通过MyPetShop.sql建立，默认属于LocalDB实例，为支持中文处理可指定排序规则参数，其连接字符串也需相应配置。 3. 使用数据源控件实现数据访问 3.1数据源控件类型 EntityDataSource（访问实体数据模型数据）、LinqDataSource（用LINQ技术访问数据库）、ObjectDataSource（访问多层应用中间层业务对象数据）、SiteMapDataSource（访问网站地图文件）、SqlDataSource（访问多种数据源）、XmlDataSource（访问XML数据源）。 3.2功能特点 提供统一编程模型，通过定义事件实现数据操作（Select、Update、Delete、Insert等），数据操作前后事件可编写代码实现灵活功能，如利用LinqDataSource和GridView显示表数据。 4. 使用LINQ实现数据访问 4.1LINQ类型 LINQ集成于.NET Framework，包括LINQ to Objects（处理集合类型数据）、LINQ to XML（处理XML数据）、LINQ to DataSet（处理DataSet数据）、LINQ to SQL（处理SQL Server数据库数据）、LINQ to Entities（处理实体数据模型）。 4.2LINQ查询表达式 包含from（指定数据源和范围变量）、select（指定结果类型和形式）、where（指定筛选条件）、group（分组）、orderby（排序）、join（连接数据源）、let（创建子表达式范围变量）、into（提供临时标识符）等子句，以from开始，以select或group结束，可实现多种数据操作，如投影（创建匿名对象选择属性）、选择（过滤记录）、排序、分组（结果为集合的集合，需嵌套循环访问）、聚合（使用Count、Max、Min、Average等方法，参数常用Lambda表达式）、连接（可直接引用对象或用join子句，适用于外键关联或未关联表）、模糊查询（调用SqlMethods.Like方法）。 4.3LINQ to SQL概述 数据库与对象映射关系：SQL Server数据库对应DataContext类，表对应实体类，属性对应属性，外键关系对应关联，存储过程对应方法。MyPetShop.dbml定义数据库架构、布局及自动生成相关类（与数据库对应的类和各表实体类），实体类通过特定属性映射数据表关系，在MyPetShopDataContext类中存储过程映射为方法及参数映射。 4.4利用LINQ to SQL管理数据 插入数据：用InsertAllOnSubmit（插入集合数据实体）和InsertOnSubmit（插入单个实体）方法，如向Category表插入数据。 修改数据：先找到需修改数据再操作，如根据CategoryId修改数据（CategoryId标识值不能改）。 删除数据：用DeleteAllOnSubmit（删除实体集合）和DeleteOnSubmit（删除单个实体）方法，如根据CategoryId删除数据。 存储过程：将SQL Server中存储过程拖入MyPetShop.dbml生成对应方法，调用方法使用存储过程，如利用存储过程插入数据。 4.5LINQ to XML概述 XDocument类操作XML文档（Save方法建立文档），XDeclaration类操作声明，XComment类操作注释，XAttribute类操作元素属性，XElement类操作元素（包括获取名称、值、导入导出文档、获取属性、删除替换元素内容、设置属性值等）。 4.6利用LINQ to XML管理XML文档 创建XML文档：用XDocument对象添加声明、元素、注释等内容后保存。 查询XML文档：用LINQ查询表达式可实现多种查询（读取、根元素、指定名称元素、指定属性元素、指定元素子元素等）。 插入元素：建立XElement实例添加内容后用Add方法插入并保存。 修改元素：查找元素后用SetAttributeValue和ReplaceNodes方法修改并保存。 删除元素：查找元素后用Remove方法删除并保存。 5. 小结 LINQ技术与编程语言整合，将数据作为对象处理，符合发展趋势，能简洁实现数据操作，是Microsoft主要数据访问技术。 第8章数据绑定知识点总结 1. 数据绑定概述 数据绑定控件与数据源控件结合时设置DataSourceID属性为数据源控件ID；与LINQ技术结合时设置DataSource属性为LINQ查询结果并调用DataBind方法显示数据。 2. ListControl类控件 2.1控件属性 AppendDataBoundItems用于追加数据绑定项到静态列表项；DataTextField绑定用于显示的字段；DataValueField绑定用于设置值的字段。 2.2实例应用 如DropDownList与LINQ结合显示Category表数据（页面加载绑定数据，选择项改变时触发事件显示选中项CategoryId值）；根据单选按钮选择项填充列表框内容（选择分类时在列表框显示该分类商品名称）。 3. GridView控件 3.1基本功能 用于显示二维表格式数据，可实现数据绑定、分页（AllowPaging为True，可在PagerSettings设置效果）、排序（AllowSorting为True）、行选择、更新、删除等功能。 3.2定制列操作 自定义列需设置AutoGenerateColumns为False，列类型有BoundField（显示文本）、CheckBoxField（显示布尔型数据）、CommandField（创建命令按钮列）、DynamicField（绑定动态数据列）、ImageField（显示图片列）、HyperLinkField（显示超链接列）、ButtonField（定义按钮列）、TemplateField（自定义模板列），如设置ImageField列的DataImageUrlField属性显示图片（数据库存储路径时直接设置，仅存储文件名时需配合DataImageUrlFormatString属性）。 3.3模板列应用 TemplateField有多种模板（AlternatingItemTemplate、EditItemTemplate、FooterTemplate、HeaderTemplate、ItemTemplate、PagerTemplate），AlternatingItemTemplate与ItemTemplate配合使用决定数据行显示方式。数据绑定方法有Eval（单向只读绑定）和Bind（双向可更新绑定），需包含在\u0026lt;%##...%\u0026gt;中，还可绑定变量等，在模板列中访问控件需用FindControl方法，如利用GridView模板列实现复选框全选及获取选中商品编号。 3.4编辑删除数据 单击智能标记选择“启用编辑”和“启用删除”提供编辑删除功能（数据源控件需支持），如为“删除”按钮添加客户端提示信息（需处理RowDataBound事件，考虑主键字段特性及编辑时按钮消失情况）；结合GridView和独立页修改数据（通过链接跳转到独立页，传递参数查询并修改数据）。 3.5显示主从表 对应数据库“一对多”联系，可在同一页（如单击“选择”链接在“从表”显示“主表”对应商品，通过gvCategory.SelectedValue传递参数）或不同页（单击“主表”链接在“从表”显示对应商品，传递查询字符串查询绑定数据）显示。 4. DetailsView控件 以表格形式显示处理单条记录（一列显示字段名，一列显示值），增加数据插入功能，如结合GridView和DetailsView管理数据（单击GridView“详细资料”链接在DetailsView显示详细信息，可进行编辑、删除、新建操作，需处理ItemDeleted和ItemInserted事件刷新GridView数据）。 5. 小结 ListControl类以列表形式显示数据；GridView以二维表格形式显示，功能丰富；DetailsView以单条记录形式显示；还有ListView（显示多条记录）、DataList（完全使用模板的数据列表控件）、FormView（显示单条记录且完全通过模板实现）等数据绑定控件。 第9章ASP.NET三层架构知识点总结 1. ASP.NET三层架构概述 1.1架构背景 Web窗体的二层架构（.aspx文件用于界面显示，.aspx.cs文件用于事件处理）存在耦合度高、扩展性差、不利于团队分工合作的问题，由此引出ASP.NET三层架构。 1.2架构组成 表示层（Web）：负责与用户交互，展示数据和接收用户输入。 业务逻辑层（BLL）：处理业务规则和逻辑，调用数据访问层获取或保存数据。 数据访问层（DAL）：与数据库交互，执行数据的查询、插入、更新和删除操作。使用不同数据访问技术时架构成员不同，如使用ADO.NET需增加业务实体类项目Model、数据库访问通用类项目DBUtility等；使用LINQ to SQL技术则只需三层架构基本组成部分。 2. 搭建ASP.NET三层架构 以MyPetShop为例（数据访问使用LINQ技术），步骤为创建空白解决方案，添加ASP.NET空网站作为表示层项目（MyPetShop.Web），添加类库项目作为业务逻辑层（MyPetShop.BLL）和数据访问层（MyPetShop.DAL），并在业务逻辑层项目中引用数据访问层项目。 3. 基于ASP.NET三层架构的用户管理 3.1用户注册 流程：表示层获取注册信息（用户名、Email、密码等），业务逻辑层调用用户名检查、用户添加等方法，数据访问层执行数据库中的用户名重名查询、用户记录插入操作。例如，MyPetShop用户注册功能中，需验证必填信息、Email格式、密码一致性，注册成功或失败有相应提示，注册失败时点击链接可跳转到登录页面并传递用户名。 3.2用户登录 流程：表示层获取登录信息（用户名、密码），业务逻辑层调用用户名和密码检查方法，数据访问层查询数据库中的用户登录信息。如MyPetShop用户登录功能，登录成功或失败有不同界面提示，登录失败时可进行相应操作（如忘记密码、注册新用户）。 3.3用户登录状态和权限 若用户权限信息未存于数据库，流程为表示层获取用户名信息，呈现相应登录状态和权限信息，如根据不同用户（如普通用户jack和管理员admin）在表示层呈现不同登录状态和权限。 3.4用户密码修改 流程：表示层获取原密码、新密码、确认新密码等信息，业务逻辑层调用方法先查询原密码，正确则再调用方法修改数据库中的密码。如修改已登录一般用户密码的操作。 3.5用户密码重置 流程：表示层获取用户名、Email等信息，业务逻辑层调用方法查询数据库中的用户名和Email，正确则重置密码并发送邮件通知用户。如MyPetShop密码重置功能，用户输入信息验证通过后密码重置并收到邮件，可获取新密码登录。 4. 小结 ASP.NET三层架构是企业Web应用开发主流技术，包括表示层、业务逻辑层和数据访问层。用户管理涵盖注册、登录、状态和权限呈现、密码修改和重置等功能，实际开发中还需完善基于角色的用户权限管理等。 第10章主题、母版和用户控件知识点总结 1. 主题 1.1主题概述 提供统一外观，包含外观文件、CSS文件、图片文件等，是定义页面和控件外观属性集合，与主题文件夹对应，存储于App_Themes文件夹，应用程序主题可选择不同风格，由外观文件等组成，还可包含其他资源。 1.2自定义主题 以创建Red主题为例，SkinID属性可为同种控件定义多种外观（无SkinID为默认，有则为已命名外观，同一主题中不允许重复），还可添加CSS和图片文件到主题。 1.3使用主题 可在单个页面（用@Page指令的Theme或StylesheetTheme属性）、网站（修改Web.config文件）或网站部分页面（将页面放文件夹建Web.config或在根Web.config用\u0026lt;location\u0026gt;元素指定）应用主题，禁用主题由控件和页面的EnableTheming属性确定，如动态切换主题实例（根据选择设置Page.Theme属性，注意设置位置和禁用主题控件情况）。 2. 母版页 2.1母版页概述 方便建立统一风格网站，可创建一致布局、处理通用功能、创建控件和代码，由@Master指令识别，包含ContentPlaceHolder占位符控件，扩展名.master，内容页通过MasterPageFile属性指定母版页路径，用Content控件与母版页占位符联系。 2.2创建母版页 如创建“上中下”布局母版页MasterPage.master。 2.3创建内容页 基于母版页创建，仅含要合并内容（文本、控件等），如创建基于MasterPage.master的ContentPage.aspx，通过@Page指令指定母版页。 3. 用户控件 3.1用户控件概述 可重复使用自定义控件，类似ASP.NET页面，用于实现未提供功能或统一页面风格，文件扩展名为.ascx，含@Control指令，不能独立运行，必须添加到Web窗体使用，不含\u0026lt;html\u0026gt;、\u0026lt;body\u0026gt;、\u0026lt;form\u0026gt;元素（由宿主页面提供）。 3.2创建用户控件 可像设计Web窗体一样设计或转换Web窗体为用户控件，转换时注意更改文件扩展名、指令及相关属性（如将单文件页或代码隐藏页转换的具体操作）。 3.3使用用户控件 从“解决方案资源管理器”拖到页面添加，自动添加@Register指令，如SearchUserControl实例（添加到Web窗体后，页面加载和按钮点击触发用户控件中相应事件，实际工程常结合数据库）。 4. 小结 外观文件统一服务器控件外观，主题存于App_Themes文件夹对应主题文件夹，母版页建立统一风格网站，用户控件统一页面局部风格，基于Web部件网站可实现用户个性化设置。 第11章网站导航知识点总结 1. 网站地图 1.1网站地图文件 用于描述网站页面层次结构，是XML文件，\u0026lt;siteMapNode\u0026gt;元素描述页面标题、URL等信息，其中一个网站地图文件须存于根文件夹下名为Web.sitemap，其他可放其他位置，\u0026lt;siteMapNode\u0026gt;元素有description（超链接提示）、roles（可访问角色）、securityTrimmingEnabled（是否支持安全特性）、siteMapFile（引用其他地图文件）、title（显示文本）、url（目标页URL）等属性，如创建网站地图实例。 1.2嵌套网站地图文件 可将页面结构分散到多个.sitemap文件再合并到根文件夹下Web.sitemap文件，合并用\u0026lt;siteMapNode\u0026gt;元素的siteMapFile属性，如创建嵌套网站地图实例（功能同简单网站地图但结构不同）。 2. SiteMapPath控件显示导航 实现面包屑导航（显示当前页面在网站层次结构位置），自动绑定Web.sitemap，无需数据源控件，常用属性有ParentLevelsDisplayed（父节点级别数）、PathDirection（导航路径呈现顺序）、PathSeparator（导航路径分隔符）、PathSeparatorTemplate（导航路径分隔模板），如利用该控件显示导航实例（可将其添加到母版页统一导航界面）。 3. TreeView控件显示导航 3.1TreeView控件 以树形结构显示分层数据，可用于网站导航、显示XML等数据，节点分为根、父、子、叶节点，每个节点是TreeNode对象，有CheckedNodes（选中复选框节点集合）、CollapseImageUrl（节点折叠显示图片URL）、EnableClientScript（是否允许客户端处理展开折叠事件）、ExpandDepth（首次显示展开级数）、ExpandImageUrl（节点展开显示图片URL）、Nodes（根节点集合）、NoExpandImageUrl（不可折叠节点图片URL）、PathSeparator（节点路径分隔符）、SelectedNode（当前选中节点）、SelectedValue（当前选中节点值）、ShowCheckBoxes（是否显示复选框）、ShowLines（是否显示连接线）等属性，TreeNode类有ChildNodes（子节点集合）、ImageUrl（节点旁图片URL）、NavigateUrl（单击节点导航URL）、Parent（父节点）等属性，节点数据可在设计时或编程动态添加修改，也可绑定数据源，有CollapseAll（折叠节点）、ExpandAll（展开节点）、Nodes.Add（添加节点）、Nodes.Remove（删除节点）等方法，如运用TreeView控件显示城市结构并操作节点实例。 3.2使用TreeView控件实现导航 数据填充方式有两种，一是用数据源控件SiteMapDataSource（设置TreeView控件DataSourceID为其ID），二是用LINQ技术，如利用TreeView控件显示导航实例（用SiteMapDataSource绑定Web.sitemap显示网页结构）。 4. Menu控件显示导航 以菜单形式显示分层数据，需数据源控件支持，Orientation属性确定排列方式（Vertical竖向，Horizontal横向，默认Vertical），如利用Menu控件显示导航菜单实例。 5. 母版页中使用网站导航 步骤为创建导航母版页、添加导航控件、创建内容页并关联母版页，如实现基于母版页的网站导航实例（母版页实现导航，内容页关联并显示提示信息）。 6. 小结 ASP.NET导航系统核心是用XML网站地图文件描述页面结构，SiteMapPath实现面包屑导航且无需数据源，TreeView以树形结构显示需数据源，Menu以菜单形式显示需数据源。 第12章ASP.NET Ajax知识点总结 1. Ajax基础 1.1Ajax概述 允许客户端异步与服务器交换数据，构建交互性Web应用程序，Ajax页面无刷新，依赖XMLHttpRequest对象（IE 5.0以上通过MSXML ActiveX组件使用）、JavaScript代码、DHTML（动态更新表单）和文档对象模型DOM（处理HTML和XML），如对比传统与Ajax Web应用程序差异。 1.2ASP.NET Ajax技术 专用于ASP.NET页面，实现局部页刷新，自动生成代理类，支持主流浏览器，页面处理多在浏览器，有“仅客户端”（使用ASP.NET Ajax Library）和“客户端与服务器”（同时使用库和服务器控件）解决方案。 2. ASP.NET Ajax服务器控件 2.1ScriptManager控件 是ASP.NET Ajax核心，管理页面Ajax资源，每个Ajax页面必须添加，EnablePartialRendering属性确定能否局部刷新，可在Scripts属性集合注册自定义JavaScript脚本，母版页使用时在母版页添加（内容页可添加ScriptManagerProxy控件）且只允许一个。 2.2UpdatePanel控件 容器控件，内部控件可局部刷新，可放多个，内容放\u0026lt;ContentTemplate\u0026gt;子元素，通过\u0026lt;Triggers\u0026gt;元素内\u0026lt;asp:AsyncPostBackTrigger\u0026gt;元素定义触发器，如内部按钮刷新（默认内部回发控件导致异步回发刷新内容）、外部按钮刷新（避免不必要数据回送，将触发控件放外部并设触发器）、多个UpdatePanel控件使用（UpdateMode属性控制刷新条件，注意属性值设置限制）实例。 2.3Timer控件 按间隔执行同步或异步回发，用于定期刷新UpdatePanel内容，Interval属性定义间隔，Tick事件触发，Enabled属性启用禁用，可多个或关联多个UpdatePanel，如定时刷新汇率及时间实例（根据用户选择设置Timer属性控制刷新频率）。 2.4UpdateProgress控件 设计直观UI显示任务完成情况，可放多个并通过AssociatedUpdatePanelID属性关联单个UpdatePanel，如单击按钮显示局部刷新进度条实例（模拟服务器延迟操作）。 3. AjaxControlToolkit程序包 基于ASP.NET Ajax框架的开源项目，用NuGet安装，提供多种扩展Ajax控件工具集，如Accordion（可折叠面板）、AjaxFileUpload（文件上传）、AlwaysVisibleControlExtender（悬浮控件）等，如运用CalendarExtender（实现日期输入，设置TargetControlID关联文本框、Format设置日期格式）和PasswordStrength（检测密码强度，可设置提示方式、强度信息、进度条样式等属性）控件实例。 4. 小结 ScriptManager是ASP.NET Ajax核心，UpdatePanel定义局部刷新区域，UpdateProgress显示局部刷新状态，Timer定时回发，AjaxControlToolkit扩展服务器控件功能。 第13章Web服务和WCF服务知识点总结 1. Web服务 1.1Web服务概述 可使Web应用程序共享和使用其他应用程序生成的数据（返回数据而非页面），实现软件重用。网络通信基于HTTP等协议，消息处理用SOAP，需WSDL和UDDI支持。 1.2建立ASP.NET Web服务 实质是在支持SOAP通信类中创建方法，创建.asmx服务文件声明Web服务，在App_Code文件夹建类文件定义方法，如创建含HelloWorld方法的Web服务（需注意命名空间、规范声明及方法前加[WebMethod]）。 1.3调用ASP.NET Web服务 可用于多种应用程序，若被Microsoft Ajax调用需声明[System.Web.Script.Services.ScriptService]，使用时以“服务引用”添加到网站，创建实例调用，如测试Web服务实例（点击按钮调用服务方法并显示结果）、运用AutoCompleteExtender控件调用Web服务实现文本框自动补全功能实例（服务被Ajax控件调用需声明相关属性）。 2. WCF服务 2.1WCF服务概述 为服务提供运行时环境，是面向服务的应用程序新框架，用于开发分布式系统，支持多种通信协议，基于.NET Framework 3.0构建（.NET Framework 4.5中相关特性），包含于System.ServiceModel.dll，命名空间为System.ServiceModel。 2.2建立WCF服务 需建立服务接口文件和逻辑处理文件，有WCF服务网站模板和WCF服务模板，如建立整数加减运算WCF服务实例（涉及服务契约定义，包括[ServiceContract]用于类或结构可远程调用，[OperationContract]用于方法可远程调用，还有数据、异常、消息契约）。 2.3调用WCF服务 通过添加服务引用在其他应用程序中调用，如调用整数加减运算WCF服务实例（建立服务对象实例，点击按钮调用相应方法计算并显示结果，使用后需关闭，可再次打开）。 3. 小结 Web服务实现数据和软件重用，方便构建分布式系统，VSC 2017模板便于建立和调用ASP.NET Web服务；WCF服务是面向服务框架，用于开发分布式系统，建立时需多种文件，有特定模板。 第14章文件处理知识点总结 1. 驱动器、文件夹和文件操作 1.1获取驱动器信息 使用DriveInfo类获取Web服务器驱动器信息，需导入System.IO命名空间，其属性（如AvailableFreeSpace、DriveFormat等）和方法（如GetDrives）可获取驱动器各种属性和所有逻辑驱动器名称，如显示所有驱动器信息实例（遍历驱动器集合添加到TreeView控件）。 1.2文件夹操作 用Directory和DirectoryInfo类操作文件夹，Directory类方法静态（可直接调用且安全检查），DirectoryInfo类方法实例化后使用，Path类提供路径操作方法（如合并、获取文件名等）。Directory类方法包括创建、删除、判断存在、获取子文件夹和文件等；DirectoryInfo类类似且有移动、获取原始路径等方法；Path类有更改扩展、合并路径等方法，如计算文件夹大小实例（递归计算文件和子文件夹大小并构建目录树显示）。 1.3文件操作 File和FileInfo类提供文件操作方法，File类方法静态，FileInfo类方法实例化后使用。File类方法涵盖创建、复制、删除、移动、打开、读写、获取时间等操作；FileInfo类类似且有追加文本、获取字符串路径等方法，如文件创建、复制、删除和移动操作实例（根据输入路径操作文件并提示信息，可获取文件创建时间和大小）。 2. 读写文件 2.1Stream类 读写数据用数据流形式，Stream类抽象，FileStream类用于文件操作，有CanRead、CanWrite等属性（判断数据流读写支持和长度等）和BeginRead、BeginWrite等方法（异步读写、关闭、刷新、读写字节等操作），异步写文件需用Lock和UnLock解决冲突，使用后用Close关闭或用using确保关闭，如利用FileStream类读写文件实例（判断文件存在与否进行读写操作，注意编码方式避免中文乱码）。 2.2Reader和Writer类 完成数据流字节读写，包括BinaryReader、StreamReader等多种类型，TextReader和TextWriter为抽象类用于读写文本内容（有Close、Peek、Read等方法），如利用StreamReader和StreamWriter读写文本文件实例（根据按钮点击读写文件，可设置写入模式）、利用BinaryReader和BinaryWriter读写二进制数据文件实例（注意写入和读取数据类型对应方法）。 3. 文件上传 FileUpload控件实现文件上传，PostedFile属性获取上传文件HttpPostedFile对象（可获取文件长度、类型、名称等属性），SaveAs方法保存文件到Web服务器，如利用FileUpload实现文件上传实例（选择文件上传到指定文件夹，限制文件大小和扩展名）。 4. 小结 System.IO命名空间下DriveInfo等类实现Web服务器文件夹和文件操作，基于Stream类和Reader/Writer类实现读写通用模型，FileUpload控件用于上传文件。 第15章MyPetShop综合实例知识点总结 1. 系统总体设计和开发思路 1.1系统功能模块设计 包含前台商品浏览、用户注册登录、购物车、订单结算模块和后台管理模块，各模块有不同功能（如前台商品浏览展示商品，后台管理模块进行商品分类、供应商、商品、订单管理等）。 1.2用户控件设计 包括AutoShow（热销商品自动定时刷新）、Category（商品分类显示）、NewProduct（最新商品显示）、PetTree（商品分类及导航）、SiteMap（网站导航）、UserStatus（显示用户登录状态）、Weather（天气预报）等用户控件。 1.3系统数据库总体设计 用SQL Server 2016 Express LocalDB开发，MyPetShop.mdf数据库含七个表（CartItem、Category、Customer、Order、OrderItem、Product、Supplier）存储相关信息。 1.4Web.config配置文件 配置文件用于项目相关设置（具体内容未详细展开）。 1.5基于VSC 2017开发总体思路 使用LINQ技术和ASP.NET三层架构，包括新建解决方案及各层项目、添加引用、复制相关文件夹、安装AjaxControlToolkit、建立数据库和各类文件、进行页面设计、生成网站并测试等一系列步骤。 2. MyPetShop.mdf数据库设计 2.1数据表设计 详细设计购物车详细信息、商品分类信息、用户信息、订单信息、订单详细信息、商品信息、供应商信息等表结构，各表包含不同字段存储相应信息。 2.2数据表联系设计 各数据表通过特定字段建立联系，如Customer表与Order表通过CustomerId关联，共同构成完整数据关系。 3. 用户控件设计 具体介绍各用户控件功能及界面呈现效果，如“热销商品自动定时刷新”用户控件定时切换展示商品，“商品分类列表”用户控件展示分类及商品数量等。 4. 前台显示页面设计 4.1母版页 应用ASP.NET Ajax技术和Bootstrap框架样式表，添加用户控件和Web部件，实现商品搜索功能，统一网站布局和风格。 4.2首页 使用ASP.NET Ajax技术，添加多个自定义用户控件（如热销、最新商品列表等），展示各类信息，提供多种功能入口（注册、登录、购物车等）。 4.3商品详细信息页面 展示商品详细信息（编号、分类、名称、价格、描述、库存等），方便用户了解商品详情。 4.4商品搜索页面 用户可输入关键词搜索商品，展示搜索结果（商品名称、价格、分类等），方便用户查找所需商品。 5. 用户注册和登录模块 5.1注册新用户 用户输入用户名、Email、密码等信息注册，系统检查信息合法性（如必填、格式、密码一致性等），注册成功或失败有相应提示，成功后可登录或进行其他操作。 5.2用户登录 用户输入用户名和密码登录，验证通过进入系统，失败显示错误提示，可进行注册、找回密码等操作。 5.3修改用户密码 已登录用户输入原密码、新密码和确认新密码修改密码，原密码正确且新密码符合要求则修改成功，否则提示错误。 5.4找回用户密码 用户输入用户名和Email，系统验证后将密码重置并发送到邮箱，用户可通过邮箱获取新密码登录。 5.5退出系统 由“用户状态”用户控件实现，登录用户点击“退出登录”链接注销用户，系统清除相关登录状态信息。 6. 购物车模块 6.1购物车组件设计与实现 采用数据库存储购物车内容，按用户编号区分，用户登录后可操作购物车，实现购物车功能的数据存储和管理基础。 6.2购物车页面设计 页面展示购物车商品信息（名称、价格、数量等），提供总价计算、删除商品、清空购物车、结算和重新计算等功能操作入口。 6.3购物车功能设计与实现 包括添加商品（用户在商品页面点击按钮将商品加入购物车，可修改数量）、删除商品（选中复选框点击按钮删除）、修改数量（更改后点击重新计算更新总价）、清空购物车（点击按钮删除所有商品记录）、结算（点击按钮重定向到结算页面，实际需关联电子支付等）。 7. 订单处理 7.1创建订单 登录用户在购物车点击结算进入创建订单页面，填写发货和发票寄送地址、联系电话等信息后提交结算，订单信息存储到数据库。 7.2查看订单 登录用户可查看自己订单详细信息（订单号、用户号、用户名、订单时间、地址、状态等），方便用户跟踪订单状态。 8. 后台管理模块 8.1商品分类管理 管理员登录后可对商品分类进行编辑（修改分类名称、描述等）、删除和新建操作，页面展示分类名称、描述及操作按钮。 8.2供应商信息管理 管理员可编辑（修改供应商名称、地址、联系方式等）、删除和新建供应商信息，页面展示供应商详细信息及操作按钮。 8.3商品信息管理 管理员可添加（输入商品名称、分类、价格、成本、库存、描述、图片等信息）、修改（修改商品各项信息）和删除商品（选中复选框点击按钮删除），页面展示商品列表及操作按钮。 8.4订单管理 管理员查看订单详细信息（订单ID、用户、审核状态等），可审核订单（点击按钮更改审核状态），页面展示订单相关信息及操作按钮。 9. 小结 MyPetShop综合实例开发涵盖系统总体设计、数据库、用户控件、前台后台页面及各功能模块设计，基于VSC 2017和ASP.NET三层架构，是学习Web应用程序开发的良好模板，有助于理解设计思想和掌握开发方法。 ","date":"2024-12-19T00:00:00Z","image":"https://Nanmur.github.io/p/asp/Weblogo_hu2003850207557139744.png","permalink":"https://Nanmur.github.io/p/asp/","title":"Web ASP网页程序设计笔记"},{"content":"Ngrok简述 Ngrok 是一个反向代理工具，它能够让运行在本地开发环境中的 Web 应用程序通过安全通道暴露在互联网上。简单来说，它可以把你本地计算机（比如localhost）上运行的服务，如 Web 服务器、API 等，映射到一个公共的互联网 URL，使得外部网络（如互联网上的其他设备）能够访问你本地的服务。 Ngrok 在本地机器和公共互联网之间建立一个隧道。当外部请求发送到 ngrok 分配的公共 URL 时，ngrok 会将这些请求转发到本地开发环境中运行的相应服务。例如，你在本地运行了一个 Web 应用，监听在http://localhost:3000 端口，通过 ngrok 可以生成一个类似https://your - ngrok - subdomain.ngrok.io的公共 URL。当用户在浏览器中访问这个公共 URL 时，ngrok 会把请求转发到本地的http://localhost:3000，然后将本地服务返回的响应再转发回用户的浏览器。 Ngrok 提供了一定程度的安全性，它可以通过配置使用安全的 HTTPS 连接。不过，在使用过程中也需要注意保护本地服务的安全。因为一旦通过 ngrok 将本地服务暴露在互联网上，如果本地服务本身存在安全漏洞，就有可能被恶意利用。同时，ngrok 免费版本有一定的限制，如流量限制、连接数限制等，对于商业或高负载应用可能需要考虑付费版本来满足需求。\n安装与配置(只需进行一次) 首先进入Ngrok官网注册账号，下载并安装适合你操作系统的 Ngrok 软件。安装完成后，需要进行注册并获取认证令牌（authtoken）。 打开Ngrok的下载路径，在当前下载路径下cmd进入命令行窗口。输入ngrok authtoken \u0026lt;YOUR_AUTHTOKEN\u0026gt;命令并运行，将你在 Ngrok 官网获取的认证令牌替换\u0026lt;YOUR_AUTHTOKEN\u0026gt;部分，这样就完成了 Ngrok 的基本配置。 启动并监听 在Ngrok官网下进入左侧边栏中的Setup\u0026amp;Installation页面,下滑找到Deploy your app online，选择Static Domain模式,即获取一个永久的静态地址，以后每次启动只需要对这个地址进行挂载即可。 复制Static Domain下的ngrok http --url=above-cat-presumably.ngrok-free.app 80命令，注意将之后的数字 80 改为数据库正在运行的端口号 xxx。这会创建一个 TCP 隧道，将本地的 xxx 端口（MySQL 服务端口）通过 Ngrok 穿刺连接到互联网上。 配置数据库连接客户端 你要从外部连接本地 MySQL 数据库时，需要使用 Ngrok 分配的公共 TCP 地址。在数据库连接配置中，将主机地址（Host）更改为 Ngrok 分配的公共地址（即上步中的静态地址），端口号更改为 Ngrok 监听的端口。 保持用户名和密码以及其他数据库连接相关的设置（如数据库名称、字符集等）不变。 通过客户端下的环境，选择合适变成语言进行连接。例如，如果你是使用 Python 的mysql - connector - python库来连接 MySQL 数据库，原来的连接代码可能是： 1 2 3 4 5 6 7 8 import mysql.connector mydb = mysql.connector.connect( host=\u0026#34;0.tcp.ngrok.io\u0026#34;, # 替换为Ngrok分配的主机地址 port=12345, # 替换为Ngrok分配的端口号 user=\u0026#34;your_username\u0026#34;, password=\u0026#34;your_password\u0026#34;, database=\u0026#34;your_database_name\u0026#34; ) js下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 const mysql = require(\u0026#39;mysql\u0026#39;); const connection = mysql.createConnection({ host: \u0026#39;0.tcp.ngrok.io\u0026#39;, // 使用Ngrok分配的主机地址 port: 12345, // 使用Ngrok分配的端口号 user: \u0026#39;your_username\u0026#39;, password: \u0026#39;your_password\u0026#39;, database: \u0026#39;your_database_name\u0026#39; }); connection.connect((err) =\u0026gt; { if (err) { console.error(\u0026#39;数据库连接错误: \u0026#39;, err); } else { console.log(\u0026#39;成功连接到数据库\u0026#39;); // 在这里可以执行数据库操作，如查询、插入等 const sql = \u0026#39;SELECT * FROM your_table\u0026#39;; connection.query(sql, (queryErr, results) =\u0026gt; { if (queryErr) { console.error(\u0026#39;查询错误: \u0026#39;, queryErr); } else { console.log(\u0026#39;查询结果: \u0026#39;, results); } connection.end(); }); } }); ","date":"2024-12-16T00:00:00Z","image":"https://Nanmur.github.io/p/ngrok/Ngroklogo_hu3594407745994625412.png","permalink":"https://Nanmur.github.io/p/ngrok/","title":"Ngrok内网穿透连接本地Mysql数据库"},{"content":"一、创建版本库 1.配置git环境 在git安装好以后，需要配置环境变量，命令行中输入以下命令： git config --global user.name \u0026quot;Your Name\u0026quot; git config \u0026ndash;global user.email \u0026ldquo;email@example.com\u0026rdquo; git config --list：查看当前的git配置；\n配置好环境后，使用git init，即可将当前目录变成一个git可以管理的仓库；\ngit顺序：工作区 \u0026ndash;\u0026gt; add \u0026ndash;\u0026gt; 暂存区 \u0026ndash;\u0026gt; commit \u0026ndash;\u0026gt; 版本库 \u0026ndash;\u0026gt; push \u0026ndash;\u0026gt; 远程版本库。\n2.时光机穿梭 1.版本回退 git status：查看仓库的当前状态； git diff：查看上次修改的内容； git log：显示所有提交日志，可以增加--pretty=oneline参数减少输出，可以使用--graph --pretty=oneline --abbrev-commit参数使输出更加直观； git reset --hard HEAD^：回退到上一版本，在git中，HEAD表示当前版本，HEAD^表示上一版本，HEAD^^表示上上个版本，HEAD~10表示往前第10个版本； git reset --hard \u0026lt;commit_id\u0026gt;：回退到指定的commit_id版本，commit_id可以不用输完整，输前几位就能找到； git reflog：查看历史命令，可以用来找回commit_id。\n二、撤销修改 git restore \u0026lt;file_name\u0026gt;：撤销对文件的修改（工作区）； git restore --staged \u0026lt;file_name\u0026gt;：撤销已经git add放到暂存区的文件； git reset --hard HEAD：撤销已经git commit到版本库的修改，即回退到上一版本。--hard表示之前的修改直接丢掉，--mixed(default)表示之前的修改保留在工作区，--soft表示之前的修改保留在暂存区。\n三、删除文件 git rm \u0026lt;file_name\u0026gt;：删除版本库中的文件，需要再使用git commit提交删除到版本库； 若删除了工作区的文件，想从版本库中恢复到工作区，可以使用git restore \u0026lt;file_name\u0026gt;；\n四、分支管理 1.创建与合并分支 git checkout -b dev：-b参数表示创建并切换到dev分支，该命令同git switch -c dev； git merge dev：合并dev分支到当前分支； git merge --no-ff dev：合并但禁用快速合并（推荐），因为dev分支上可能会有很多零碎的提交，这种方式能够避免搅乱master的分支提交历史； git branch -d dev：删除dev分支，参数-D表示强制删除，用来删除还未合并的分支。\n2.解决冲突 若合并时存在冲突，使用git status查看冲突文件； 然后手动编辑文件解决冲突。\n五、Bug分支 修复Bug时，通常我们会创建新的Bug分支进行修复，然后合并，最后删除； 当手头工作没有完成，需要先把工作现场git stash储藏起来，改完Bug后再用git stash pop还原工作现场，可以使用git stash list查看储藏列表； 在master分支上修复的Bug，可以通过git cherry-pick \u0026lt;commit_id\u0026gt;复制到当前分支。\n六、多人协作 git remote -v：查看远程分支详细信息； git push origin \u0026lt;branch_name\u0026gt;：推送到远程指定的分支上； git checkout -b dev origin/dev：创建远程的dev分支到本地； git pull：从远程获取最新版本并merge到本地，自动合并或修改当前的工作； git fetch：从远程拉取到本地仓库，不会自动合并或修改当前的工作； git --set-upstream-to=origin/dev dev：设置dev分支与远程origin/dev分支的链接，链接完成后，在dev分支中git pull就会直接从origin/dev上拉取了。\n在dev分支上执行git rebase master：若此时master上有新的提交，则用master上的新提交来作为dev的新基底，若master上没有提交，则类似于进行了merge操作。一般公司里会禁用rebase，统一使用merge，因为rebase会整合分支提交记录，不清楚主线上谁合了代码以及他们合代码的先后顺序。\n注意：总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作。\n","date":"2024-12-14T00:00:00Z","image":"https://Nanmur.github.io/p/git/Gitlogo_hu2783557759348303388.png","permalink":"https://Nanmur.github.io/p/git/","title":"Git入门"},{"content":"1.前缀和差分 输入输出 scanf 和 printf 优点：格式化输入、输出 %.nlf可以保留n位输出浮点数（一般竞赛中只用double 因为float能做的double都能做）\ncin 和 cout 优点：简洁，在取消同步流的情况下一般比scanf更快 取消同步流（一定要把三个语句写完整）：\n1 ios:: sync_with_stdio(0),cin.tie(0),cout.tie(0); 当取消了同步流之后，应该避免使用 endl，因为它会导致缓冲区立即刷新，引起不必要的系统调用，降低程序的执行效率。相反，推荐使用 \u0026lsquo;\\n\u0026rsquo; 来替代 endl，它只插入一个换行符，不会刷新缓冲区\n推荐写法： 1.确定数组N的大小，用const int不要用define 2.建议开全局数组。注意，全局的数组自动初始化为0。函数里面的数组使用的是栈空间（很小），且不会初始化。 3.输入要单独做，如果开循环的话，只在循环里做输入或输出，其他的操作不要在这个循环内做。\n前缀和数组 前缀和数组是一种在算法中常用的数据结构，用于存储一个序列（通常是数组）的前缀（即从开始到当前位置的所有元素的和）。这种数据结构可以快速地计算某个序列的任何一段区间的和，而不需要重复计算。\n其实这种思想不一定非要是前缀和，前缀积，前缀异或都可以，只要是满足可加性的运算都可以使用 前缀和数组在算法中非常有用，尤其是在处理区间和、连续子数组和等问题时。它可以将时间复杂度从 O(n^2) 降低到 O(n)。 其递推式为：prefix[i] = p[i-1] - a[i] 伪代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Input: nums[] (数组) Output: prefix_sum[] (前缀和数组) 1. 初始化: prefix_sum[0] = 0 2. 计算前缀和: for i = 1 to len(nums): prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1] 3. 查询任意区间 [l, r] 的和: function range_sum(l, r): return prefix_sum[r + 1] - prefix_sum[l] 4. 示例: range_sum(1, 3) 表示 nums[1] + nums[2] + nums[3] 1 2 3 4 5 using ll = long long; const N = 1e5 + 9; ll a[N],prefix[N];//a用来存最初的数组，prefix即是前缀和数组 for(int i = 1; i \u0026lt;= n;++i)cin \u0026gt;\u0026gt; a[i]; for(int i = 1; i \u0026lt;= n;++i)prefix[i] = prefix[i - 1] + a[i];//利用前缀和数组的可加性 简便计算 二维前缀和 二维前缀和是一种用于快速计算二维数组中任意子矩阵区域和的数据结构。它通过构建一个与原矩阵大小相同的二维前缀和数组来实现，其中每个元素存储了原数组中从左上角起点 (0, 0) 到当前位置 (i, j) 的子矩阵区域内所有元素的和。 其递推式为：prefix[i][j] = prefix[i-1][j] + prefix[i][j-1] +a[i][j]-p[i-1][j-1] 伪代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 Input: matrix[n][m] (二维矩阵) Output: prefix_sum[n+1][m+1] (二维前缀和数组) 1. 初始化: 创建一个大小为 (n+1) x (m+1) 的二维数组 prefix_sum，所有元素初始化为 0 2. 计算二维前缀和: for i = 1 to n: for j = 1 to m: prefix_sum[i][j] = matrix[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1] 3. 查询任意子矩阵和: function range_sum(x1, y1, x2, y2): # 矩阵区域 [(x1, y1), (x2, y2)]，注意这里是1-based下标 return prefix_sum[x2][y2] - prefix_sum[x1-1][y2] - prefix_sum[x2][y1-1] + prefix_sum[x1-1][y1-1] 4. 示例: 输入: 矩阵 [[1, 2], [3, 4]] prefix_sum: [[0, 0, 0], [0, 1, 3], [0, 4, 10]] range_sum(1, 1, 2, 2) = 10 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 using ll = long long; const N = 1e5 + 9; ll a[N],prefix[N]; int n,m,q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q; for(int i = 1; i \u0026lt;= n; ++i) { for(int j = 1; j \u0026lt;= m; ++j) { cin \u0026gt;\u0026gt; a[i][j]; } } for(int i = 1; i \u0026lt;= n; ++i) { for(int j = 1; j \u0026lt;= m; ++j) { prefix[i][j] = prefix[i-1][j] + prefix[i][j-1] +a[i][j]-p[i-1][j-1]//至此已经构造出二维前缀和数组 } } while(q--) { int x1,y1,x2,y2; cin \u0026gt;\u0026gt; x1 \u0026gt;\u0026gt; y1 \u0026gt;\u0026gt; x2 \u0026gt;\u0026gt; y2; int area; area = prefix[x2][y2] - prefix[x2][y1-1] -prefix[x1-1][y2] + prefix[x1-1][y1-1]; } 差分数组 差分数组是一种处理序列动态修改问题的数据结构，它通过记录每个元素与其前一个元素的差值来表示原始数组的变化。这种数据结构的主要用途是简化对原数组的频繁更新和查询操作，从而提高算法效率。 差分数组的主要优点是能够高效地处理大量区间修改操作。通过修改差分数组，可以间接实现原数组的区间修改，而不需要直接操作原数组，从而极大地提高了算法效率。 其递推式为：diff[i] = a[i] - a[i-1] 伪代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Input: nums[] (原数组) Output: diff[] (差分数组) 1. 初始化差分数组: diff[0] = nums[0] for i = 1 to len(nums) - 1: diff[i] = nums[i] - nums[i-1] 2. 区间修改: function update_range(l, r, val): diff[l] += val if r + 1 \u0026lt; len(diff): diff[r + 1] -= val 3. 计算修改后的数组: for i = 1 to len(nums) - 1: nums[i] = nums[i - 1] + diff[i] 4. 示例: 初始数组: nums = [0, 0, 0, 0, 0] 修改区间 [1, 3], 增加值 2: diff = [0, 2, 0, 0, -2] nums = [0, 2, 2, 2, 0] 1 2 3 4 5 using ll = long long; const N = 1e5 + 9; ll a[N],diff[N],prefix[N];//a用来存最初的数组，prefix即是前缀和数组,diff即是差分数组 for(int i = 1; i \u0026lt;= n;++i)cin \u0026gt;\u0026gt; a[i]; for(int i = 1; i \u0026lt;= n;++i)diff[i] = a[i] - a[i-1]; 二维差分数组 二维差分数组是一种用于处理二维数组中区间更新的数据结构。它通过记录每个元素与其相邻元素（左、上、右、下）的差值来表示原始数组的变化。这种数据结构的主要用途是简化对原数组的频繁更新操作，从而提高算法效率。 二维差分数组 diff 由原数组 arr 衍生而来，其中 diff[i][j] 表示原数组中元素 arr[i][j] 与其左侧元素 arr[i][j-1]、上侧元素 arr[i-1][j] 的差值。 具体来说： diff[i][j] = arr[i][j] - arr[i][j-1]（如果 j \u0026gt; 0） diff[i][j] = arr[i][j] - arr[i-1][j]（如果 i \u0026gt; 0） 这样，原数组中任意位置 (i, j) 的值可以通过累加前面所有差分值来恢复： arr[i][j] = diff[i][j] + arr[i][j-1]（如果 j \u0026gt; 0） arr[i][j] = diff[i][j] + arr[i-1][j]（如果 i \u0026gt; 0） 伪代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Input: matrix[n][m] (二维矩阵) Output: diff[n+1][m+1] (二维差分数组) 1. 初始化差分数组: 创建大小为 (n+1) x (m+1) 的二维数组 diff，所有元素初始化为 0 2. 区域修改: function update_range(x1, y1, x2, y2, val): diff[x1][y1] += val diff[x1][y2+1] -= val diff[x2+1][y1] -= val diff[x2+1][y2+1] += val 3. 计算修改后的矩阵: for i = 1 to n: for j = 1 to m: diff[i][j] += diff[i-1][j] + diff[i][j-1] - diff[i-1][j-1] matrix[i-1][j-1] = diff[i][j] 4. 示例: 初始矩阵: [[0, 0], [0, 0]] 修改区域 [(1, 1), (2, 2)], 增加值 2: diff: [[2, -2], [-2, 2]] 结果矩阵: [[2, 2], [2, 2]] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 using ll = long long; const N = 1e5 + 9; ll a[N],diff[N],prefix[N]; int n,m,q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q; for(int i = 1; i \u0026lt;= n; ++i) { for(int j = 1; j \u0026lt;= m; ++j) { cin \u0026gt;\u0026gt; a[i][j]; } } for(int i = 1; i \u0026lt;= n; ++i) { for(int j = 1; j \u0026lt;= m; ++j) { d[i][j] += a[i][j]; d[i+1][j] -= a[i][j]; d[i][j+1] -= a[i][j]; d[i+1][j+1] += a[i][j]; }//至此已经构建出二维差分数组 } while(q--) { int x1,y1,x2,y2,v; cin \u0026gt;\u0026gt; x1 \u0026gt;\u0026gt; y1 \u0026gt;\u0026gt;x2 \u0026gt;\u0026gt; y2 \u0026gt;\u0026gt; v; d[x1][y1] += v; d[x1][y2+1] -= v; d[x2+1][y1] -= v; d[x2+1][y2+1] += v; } for(int i = 1; i \u0026lt;= n; ++i) { for(int j = 1; j \u0026lt;= m; ++j) { a[i][j] = a[i-1][j] + a[i][j-1] -a[i-1][j-1] +d[i][j]; prefix[i][j] = p[i-1][j] + p[i][j-1] -p[i-1][j-1] +a[i][j]; } } while(q--) { int x1,y1,x2,y2; cin \u0026gt;\u0026gt; x1 \u0026gt;\u0026gt; y1 \u0026gt;\u0026gt; x2 \u0026gt;\u0026gt; y2; int area; area = prefix[x2][y2] - prefix[x2][y1-1] -prefix[x1-1][y2] + prefix[x1-1][y1-1]; } eg： 题目描述：在一个叫做酱西功爷枝叶鸡树学院的地方有 ( n ) 只小动物，要么是鼠鼠，要么是鸭鸭，从1到 ( n ) 编号，每只小动物有个体重 ( a_i )。在这个学校里，存在一种神奇的魔法，可以将编号位于某个区间 ([l, r]) 内的所有鼠鼠都变为鸭鸭，鸭鸭都变为鼠鼠（魔法并不会改变体重）。现在你可以施放这个魔法至多1次。（也可以不施放）问最终鸭鸭的总重量最多是多少？ 输入格式：第一行一个整数 ( T ) 表示样例个数。 ( (1 \\leq T \\leq 10) )对于每个样例:第一行一个整数 ( n ) 表示小动物的个数。 ( \\left(1 \\leq n \\leq 10^5\\right) )第二行 ( n ) 个整数，表示第 ( i ) 个小动物的类型。 0 表示鼠鼠， 1 表示鸭鸭。第三行 ( n ) 个整数，表示第 ( i ) 个小动物的体重 ( a_i )。 ( \\left(1 \\leq a_i \\leq 10^9\\right) ) 输出格式：对于每个样例一行一个整数表示答案。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e5 + 9; ll a[N], w[N], prefix[N]; // 分别存原动物类型、重量、和前缀和数组 void solve() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; w[i]; for (int i = 1; i \u0026lt;= n; ++i) { prefix[i] = prefix[i - 1] + ((a[i] == 1) ? -1 : 1) * w[i]; // 看a[i] 如果原来是鼠(0)，变完就是鸭子(1)，结果会相较于基础结果加上w[i]；反之减少w[i]。 } ll ess = 0; // 基础结果 for (int i = 1; i \u0026lt;= n; ++i) ess += w[i] * a[i]; ll mi = 0, Fix = 0; // mi表示 min(prefix[j]) 0 \u0026lt;= j \u0026lt; i for (int i = 1; i \u0026lt;= n; ++i) { Fix = max(Fix, prefix[i] - mi); mi = min(mi, prefix[i]); } cout \u0026lt;\u0026lt; ess + Fix \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _; cin \u0026gt;\u0026gt; _; while (_--) solve(); return 0; } 2.位运算、双指针、排序二分 位运算（都建立在二进制的基础上） 与运算 \u0026amp; a + b = 2(a \u0026amp; b) + (a ^ b)\n或运算 | 非运算 ! 异或运算 ^ 当 0 \u0026lt; a, b 时，有 a + b \u0026gt;= a ^ b 结合律： a ^ (b ^ c) = (a ^ b) ^ c 交换律： a ^ b = b ^ a 没有分配律 a ^ a = 0 a ^ 0 = a\neg:题目描述：给定两个正整数 ( a, b )，你可以写出一些非负整数数组，使得该数组的 MEX 和 XOR 值分别为 ( a ) 和 ( b )。你需要求出满足条件的非负整数数组的最小长度。 **提示:**MEX 值是指：最小的不存在于该数组之中的非负整数。例如，数组 ( (0,3,2,2) ) 的 MEX 值为 1。XOR 值是指：数组中的所有元素做异或运算的结果。例如，数组 ( (3,5,5) ) 的 XOR 值为 ( 3 \\oplus 5 \\oplus 5 = 3 )。 输入描述：第一行：一个整数 ( t )，表示测试用例的数量。 ( \\left(1 \\leq t \\leq 10^5\\right) ) 接下来 ( t ) 行，每行两个整数 ( a, b )。 ( \\left(1 \\leq a \\leq 2 \\times 10^5, 0 \\leq b \\leq 2 \\times 10^5\\right) ) 输出描述：共 ( t ) 行：第 ( i ) 行为第 ( i ) 个测试用例的答案。 整数a一定可以由b和c通过异或构造出来 （b，c \u0026gt; a）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2e5 + 9; int prexor[N];//构造异或前缀和 防止时间超限 void solve() { int a,b;cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; int y = prexor[a - 1] ^ b; //y是使XOR=b的那个缺少的值（除了0~a-1之外） if(y == a) cout \u0026lt;\u0026lt; a + 2 \u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; //缺少a 则需要两个比a大的数字来构造出a 所以最小 a+2 else if(y == 0) cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; //缺少0 0已经包含在0~a-1内 所以最小数字集合就是a else cout \u0026lt;\u0026lt; a + 1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; //其余情况 只要在0~a-1加上这个数字就行 所以 a+1 } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); for(int i = 1; i \u0026lt;= 2e5; ++i) prexor[i] = prexor[i - 1] ^ i; int _; cin \u0026gt;\u0026gt; _; while(_--) solve(); return 0; } 移位运算 \u0026laquo; \u0026raquo; 左移高位溢出直接丢掉，右移低位溢出直接丢掉。 左移相当于 ×2 右移相当于 /2 一般不对负数移位，移位时会把符号位也移出去。\n取反运算 ~ 按位取反\n双指针 特征：1.两个指针在同一个容器内 2.一快一慢 3.只往同一个方向走 4.区间内维护某种条件 伪代码实现(求和为目标值的数)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Input: nums[] (升序数组), target (目标值) Output: pairs (所有满足条件的数对) 1. 初始化: left = 0, right = len(nums) - 1 pairs = [] 2. 开始移动指针: while left \u0026lt; right: sum = nums[left] + nums[right] if sum == target: pairs.append((nums[left], nums[right])) left += 1 right -= 1 else if sum \u0026lt; target: left += 1 # 需要更大的值 else: right -= 1 # 需要更小的值 3. 返回结果: return pairs eg: 题目描述:本题有 ( T ) 组测试样例，对于每组样例：给定一个长度为 ( n ) 的数组，求其中最长的连续且无重复数字的子序列的长度。 输入格式:第一行一个整数 ( T )，表示样例数。 ( (1 \\leq T \\leq 10) ) 第一行一个整数 ( n )。 ( \\left(1 \\leq n \\leq 10^5\\right) ) 第二行 ( n ) 个整数 ( a_i )。 ( \\left(1 \\leq a_i \\leq 10^5\\right) ) 数据保证 ( \\sum n \\leq 10^5 )。 输出格式:一个整数表示答案。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2e5 + 9; int a[N], c[N]; // a[N]是读入的数组 c[N]用来记录数组中每个数的出现次数，其实是采用了桶的思想 void solve() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n; ++i) c[a[i]] = 0; ll ans = 0; for (int i = 1, j = 0; i \u0026lt;= n; ++i) { while (j \u0026lt; n \u0026amp;\u0026amp; !c[a[j + 1]]) c[a[++j]]++; // 若当前数字 a[j+1]在窗口内没有重复（c[a[j+1]] == 0），右移 j，并将 c[a[j+1]] 计数增加，表示该数字进入窗口。 ans = max(ans, j - i + 1ll); c[a[i]]--; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _; cin \u0026gt;\u0026gt; _; while (_--) solve(); return 0; } 二分 二分法（Binary Search）是一种在有序数组中查找特定元素的高效算法。它通过将目标值与数组中间元素进行比较，从而将搜索范围缩小一半，这使得二分法的时间复杂度为 O(log n)，其中 n 是数组的长度。二分法也可以扩展到查找最小值、最大值、满足特定条件的第一个或最后一个元素等。 二分里重要的两个函数： lower_bound（起始位置，结束位置，给定值） lower_bound 函数返回一个迭代器，指向容器中第一个不小于给定值的元素。如果所有元素都小于给定值，则返回指向容器末尾的迭代器。 upper_bound（起始位置，结束位置，给定值） upper_bound 函数返回一个迭代器，指向容器中第一个大于给定值的元素。如果所有元素都不大于给定值，则返回指向容器末尾的迭代器。 二分思路： 1.确定二分范围，即l和r 2.循环条件一定是while(l + 1 != r) 3.mid = (l + r) / 2 4.if(check()) l == mid (或者 r == mid) 5.else r == mid (或者 l == mid) 伪代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Input: nums[] (升序数组), target (查找的目标值) Output: index (找到的目标值下标，若不存在则返回 -1) 1. 初始化: left = 0, right = len(nums) - 1 2. 开始查找: while left \u0026lt;= right: mid = left + (right - left) / 2 if nums[mid] == target: return mid # 找到目标值 else if nums[mid] \u0026lt; target: left = mid + 1 # 排除左半部分 else: right = mid - 1 # 排除右半部分 3. 未找到: return -1 事实上 要记住 mid即是你想要的答案，所做的每一步就是把mid夹逼到题目所问的位置 eg: 二分查找模板 题目描述:给定一个大小为 ( n ) 的单调不减的非负整数序列 ( a )（下标从 1 开始），再给出 ( q ) 个询问。对于每个询问，给出一个整数 ( x )，你需要回答出，( x ) 第一次在给定序列 ( a ) 中出现的下标。 输入描述:第一行：两个整数 ( n, q )。 ( \\left(1 \\leq n, q \\leq 2 \\times 10^5\\right) ) 第二行：( n ) 个整数，表示 ( a_1, a_2, \\cdots, a_n )。 ( \\left(0 \\leq a_i \\leq 10^9, 1 \\leq i \\leq n\\right) ) 第三行：( q ) 个整数，表示询问的具体数字。 ( \\left(0 \\leq x \\leq 10^9\\right) ) 输出描述:共一行，( q ) 个整数，表示每个询问数字在序列中第一次出现的下标，若不存在，则为 -1。请注意，每个整数后为空格，而不是换行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2e5 + 9; int a[N]; void solve() { int n, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; while (q--) { int x; cin \u0026gt;\u0026gt; x; int l = 0, r = n; // 注意这里的初始值应该是 1 和 n，因为数组是从 1 开始索引的 while (l + 1 != r) { int mid = (l + r) / 2; if (a[mid] \u0026lt; x) l = mid; else r = mid; } if (a[r] == x) cout \u0026lt;\u0026lt; r \u0026lt;\u0026lt; \u0026#39; \u0026#39;; else cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } eg:题目描述：Farmer John建造了一个有 ( N )（( 2 \\leq N \\leq 10^5 )）个隔间的牛棚，这些隔间分布在一条直线上，坐标是 ( x_1, x_2, \\cdots, x_N )（( 0 \\leq x_i \\leq 10^9 )）。他的 ( C )（( 2 \\leq C \\leq N )）头牛不满于隔间的位置分布，它们为牛棚里其他的牛的存在而愤怒。为了防止牛之间的互相打斗，Farmer John想把这些牛安置在指定的隔间，所有牛中相邻两头的最近距离越大越好。那么，这个最大的最近距离是多少呢？ 输入格式：第 1 行：两个用空格隔开的数字 ( N ) 和 ( C )。第 2 至 ( N+1 ) 行：每行一个整数，表示每个隔间的坐标。 输出格式：输出只有一行，即相邻两头牛最大的最近距离。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2e5 + 9; int a[N], n, c; int f(int mid) // 在mid的条件下 能放的牛的最大数量 （放的牛数量越大，相邻两头的最近距离越小） { int res = 0; int pre = -1e9; // res是贪心算法算出的可以放置牛的最大数量 pre表示上一个放了牛的点的位置 for (int i = 1; i \u0026lt;= n; ++i) { if (a[i] - pre \u0026gt;= mid) { res++; pre = a[i]; } } return res; } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; c; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; sort(a + 1, a + 1 + n); int l = 0; int r = 1e9 + 10; while (l + 1 != r) { int mid = (l + r) / 2; if (f(mid) \u0026gt;= c) l = mid; else r = mid; } cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 排序 排序并去重模板 sort(a.begin(),a.end()); a.erase(unique(a.begin(),a.end()),a.end()); sort(a,b)是一个左闭右开的区间 从小到大排序 若要从大到小 则再reverse(a,b)即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1005; vector\u0026lt;int\u0026gt; a; int main() { ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); int n; cin \u0026gt;\u0026gt; n; a.resize(n+1); for(int i = 1; i \u0026lt;= n; ++i) { int x; cin \u0026gt;\u0026gt; x; a.push_back(x); } sort(a.begin(),a.end()); a.erase(unique(a.begin(),a.end(),a.end())); return 0; } 结构体排序模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2e5 + 9; struct A { int a,b,c; //函数重载： bool operator \u0026lt; (const A \u0026amp;u) const { if (a == u.a \u0026amp; b == u.b) return c \u0026lt;u.c; else if (a == u.a) return b \u0026lt;u.b; return a \u0026lt; u.a; } }p[N]; int main() { ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); int n; cin \u0026gt;\u0026gt; n; for(int i = 1;i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; p[i].a \u0026gt;\u0026gt; p[i].b \u0026gt;\u0026gt; p[i].c; sort(p+1,p+1+n); for(int i = 1;i \u0026lt;= n; ++i) cout \u0026lt;\u0026lt;p[i].a \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; p[i].b \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;p[i].c \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; ; return 0; } 桶排序模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2e5 + 9; int c[N]; int main() { ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); int n; cin \u0026gt;\u0026gt; n; for(int i = 1; i \u0026lt;= n;++i) { int x;cin\u0026gt;\u0026gt;x; c[x] ++; } for(int i = 0;i \u0026lt;= 2e5; ++i) { for(int j = 0; j \u0026lt; c[i]; ++j) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt;\u0026#39; \u0026#39;; } } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 3.栈、优先队列、map、set、bitset 栈 栈：先进后出的数据结构（一个放在地上的桶） 维护栈的时候只维护栈顶\n题目描述：现在有 ( n ) 部火车，每一部火车都有一个1~( n ) 的编号且各不相同（火车编号构成一个排列）。现在他们按照给定的顺序排列在一条轨道上，只能按照箭头所指方向移动，问他们能否通过一个车站，且每部火车至多进站一次，使得出站口的编号顺序变为升序（即出站顺序为 1, 2, 3,\u0026hellip;）？如果可以输出 \u0026ldquo;Yes\u0026rdquo;，如果不行输出 \u0026ldquo;No\u0026rdquo;。（不带引号） 输入格式：第一行一个整数 ( n )。 ( (1 \\leq n \\leq 10^5) ) 第二行 ( n ) 个整数 ( a_i ) 表示在进站口的编号。 ( (1 \\leq a_i \\leq n, a_i \\neq a_j) ) 输出格式：如果可以变为升序输出 \u0026ldquo;Yes\u0026rdquo;，反之输出 \u0026ldquo;No\u0026rdquo;。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e5 + 9; int a[N], pos; void solve() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; // 右边待进站列车 stack\u0026lt;int\u0026gt; stk; pos = 1; // 表示当前是第几辆车 // i表示左边轨道所需的列车编号 for (int i = 1; i \u0026lt;= n; ++i) { // 如果不是想要的（目标列车存在且车站是空的或者栈顶不是目标列车） 就一直找（右侧进站） while (pos \u0026lt;= n \u0026amp;\u0026amp; (stk.empty() || stk.top() != i)) stk.push(a[pos++]); // 找到了目标列车 则弹出（目标列车进入左侧轨道） if (stk.top() == i) stk.pop(); else { cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return; } } cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 优先队列/堆(priority_queue) 是一种二叉树状结构，只对堆顶(top)进行维护，堆顶元素是最大/最小的（由比较函数决定）默认是大根堆 eg:题目描述：你有一个菜篮子。 接下来 ( Q ) 次操作，每次操作如下：\n\u0026ldquo;1 x\u0026rdquo;，将一个重量为 ( x ) 的菜放入到菜篮子中。 \u0026ldquo;2\u0026rdquo;，将菜篮子中重量最大的菜丢掉（如果菜篮子为空，则跳过）。 问 ( Q ) 次操作后，菜篮子中剩下的菜的总重量。 输入描述： 第一行一个整数 ( Q )，表示操作次数。 ( \\left(1 \\leq Q \\leq 10^5\\right) ) 接下来 ( Q ) 行，每行一条操作。 ( \\left(1 \\leq x \\leq 10^9\\right) ) 输出描述:一个整数表示答案。 注意，优先队列里没有对于队列里所有元素求和sum的内置函数，需要自己维护\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e5 + 9; void solve() { int q; cin \u0026gt;\u0026gt; q; priority_queue\u0026lt;ll\u0026gt; pq; ll sum = 0; while (q--) { int op; cin \u0026gt;\u0026gt; op; if (op == 1) { ll x; cin \u0026gt;\u0026gt; x; pq.push(x); sum += x; } else if (pq.size()) { sum -= pq.top(); pq.pop(); } } cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 小根堆模板1\n1 priority_queue\u0026lt;ll,vector\u0026lt;ll\u0026gt;,greater\u0026lt;ll\u0026gt;\u0026gt; pq; 小根堆模板2\n1 2 3 4 5 6 7 8 struct cmp { bool oprator()(const ll \u0026amp;u,const ll \u0026amp;v)const { return u \u0026gt; v; } } priority_queue\u0026lt;ll,vector\u0026lt;ll\u0026gt;,cmp\u0026gt; pq; map map 是一个关联容器，它存储了键值对（key-value pairs）。std::map 中的元素是按键排序的，通常是根据键的顺序自动排序的，这意味着它是一个有序的容器。std::map 基于红黑树实现，这确保了即使在最坏情况下，基本操作（如查找、插入和删除）的时间复杂度也是对数级的（O(log n)）。 map可用[]运算符像数组一样操作,只不过下表变成了键值，也可以像普通STL一样用内置函数操作。一般不做erase只做insert之后进行查找即通过key去找value。 常用专门函数: count(key) 返回key所对应的value的个数（0/1）。 find(key) 返回key所对应的iterator,若iterator = end()，说明没有这个key。 eg:题目描述：空中有 ( n ) 个气球，第 ( i ) 个气球有一个颜色 ( col_i )（用一个字符串表示）。请你求出每种气球的个数，按照气球出现的顺序进行排序输出。 输入描述：第一行一个整数 ( T ) 表示样例个数。 ( (1 \\leq T \\leq 10) ) 对于每个样例，第一行一个整数 ( n ) 表示气球个数。 ( (1 \\leq n \\leq 100) ) 接下来 ( n ) 行，每行一个字符串表示 ( col_i )。 ( \\left(1 \\leq |col_i| \\leq 50\\right) ) 字符串仅包含小写英文字母。 输出描述：对于每个样例，输出所有气球的种类和个数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e5 + 9; int a[N], pos; void solve() { map\u0026lt;string, int\u0026gt; mp; // mp[s]表示s的数量 vector\u0026lt;string\u0026gt; v; // 表示字符串出现的顺序 int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) { string s; cin \u0026gt;\u0026gt; s; if (mp.count(s)) mp[s]++; else v.push_back(s), mp[s] = 1; } for (auto \u0026amp;i : v) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; mp[i] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _; cin \u0026gt;\u0026gt; _; while (_--) solve(); return 0; } set set是一个基于平衡二叉搜索树（通常是红黑树）实现的关联容器，它存储唯一的元素，并且元素会按照特定的顺序自动排序（默认升序）。set中的元素是唯一的，这意味着不允许有重复的元素。插入、删除、查找效率都很高。 eg: 题目描述:给定一个大小为 ( n ) 的整型数组 ( a )，你需要对其按照升序排序并进行去重。 输入描述:第一行：一个整数 ( n )。 ( (1 \\leq n \\leq 2 \\times 10^5) ) 第二行：( n ) 个整数，表示数组 ( a ) 的所有元素。 ( \\left(-10^9 \\leq a_i \\leq 10^9, 1 \\leq i \\leq n\\right) ) 输出描述:共一行，( n ) 个整数，表示进行升序排序并进行去重后的数组。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e5 + 9; int a[N]; void solve() { int n; cin \u0026gt;\u0026gt; n; set\u0026lt;int\u0026gt; st; for (int i = 1; i \u0026lt;= n; ++i) { int x; cin \u0026gt;\u0026gt; x; st.insert(x); } for (auto \u0026amp;i : st) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } bitset bitset 是一个固定大小的位集合容器，它提供了一种高效的方式来存储和操作二进制位。bitset 模板的参数指定了位集合中位的数量，并且所有的位最初都被设置为 0。可以理解为一个很长二进制数，右边是低位左边是高位，每位都只能0/1。只支持位运算不支持算术运算。 可以当作一个bool[]来用。 常用函数：count()返回1的个数;reset()各位全部置零 eg:题目描述：给定 ( n ) 个整数，问由这些整数通过“加法”操作，可以组成多少种数字？ 输入格式：第一行一个整数 ( n )。 ( \\left(1 \\leq n \\leq 5 \\times 10^3\\right) ) 第二行 ( n ) 个整数。 ( \\left(1 \\leq a_i \\leq 100\\right) ) 输出格式：一个整数表示答案。 需要借助dp（动态规划的思想）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e5 + 9, M = 5e5 + 9; int a[N]; void solve() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; bitset\u0026lt;M\u0026gt; bs; bs[0] = 1; for (int i = 1; i \u0026lt;= n; ++i) bs |= (bs \u0026lt;\u0026lt; a[i]); // 先把上一轮的左移a[i]位（相当于上一轮的每个数都加上a[i]），再与上一轮的相或（相当于复制上一轮结果）。 cout \u0026lt;\u0026lt; bs.count() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 4.单调栈、单调队列 单调栈 单调栈是一种单调递增或单调递减的栈。它只允许在栈的顶部插入和删除元素，但插入和删除的操作受到栈的单调性限制。 一般用单调栈不直接存元素 而是去存这个元素的下标 因为如果用元素是无法反推得到下标的 且，一般用数组来实现单调栈而不是stl里的stack\neg:题目描述:给定一个长度为 ( n ) 的整数数组 ( a )，你需要求出每个元素的左边离它最近且比它小的元素。 输入描述:第一行：一个整数 ( n )。 ( \\left(1 \\leq n \\leq 2 \\times 10^5\\right) ) 第二行：( n ) 个整数，表示整数数组 ( a )。 ( \\left(1 \\leq a_i \\leq 10^9\\right) ) 输出描述:共一行，( n ) 个整数，表示每个元素的左边第一个比它小的元素，若不存在则为 -1。 单调栈模板题 1.用stl实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2e5 + 9; int a[N], l[N]; // l[N]就是求每个元素的左边第一个比它小的元素 void solve() { int n; cin \u0026gt;\u0026gt; n; stack\u0026lt;int\u0026gt; st; // 这里题目要求的就是元素值 因此不用下标，直接存value for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n; ++i) { while (st.size() \u0026amp;\u0026amp; st.top() \u0026gt;= a[i]) { st.pop(); } // st.size() 用于确保在调用 st.top() 之前栈是非空的。 // st.empty() 用于在循环内部检查栈是否为空，并根据情况更新 l[i] 的值。 if (st.empty()) l[i] = -1; // 栈为空 else l[i] = st.top(); // 栈非空 st.push(a[i]); } for (int i = 1; i \u0026lt;= n; ++i) cout \u0026lt;\u0026lt; l[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); } 单调栈模板题 2.用数组实现 清除效率更高，可以lazyclear(脏数据留下不用管他 直接清除top即可)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2e5 + 9; int a[N], l[N], stk[N], top; // 在单调栈stk里存放的是下标 void solve() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n; ++i) { while (top \u0026amp;\u0026amp; a[stk[top]] \u0026gt;= a[i]) top--; if (top) l[i] = a[stk[top]]; else l[i] = -1; stk[++top] = i; } for (int i = 1; i \u0026lt;= n; ++i) cout \u0026lt;\u0026lt; l[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); } 单调队列 单调队列是一种单调递增或单调递减的队列。它允许在队列的前端和后端插入和删除元素，但插入和删除的操作受到队列的单调性限制。 普通的queue只能对头进行弹出 因此构造单调队列是一般用双端队列deque 其中front是头，back是尾 deque = deque()或while(dq.size())dq.pop_back();可以清空 队列里存的也是下标 而不是值 eg：x1 x2 x3 x4 而所说的单调是指 f(x)单调的 即 f(x1) \u0026gt; f(x2) \u0026gt; f(x3) \u0026gt; f(x4) 思路： 1.for()进入循环 2.检测队头合法性：while(队列非空且头不合法)弹出队头 pop_front 3.检测队尾优越性：while(队列非空且当前的i的值优于队尾) 弹出队尾 pop_back 4.push_back(i) 5.输出队头即为最优\neg:题目描述:给定一个长度为 $n$ 的数组 $a$。有一个大小为 $k$ 的滑动窗口（窗口中只能看到 $k$ 个元素），它从数组的最左边，每次向右移动一个位置，直到移动到最右边。你需要回答出滑动窗口在每个位置时，窗口中的最大值和最小值。 输入描述:第一行：两个整数 $n, k$。 ($1 \\leq k \\leq n \\leq 2 \\times 10^5$)第二行：$n$ 个整数，代表数组 $a$。 ($-10^6 \\leq a_i \\leq 10^6, 1 \\leq i \\leq n$) 输出描述:第一行：从左到右，滑动窗口在每个位置的最大值。第二行：从左到右，滑动窗口在每个位置的最小值。 单调队列作滑动窗口模板题 1.用stl实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2e5 + 9; int a[N]; void solve() { int n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; deque\u0026lt;int\u0026gt; dq; for (int i = 1; i \u0026lt;= n; ++i) // 找最大值 { // 以i为右端点 区间大小为k 即[i-k+1,i] // 1.队头合法性： while (dq.size() \u0026amp;\u0026amp; dq.front() \u0026lt;= i - k) dq.pop_front(); // 2.队尾优越性： while (dq.size() \u0026amp;\u0026amp; a[dq.back()] \u0026lt;= a[i]) dq.pop_back(); dq.push_back(i); if (i \u0026gt;= k) cout \u0026lt;\u0026lt; a[dq.front()] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; dq = deque\u0026lt;int\u0026gt;(); // 清空dq for (int i = 1; i \u0026lt;= n; ++i) // 找最小值 { // 以i为右端点 区间大小为k 即[i-k+1,i] while (dq.size() \u0026amp;\u0026amp; dq.front() \u0026lt;= i - k) dq.pop_front(); while (dq.size() \u0026amp;\u0026amp; a[dq.back()] \u0026gt;= a[i]) dq.pop_back(); dq.push_back(i); if (i \u0026gt;= k) cout \u0026lt;\u0026lt; a[dq.front()] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); } 单调队列作滑动窗口模板题 2.用数组实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2e5 + 9; int a[N],dq[N],head,tail; void solve() { int n,k;cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for(int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; int head = 1, tail = 0; //求最大： for(int i = 1; i \u0026lt;= n; ++i) { while(head \u0026lt;= tail \u0026amp;\u0026amp; dq[head] \u0026lt;= i - k) head ++; while(head \u0026lt;= tail \u0026amp;\u0026amp; a[dq[tail]] \u0026lt;= a[i]) tail --; dq[++ tail] = i; if(i \u0026gt;= k) cout \u0026lt;\u0026lt;a[dq[head]] \u0026lt;\u0026lt;\u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; head = 1; tail = 0; //求最小： for(int i = 1; i \u0026lt;= n; ++i) { while(head \u0026lt;= tail \u0026amp;\u0026amp; dq[head] \u0026lt;= i - k) head ++; while(head \u0026lt;= tail \u0026amp;\u0026amp; a[dq[tail]] \u0026gt;= a[i]) tail --; dq[++ tail] = i; if(i \u0026gt;= k) cout \u0026lt;\u0026lt;a[dq[head]] \u0026lt;\u0026lt;\u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); int _ = 1 ; while(_--) solve(); } eg:给定一个大小为n的整数序列a（下标从1开始），你需要求出该序列所有子区间最小值的和，即 $$ \\sum_{i=1}^{n}\\sum_{j=i}^{n}\\operatorname{min}\\left(a_{i}, a_{i+1},\\cdots, a_{j}\\right) $$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2e5 + 9; ll a[N],l[N],r[N]; //l[N] : i左边最近的\u0026lt;= a[i]的位置 r[N]：i右边最近的\u0026lt;a[i]的位置 int stk[N],top; //数组模拟单调栈 void solve() { int n;cin \u0026gt;\u0026gt; n; for(int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; //先求l[] \u0026lt; a[i] for(int i = 1; i \u0026lt;= n; ++i) { while(top \u0026amp;\u0026amp; a[stk[top]] \u0026gt;= a[i]) top--; //此时栈顶就是l[i] if(!top) l[i] = 0; else l[i] = stk[top]; stk[++top] = i; } top = 0; for(int i = n; i \u0026gt;= 1; -- i) { //上面是\u0026gt;=这里就是\u0026lt; 左闭右开 while(top \u0026amp;\u0026amp; a[stk[top]] \u0026gt; a[i]) top--; if(!top) r[i] = n + 1; else r[i] = stk[top]; stk[++top] = i; } ll ans = 0; for(int i = 1; i \u0026lt;= n; ++i) ans += a[i]*(r[i] - i) *(i - l[i]); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); int _ = 1 ; while(_--) solve(); } 5.树状数组和离散化 树状数组 树状数组（Binary Indexed Tree，简称 BIT 或 Fenwick Tree）是一种数据结构，用于高效地处理数组上的累积和（前缀和）问题，特别是对于区间求和(O(logn))和单点更新(O(1))操作。它通过构建一个辅助数组来实现对原始数组的快速查询和更新。 树状数组并不是树结构，而是通过一个一维数组实现的。它利用了二进制表示的特性，将原始数组中的每个元素映射到树状数组中的多个位置，从而实现区间和的快速计算。 注意：1.一定不能用0当下标 2.开数组的时候的大小与原数组一样 lowbit 操作：对于一个整数 x，lowbit(x) 表示 x 的二进制表示中最低位的 1。例如，lowbit(10) = 2，因为 10 的二进制表示为 1010，最右边的 1 位于第 2 位（从 0 开始计数） ！！！相当于 （x \u0026amp; -x）！！！ 树状数组的原理： 树状数组的核心思想是将原始数组的每个元素映射到一个新的数组（树状数组）中的多个位置，从而实现快速的区间求和。这个映射是基于二进制表示的，特别是基于一个数的二进制表示中最低位的 1（即 lowbit）。 优势：单点修改 区间求和 单点修改： 更新操作涉及到将一个值加到原始数组的某个位置上，然后更新树状数组中所有受到这个更新影响的位置。具体来说，从 i 开始，每次将i加上 lowbit(i)，直到 i 超过数组的大小。 区间求和： 查询操作涉及到计算原始数组中从索引 1 到 i 的所有元素的累积和。这可以通过遍历树状数组中所有 i 的 lowbit(i)位置来实现，将这些位置上的值累加起来。 伪代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 Input: n (数组大小), arr[] (初始数组) Output: fenwick[] (树状数组) 1. 初始化: fenwick[i] = 0 (大小为 n + 1，因为从 1 开始存储) 2. 单点更新: function update(index, delta): while index \u0026lt;= n: fenwick[index] += delta index += index \u0026amp; (-index) # 移动到下一个父节点 3. 查询前缀和: function query(index): sum = 0 while index \u0026gt; 0: sum += fenwick[index] index -= index \u0026amp; (-index) # 移动到前一个节点 return sum 4. 构建树状数组: for i = 1 to n: update(i, arr[i]) 5. 查询任意区间 [l, r]: function range_query(l, r): return query(r) - query(l - 1 eg:题目描述:给定一个大小为 ( n ) 的数组 ( a ) 和 ( q ) 次操作。每次操作分为下面两种：\n\u0026ldquo;1 ( k ) ( v )\u0026quot;：给 ( a_k ) 加上 ( v )。 \u0026ldquo;2 ( l ) ( r )\u0026quot;：查询区间 ([l, r]) 的和。 对于每次2操作，输出结果。 输入格式:第一行两个整数 ( n, q )。 ( \\left(1 \\leq n, q \\leq 2 \\times 10^5\\right) ) 第二行 ( n ) 个整数表示数组 ( a )。 ( \\left(-10^5 \\leq a_i \\leq 10^5\\right) ) 接下来 ( q ) 行，每行一个操作。 ( (1 \\leq l \\leq r \\leq n, -10^5 \\leq v \\leq 10^5) ) 输出格式:对于每次2操作，在一行内输出结果。 树状数组单点修改模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2e5 + 9; int a[N], t[N]; // t数组即树状数组 int n, q; int lowbit(int x){ return x \u0026amp; -x;} void update(int k, ll x) { for (int i = k; i \u0026lt;= n; i += lowbit(i))t[i] += x; // a_k加多少，所有覆盖到a_k的树状数组也要加多少 // 通过每一个+lowbit找到下一个覆盖a_k的树状数组 } ll getsum(int k) { ll res = 0; for (int i = k; i \u0026gt; 0; i -= lowbit(i))res += t[i]; //通过每一个-lowbit找到与当前树状数组无缝衔接的上一个 return res; } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n; ++i)update(i, a[i]); while (q--) { int op; cin \u0026gt;\u0026gt; op; if (op == 1) { ll k, v; cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; v; update(k, v); } else { ll l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; cout \u0026lt;\u0026lt; getsum(r) - getsum(l - 1) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } eg：题目描述:给定一个大小为 ( n ) 个数组 ( a )，( q ) 次操作。每次操作分为下面两种：\n\u0026ldquo;1 ( l ) ( r ) ( v )\u0026quot;：给区间 ([l, r]) 中的数组加上 ( v )。 \u0026ldquo;2 ( l ) ( r )\u0026quot;：查询区间 ([l, r]) 中数字的和。 对于每次2操作，输出结果。 输入格式:第一行两个整数 ( n, q )。 ( \\left(1 \\leq n, q \\leq 2 \\times 10^5\\right) ) 第二行 ( n ) 个整数表示数组 ( a )。 ( \\left(-10^5 \\leq a_i \\leq 10^5\\right) ) 接下来 ( q ) 行，每行一个操作。 ( \\left(1 \\leq l \\leq r \\leq n, -10^5 \\leq v \\leq 10^5\\right) ) 输出格式:对于每次2操作，在一行内输出结果。 思路： 用树状数组来维护差分d[]。 a[1]=d[1];a[2]=d[1]+d[2];a[3]=d[1]+d[2]+d[3]…… 而[ \\sum_{i=1}^{r} a_i = \\sum_{i=1}^{r} (r+1)d_i - \\sum_{i=1}^{r} id_i ] 可以把原数组拆成两个数组，分别叫做t1（来表示式子中的di的累加）,t2（来表示式子中的i*di的累加）。每一次的区间修改，就转化成了在t1和t2这两个数组上的单点修改，就可以化为模型1。 树状数组区间修改模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2e5 + 9; ll a[N], td[N], itd[N]; int lowbit(int x) { return x \u0026amp; -x; } int n, q; void update(int k, ll x) { for (int i = k; i \u0026lt;= n; i += lowbit(i)) td[i] += x, itd[i] += k * x; } ll getsum(int k) { ll res = 0; for (int i = k; i \u0026gt; 0; i -= lowbit(i)) res += (k + 1) * td[i] - itd[i]; return res; } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n; ++i) { // 用差分数组的逻辑来进行区间修改 update(i, a[i]); update(i + 1, -a[i]); } while (q--) { int op; cin \u0026gt;\u0026gt; op; if (op == 1) { ll l, r, v; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; v; update(l, v); ; update(r + 1, -v); } else { ll l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; cout \u0026lt;\u0026lt; getsum(r) - getsum(l - 1) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } eg:题目描述:给定一个长度为 ( n ) 的数组 ( a )，求 ( a ) 的逆序对个数。逆序对的定义是一个二元组 ( (a_i, a_j) )，满足：( i \u0026lt; j ) 且 ( a_i \u0026gt; a_j )。 输入格式:一个整数 ( n )。 ( \\left(1 \\leq n \\leq 2 \\times 10^5\\right) ) 接下来一行 ( n ) 个整数表示数组 ( a )。 ( \\left(1 \\leq a_i \\leq 10^9\\right) ) 输出格式:一行输出一个结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2e5 + 9; ll a[N], t[N]; int n, q; vector\u0026lt;int\u0026gt; X; // 用来做离散化数组 int bin(int x) // 通过元素找下标 { return lower_bound(X.begin(), X.end(), x) - X.begin() + 1; } int lowbit(int x) { return x \u0026amp; -x; } void update(int k, int x) { for (int i = k; i \u0026lt;= X.size(); i += lowbit(i)) t[i] += x; } int getsum(int k) { int res = 0; for (int i = k; i \u0026gt; 0; i -= lowbit(i)) res += t[i]; return res; } void solve() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) { cin \u0026gt;\u0026gt; a[i]; X.push_back(a[i]); } sort(X.begin(), X.end()); X.erase(unique(X.begin(), X.end()), X.end()); ll ans = 0; for (int i = 1; i \u0026lt;= n; ++i) { ans += getsum(X.size()) - getsum(bin(a[i])); // 因为已经排序 所以：所有的 - 小于等于a[i]的 = 严格比a[i]大的 update(bin(a[i]), 1); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 离散化 离散化（Discretization）是一种处理连续数据的技术，它将连续的数值或区间映射到离散的整数上。这种方法在算法设计和数据分析中非常有用，尤其是在处理区间问题、范围查询、几何问题和优化问题时。离散化的目的是简化问题，使其能够在整数上高效地处理。 思路： 1.找出所有与结果有关的相关点 用离散化数组存下来 2.将相关点排序并去重（模板） 3.把原数组映射至离散化数组上 离散化数组也要能映射至原数组中（找下标） 4.把原本在原数组上的操作改到离散化数组中来做，实现数据量降维 伪代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Input: nums[] (需要离散化的数组) Output: discrete_map (原值到离散值的映射) 1. 去重并排序: sorted_nums = sort(unique(nums)) 2. 构建映射: discrete_map = {} for i = 0 to len(sorted_nums) - 1: discrete_map[sorted_nums[i]] = i + 1 3. 转换数组: for i = 0 to len(nums) - 1: nums[i] = discrete_map[nums[i]] 4. 返回结果: return nums, discrete_map eg:题目描述:小e有一个很长很长的数组，数组的下标范围为 (\\left[0,10^9\\right])，初始时每个元素均为0。现在，他想进行 ( n ) 次操作，每次操作将某个下标 ( i ) 处的元素加上 ( x )。然后他给出了 ( q ) 次询问，每个询问格式为 ( l, r )，你需要回答出下标在区间 ([l, r]) 内的所有元素的和。 输入描述:第一行：两个整数 ( n, q )。 ( (1 \\leq n, q \\leq 10^5) ) 接下来 ( n ) 行：每行两个整数 ( i, x )。 ( \\left(0 \\leq i \\leq 10^9, 0 \\leq x \\leq 10^4\\right) ) 再接下来 ( q ) 行：每行两个整数 ( l, r )。 ( \\left(0 \\leq l \\leq r \\leq 10^9\\right) ) 输出描述:共 ( q ) 行，每行输出相应询问的答案。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 3e5 + 9; ll a[N]; // 存离散化数组对应的数组 vector\u0026lt;int\u0026gt; X; // 离散化数组（存的是下标） struct Q // 创建结构体存放操作和询问 { ll a, b; } op[N], query[N]; int getidx(ll x) // 找下标 { // lower_bound：找出数组中第一个 \u0026gt;= x 的迭代器 return lower_bound(X.begin(), X.end(), x) - X.begin() + 1; // 返回值的范围是[1,X.size()] } void solve() { int n, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; ++i) { ll x, w; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; w; // x是题中下标i，w是元素加的那个x X.push_back(x); // 记录所有用得到的下标 op[i] = {x, w}; } for (int i = 1; i \u0026lt;= q; ++i) { ll l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; X.push_back(l), X.push_back(r); query[i] = {l, r}; } // 排序去重 sort(X.begin(), X.end()); X.erase(unique(X.begin(), X.end()), X.end()); for (int i = 1; i \u0026lt;= n; ++i) { int x = getidx(op[i].a); ll w = op[i].b; a[x] += w; } for (int i = 1; i \u0026lt;= X.size(); ++i) a[i] += a[i - 1]; // 更新a[i]直接作前缀和 for (int i = 1; i \u0026lt;= q; ++i) { int l = getidx(query[i].a); int r = getidx(query[i].b); cout \u0026lt;\u0026lt; a[r] - a[l - 1] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 6.图的存储、DFS、BFS 图的存储 邻接矩阵 邻接矩阵是一种用于表示图的数据结构，它使用一个二维数组来存储图中顶点之间的连接关系。在邻接矩阵中，行和列分别代表图中的顶点，而矩阵中的元素表示顶点之间的边。 表示无向图和有向图：邻接矩阵可以表示无向图和有向图。对于无向图，邻接矩阵是对称的；对于有向图，如果存在从顶点 i 到顶点 j 的边，则 matrix[i][j] 包含边的权重或存在性，而 matrix[j][i] 通常为 0 或不包含边。 一般用的比较少\n深度优先搜索（DFS） 特点：一条路走到黑 DFS 从起始节点开始，沿着图的边尽可能深地探索，直到到达一个没有未访问邻居的节点，然后回溯到上一个节点，继续探索其他分支。DFS 使用栈（可以是显式的栈或递归调用的隐式栈）来管理已经访问但尚未探索完的节点。DFS 是递归实现的，可以很容易地处理图中的递归结构。 注意 如果可能出现环的话 需要多开一个布尔或bitset vis[i]数组 表示是否已经走过i了。当所查找的点vis[i]=ture，则跳出递归，接着找其他的子节点。 伪代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 Input: n (点数), edges[] (边表), start (起点) Output: visited[] (标记是否访问过) 1. 初始化: visited[i] = false (所有点未访问) graph[i] = [] (使用邻接表表示图) 2. 构建图: for each (u, v) in edges: graph[u].append(v) (无向图需加 graph[v].append(u)) 3. DFS 函数: function dfs(node): visited[node] = true for neighbor in graph[node]: if not visited[neighbor]: dfs(neighbor) 4. 遍历所有点: for i = 1 to n: if not visited[i]: dfs(i) eg: 题目描述:给定一个 $n$ 个点 $m$ 条边的有向图，图中可能存在重边和自环，点的编号为 $1\\sim n$。 你需要求出从点1出发，能够到达的所有点。 输入描述:第一行：两个整数 $n, m$，分别表示有向图的点数、边数。($1 \\leq n, m \\leq 10^5$) 接下来 $m$ 行：每行两个整数 $u_i, v_i$，表示存在一条从 $u_i$ 到 $v_i$ 的有向边。 ($1 \\leq u_i, v_i \\leq n$) 输出描述:共一行，从小到大输出1号点能够到达的点的编号。 dfs模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 60; vector\u0026lt;int\u0026gt; g[N]; int n, m; bitset\u0026lt;N\u0026gt; vis; void dfs(int x) { if (vis[x]) return; // 若走过则跳过 vis[x] = true; for (auto \u0026amp;y : g[x]) dfs(y); } void solve() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; while (m--) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; if (u != v) g[u].push_back(v); // 若不是一个点，则放入邻接表 } dfs(1); for (int i = 1; i \u0026lt;= n; ++i) if (vis[i]) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 全排列 全排列是指从给定的一组元素中，生成所有可能的排列组合。对于一个包含 n 个不同元素的集合，它的全排列数量是 n 的阶乘（n!），即 1 到 n 所有正整数的乘积。 eg:题目描述:给定一个数字 $n$，请按照字典序输出排列 $[1,2,\\ldots,n]$ 的全排列。 输入格式:一个整数 $n$。 ($1 \\leq n \\leq 10$) 输出格式 :一行输出一个结果，按照字典序从小到大排列。 用dfs实现全排列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 19; int a[N], n; bitset\u0026lt;N\u0026gt; vis; void dfs(int dep) // dep表示此时所处的深度 { if (dep == n + 1) // 说明已经走到叶子节点最下面了 需输出 { for (int i = 1; i \u0026lt;= n; ++i) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[i == n]; return; } for (int i = 1; i \u0026lt;= n; ++i) { if (vis[i]) continue; vis[i] = true; a[dep] = i; dfs(dep + 1); // 去下一层 // 出来之后恢复现场： a[dep] = 0; vis[i] = false; } } void solve() { cin \u0026gt;\u0026gt; n; dfs(1); } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 全排列函数模板 按字典序从小到大\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 19; int n, a[N]; void solve() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) a[i] = i; bool go = true; while (go) { for (int i = 1; i \u0026lt;= n; ++i) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; go = next_permutation(a + 1, a + 1 + n); } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 全排列函数模板 按字典序从小到大\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 19; int n, a[N]; void solve() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) a[i] = n + 1 - i; bool go = true; while (go) { for (int i = 1; i \u0026lt;= n; ++i) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; go = prev_permutation(a + 1, a + 1 + n); } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 广度优先搜索（BFS） 特点:像洋葱一样一层一层拨开你的心 BFS 从起始节点开始，首先探索所有邻接的节点，然后对每个邻接节点的未访问邻接节点进行探索，以此类推。BFS 使用队列来管理待访问的节点。BFS 保证找到的是从起点到目标节点的最短路径（如果所有边的权重相同）。 伪代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 Input: n (点数), edges[] (边表), start (起点) Output: dist[] (起点到其他点的最短距离) 1. 初始化: visited[i] = false (所有点未访问) graph[i] = [] (使用邻接表表示图) dist[i] = -1 (所有点初始距离为 -1，表示不可达) queue = [] (空队列) 2. 构建图: for each (u, v) in edges: graph[u].append(v) (无向图需加 graph[v].append(u)) 3. BFS 函数: function bfs(start): queue.push(start) visited[start] = true dist[start] = 0 while queue is not empty: current = queue.pop_front() for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = true dist[neighbor] = dist[current] + 1 queue.push(neighbor) 4. 调用 BFS: bfs(start) eg:题目描述:给定一个 $n$ 个点 $m$ 条边的有向图，图中可能存在重边和自环，点的编号为 $1\\sim n$。 你需要求出从点1出发，能够到达的所有点。 输入描述:第一行：两个整数 $n, m$，分别表示有向图的点数、边数。($1 \\leq n, m \\leq 10^5$) 接下来 $m$ 行：每行两个整数 $u_i, v_i$，表示存在一条从 $u_i$ 到 $v_i$ 的有向边。 ($1 \\leq u_i, v_i \\leq n$) 输出描述:共一行，从小到大输出1号点能够到达的点的编号。 bfs模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e5 + 9; vector\u0026lt;int\u0026gt; g[N]; int n, m; bitset\u0026lt;N\u0026gt; vis; void bfs(int st) { queue\u0026lt;int\u0026gt; q; q.push(st); while (q.size()) { int x = q.front(); q.pop(); if (vis[x]) continue; vis[x] = true; for (auto \u0026amp;y : g[x]) { if (vis[y]) continue; q.push(y); } } } void solve() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; while (m--) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; if (u != v) g[u].push_back(v); // 若不是一个点，则放入邻接表 } bfs(1); for (int i = 1; i \u0026lt;= n; ++i) if (vis[i]) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } eg:题目描述:给定一个大小为 $n \\times m$ 的矩阵，用来表示一个迷宫，矩阵中：0，表示空白处，可以行走；1，表示障碍物，不可通过。最初，小e位于迷宫的左上角 (1,1) 处，每秒钟，他可以向上、左、下、右任意一个方向移动一个位置。现在他想走到迷宫的右下角 $(n, m)$ 处，你能否告诉他，他能否到达目的地，以及若能到达，所需要的最短时间为多少呢？ 输入描述:第一行：两个整数 $n$ 和 $m$ ($1 \\leq n, m \\leq 1000$)，分别表示矩阵的行数和列数。接下来 $n$ 行：每行为 $m$ 个整数 (0 或 1)，表示迷宫矩阵，数据保证 (1,1) 和 $(n,m)$ 均为 0。 输出描述:若无法到达 $(n,m)$，输出 -1；否则，输出所需要的最短时间。 BFS+迪杰斯特拉 求最短路径模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e3 + 9; int mp[N][N]; // 存地图 int d[N][N]; // 表示从起点走到(i,j)所需的最小时间/距离 int n, m; bitset\u0026lt;N\u0026gt; vis[N]; int dx[] = {0, 0, 1, -1}; // 表示上下左右分别对x的变化 int dy[] = {1, -1, 0, 0}; // 表示上下左右分别对y的变化 bool inmp(int x, int y) { return 1 \u0026lt;= x \u0026amp;\u0026amp; x \u0026lt;= n \u0026amp;\u0026amp; 1 \u0026lt;= y \u0026amp;\u0026amp; y \u0026lt;= m; } void bfs(int sx, int sy) { queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q; memset(d, 0x3f, sizeof d); // 初始化为无穷 d[sx][sy] = 0; q.push({sx, sy}); while (q.size()) { int x = q.front().first, y = q.front().second; q.pop(); if (vis[x][y]) continue; // 表示是否已经更新过 vis[x][y] = true; for (int i = 0; i \u0026lt; 4; ++i) { int nx = x + dx[i], ny = y + dy[i]; if (inmp(nx, ny) \u0026amp;\u0026amp; !mp[nx][ny] \u0026amp;\u0026amp; d[nx][ny] \u0026gt; d[x][y] + 1) // 下一步在地图内 且 下一步可走 { d[nx][ny] = d[x][y] + 1; q.push({nx, ny}); } } } } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; ++i) for (int j = 1; j \u0026lt;= m; ++j) cin \u0026gt;\u0026gt; mp[i][j]; bfs(1, 1); if (!vis[n][m]) cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else cout \u0026lt;\u0026lt; d[n][m] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 邻接表 邻接表是图的另一种常用数据结构，用于表示图中顶点之间的关系。与邻接矩阵不同，邻接表更节省空间，尤其是对于稀疏图（边的数量远小于顶点对的数量）。邻接表通过为每个顶点维护一个列表来记录其相邻的顶点，从而表示图的结构。 g[i]表示顶点i的所有出点（由i能够到达的点）编号 在存树时，不需要知道每个点的出入点，只需要知道每个点的父节点就行了。用fa[i]即可表示。 一般用vector来实现 eg:题目描述:给定一棵大小为 $n$，根为 1 的树，求出其 dfs 序、bfs 序。请将所有出点按照编号从小到大排序后进行遍历。解释：dfs 为深度优先搜索，bfs 为宽度优先搜索。 输入格式:一个整数 $n$，表示点的个数。 ($1 \\leq n \\leq 50$)接下来一行 $n-1$ 个整数，第 $i$ 个数字 $fa_i$ 表示点 $i$ 的父亲。($1 \\leq fa_i \\leq n$) 输出格式:第一行输出 dfs 序，第二行输出 bfs 序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 60; int n; int fa[N]; // 存放父节点 vector\u0026lt;int\u0026gt; g[N]; // 存放邻接表 存放每个点的出点 void dfs(int x) // p即双亲 { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; for (auto \u0026amp;y : g[x]) { dfs(y); } } void bfs(int st) { queue\u0026lt;int\u0026gt; q; q.push(st); while (q.size()) { int x = q.front(); //x就是现在所在的节点，开始走他的子节点 q.pop(); cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; for (auto \u0026amp;y : g[x]) q.push(y); //遍历全部子节点放进队列 } } void solve() { cin \u0026gt;\u0026gt; n; for (int i = 2; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; fa[i]; for (int i = 2; i \u0026lt;= n; ++i) g[fa[i]].push_back(i); for (int i = 1; i \u0026lt;= n; ++i) sort(g[i].begin(), g[i].end()); dfs(1); cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; bfs(1); } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 7.并查集、最短路 并查集 并查集（Union-Find）是一种用于处理一些不交集的合并及查询问题的数据结构。它在许多算法问题中都非常有用，特别是在那些需要动态维护元素集合的并集和查询两个元素是否属于同一集合的场景中。 并查集主要有两个操作：查找（Find）：确定两个元素是否属于同一个集合。（原理是去找节点的根，如果两个节点的根是同一个节点，则他们属于有同一个连通块）合并（Union）：将两个元素所在的集合合并。（原理是把一个元素的根连到另一个元素的根，使他们根节点相同） 所以 所有操作都在根上，并不关心某一个具体的节点，而只关心一个连通块的根。 路径压缩（Path Compression）是一种优化技术，用于加速查找（Find）操作。在没有路径压缩的情况下，查找操作可能需要遍历很长的路径才能到达根节点，这会导致查找操作的时间复杂度较高。路径压缩通过在查找过程中将查找路径上的所有节点直接连接到根节点，从而减少未来的查找操作的时间。 伪代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Input: n (元素数量) Output: parent[] (每个点的父节点), size[] (每个集合的大小) 1. 初始化: parent[i] = i (每个点初始化为自己的父节点) size[i] = 1 (每个集合的初始大小为 1) 2. 查找根节点（路径压缩）: function find(x): if parent[x] != x: parent[x] = find(parent[x]) (递归找根节点并路径压缩) return parent[x] 3. 合并两个点所在的集合（按秩合并）: function union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if size[rootX] \u0026lt; size[rootY]: swap(rootX, rootY) (确保 rootX 是较大集合) parent[rootY] = rootX (将 rootY 合并到 rootX) size[rootX] += size[rootY] 4. 判断两个点是否在同一集合: function isConnected(x, y): return find(x) == find(y) eg:题目描述：给定一个无向图，包含 $n$ 个点，$m$ 条边（没有重边和自环）。求图中所有联通块的大小。 输入格式：第一行：两个整数 $n$，$m$，表示点数和边数。（$1 \\leq n, m \\leq 2 \\times 10^5$）接下来 $m$ 行：每行两个整数 $u_i$，$v_i$，表示在 $u_i$ 和 $v_i$ 之间存在一条无向边。 输出格式：从小到大输出所有联通块的大小。 并查集模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e5 + 9; int pre[N], cnt[N];//pre[i]表示i所在的连通块 int root(int x) // 找x所在联通块的根节点 { return pre[x] = (pre[x] == x ? x : root(pre[x])); } void merge(int x, int y) // 做连通块合并 { pre[root(x)] = root(y); } bool isConnected(int x, int y) // 判断是否在同意连通块 { return root(x) == root(y); } void solve() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; ++i) pre[i] = i; for (int i = 1; i \u0026lt;= m; ++i) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; merge(u, v); //每输入一条边 就相当于把两个节点合并 } for (int i = 1; i \u0026lt;= n; ++i) cnt[root(i)]++; vector\u0026lt;int\u0026gt; v; for (int i = 1; i \u0026lt;= n; ++i) { if (cnt[i]) v.push_back(cnt[i]); } sort(v.begin(), v.end()); for (auto \u0026amp;y : v) cout \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 最短路 最短路径问题是图论中的一个经典问题，目的是找到图中两个顶点之间的最短路径。根据图的类型（有向图或无向图）和边的权重（正权重或负权重），最短路径问题的解决方法也有所不同。\n常见的最短路径算法#### Dijkstra 算法 单源最短路径，适用于有向图或无向图，且边的权重必须非负。使用贪心策略，从源点开始，逐步扩展到距离源点最近的顶点。时间复杂度：使用优先队列时为 O((V+E)logV)，其中 V 是顶点数，E 是边数。 思路：创建一个距离数组 dist[]，其中 dist[i] 表示从源点到顶点 i 的最短距离。初始时，将源点到自身的距离设为0，其他所有顶点的距离设为无穷大（INF）。遍历源点的每一条边，用每一条边去更新最短路径。然后在所有点里找距离源点最近的点，遍历它的每一条边，用每一条边去更新最短路径。不断递归，直到遍历了全部的点。 伪代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 朴素数组实现； Input: n (点的数量), graph[n][n] (邻接矩阵, 不存在边时值为 ∞), start (起点) Output: dist[] (从起点到每个点的最短距离) 1. 初始化: dist[] = {∞, ∞, ..., ∞} (长度为 n，所有点的初始距离为无穷大) visited[] = {false, false, ..., false} (长度为 n，标记是否访问过) dist[start] = 0 (起点到自身的距离为 0) 2. 对每个点循环 n 次: a. 从未访问的点中找到距离起点最近的点 u: min_dist = ∞ u = -1 for i = 1 to n: if not visited[i] and dist[i] \u0026lt; min_dist: min_dist = dist[i] u = i b. 如果 u == -1 或 min_dist == ∞，退出循环 (剩余点不可达) c. 标记点 u 为已访问: visited[u] = true d. 更新从 u 到其他点的最短距离: for v = 1 to n: if not visited[v] and graph[u][v] != ∞: dist[v] = min(dist[v], dist[u] + graph[u][v]) 3. 返回 dist[] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 优先队列实现： Input: n (点的数量), graph (邻接表, 每个点存它的边), start (起点) Output: dist[] (从起点到每个点的最短距离) 1. 初始化: dist[] = {∞, ∞, ..., ∞} (所有点的初始距离为无穷大) visited[] = {false, false, ..., false} (标记是否访问过) dist[start] = 0 创建优先队列 pq，初始时插入 (0, start) (距离为 0 的起点) 2. 当队列 pq 不为空时: a. 从队列中弹出当前距离最近的点 (du, u): (du, u) = pq.pop() if visited[u]: continue 标记 u 为已访问: visited[u] = true b. 遍历 u 的所有相邻点 v: if not visited[v]: 新距离 = dist[u] + weight(u, v) if 新距离 \u0026lt; dist[v]: dist[v] = 新距离 pq.push((dist[v], v)) (将更新后的点加入队列) 3. 返回 dist[] eg:题目描述：给定一个 $n$ 个点、$m$ 条边的有向图，要求计算出点 1 到点 $n$ 的最短距离。 输入描述：第一行：两个整数 $n, m$。 ($1 \\leq n \\leq 10^3, 1 \\leq m \\leq 10^5$)接下来 $m$ 行：每行三个整数 $u_i, v_i, w_i$，表示存在一条从 $u_i$ 到 $v_i$，权值为 $w_i$ 的有向边。 ($1 \\leq u_i, v_i \\leq n, 1 \\leq w_i \\leq 10^6$) 输出描述：一个整数，表示点 1 到点 $n$ 的最短距离；若不存在从点 1 到点 $n$ 的路径，则输出 -1。 朴素dijkstra模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e3 + 9; struct Edge { int x, w; // x表示出点，w表示权值 }; vector\u0026lt;Edge\u0026gt; g[N]; ll d[N], n, m; void dijkstra(int st) { memset(d, 0x3f, sizeof(ll) * (n + 1)); d[st] = 0; bitset\u0026lt;N\u0026gt; vis; // 表示已经到达过的点 for (int i = 1; i \u0026lt;= n; ++i) { // 找出距离源点最近的点 int u = 1; for (int j = 1; j \u0026lt;= n; ++j) { if (vis[u] || (!vis[j] \u0026amp;\u0026amp; d[j] \u0026lt; d[u])) u = j; } vis[u] = true; // 此时d[u]就是最近的点 for (auto \u0026amp;[v, w] : g[u]) { if (!vis[v] \u0026amp;\u0026amp; d[v] \u0026gt; d[u] + w) d[v] = d[u] + w; } } } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; ++i) { int u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; if (u != v) g[u].push_back({v, w}); } dijkstra(1); cout \u0026lt;\u0026lt; (d[n] \u0026gt;= 0x3f3f3f3f ? -1 : d[n]) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 优先队列版dijkstra模板 效率更高\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2e5 + 9; struct Edge { int x, w; // x表示出点，w表示权值 bool operator\u0026lt;(const Edge \u0026amp;v) const { return w == v.w ? x \u0026lt; v.x : w \u0026gt; v.w; // 优先比较权值 权值越大，则越\u0026lt; 则越优先 } }; vector\u0026lt;Edge\u0026gt; g[N]; ll d[N], n, m; void dijkstra(int st) { memset(d, 0x3f, sizeof(ll) * (n + 1)); d[st] = 0; bitset\u0026lt;N\u0026gt; vis; // 表示已经到达过的点 priority_queue\u0026lt;Edge\u0026gt; pq; pq.push({st, d[st]}); //将起点作为待到达的点 while (pq.size())//只要队列里还有等待拓展的点 { int x = pq.top().x; pq.pop(); if (vis[x]) continue;//取出的x点已经得到了最短距离d[x] vis[x] = true; for (auto \u0026amp;[y, w] : g[x]) { if (!vis[y] \u0026amp;\u0026amp; d[y] \u0026gt; d[x] + w) { //若vix[y]说明y的最短距离已经计算过，无需更新 d[y] = d[x] + w; pq.push({y, d[y]}); } } } } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; ++i) { int u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; if (u != v) g[u].push_back({v, w}); } dijkstra(1); cout \u0026lt;\u0026lt; (d[n] \u0026gt;= 0x3f3f3f3f ? -1 : d[n]) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 重点语句分析\n1 return w == v.w ? x \u0026lt; v.x : w \u0026gt; v.w; 对于 w != v.w 的情况：\n如果 w \u0026gt; v.w，返回 true：当前 Edge 被认为“较小”。在大顶堆中，它优先级较低，排后。 如果 w \u0026lt; v.w，返回 false：当前 Edge 被认为“较大”。在大顶堆中，它优先级较高，排前。 优先队列默认是大根堆。 Floyd-Warshall 算法 多源最短路径算法，适用于有向图或无向图，可以处理负权重边，但不能有负权重环。通过动态规划方法计算图中所有顶点对的最短路径。时间复杂度：O(V^3)。\n伪代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 Input: n (点的数量), graph[n][n] (邻接矩阵, 不存在边时值为 ∞) Output: dist[n][n] (任意两点之间的最短距离) 1. 初始化: dist[i][j] = graph[i][j] (直接使用输入图作为初始距离矩阵) dist[i][i] = 0 (自己到自己距离为0,自环时注意) 2. 三重循环: for k = 1 to n: (枚举中间点 k) for i = 1 to n: (枚举起点 i) for j = 1 to n: (枚举终点 j) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]) 3. 返回 dist eg:题目描述：给定一个 $n$ 个点、$m$ 条边的有向图。再给出 $q$ 次询问，每个询问为两个整数 $u_i, v_i$，你需要回答从 $u_i$ 到 $v_i$ 的最短距离。 输入描述：第一行：三个整数 $n, m, q$。 ($1 \\leq n \\leq 300, 1 \\leq m, q \\leq 10^5$)。接下来 $m$ 行：每行三个整数 $u_i, v_i, w_i$，表示存在一条从 $u_i$ 到 $v_i$，权值为 $w_i$ 的有向边。 ($1 \\leq u_i, v_i \\leq n, 0 \\leq w_i \\leq 10^6$)可能存在重边和自环。再接下来 $q$ 行，每行两个整数 $u_i, v_i$，表示查询从 $u_i$ 到 $v_i$ 的最短距离。 输出描述：共 $q$ 行：每行一个整数，表示查询的最短距离；若不存在路径，则输出 -1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 300 + 5; const ll inf = 4e18; ll d[N][N], n, m, q; void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q; memset(d, 0x3f, sizeof d); for (int i = 1; i \u0026lt;= m; ++i) { ll u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; d[u][v] = min(d[u][v], w); // 处理重边 } // 初始化： for (int i = 1; i \u0026lt;= n; ++i) d[i][i] = 0; for (int k = 1; k \u0026lt;= n; ++k) for (int i = 1; i \u0026lt;= n; ++i) for (int j = 1; j \u0026lt;= n; ++j) d[i][j] = min(d[i][j], d[i][k] + d[k][j]); while (q--) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; cout \u0026lt;\u0026lt; (d[u][v] \u0026gt;= inf ? -1 : d[u][v]) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 算法对比 算法 适用场景 时间复杂度 优点 缺点 Dijkstra 朴素数组 小规模稠密图 (边多) (O(n^2)) 实现简单 对稀疏图性能较差 Dijkstra 优先队列 大规模稀疏图 (边少) (O((n+m)\\log n)) 性能优异，适合稀疏图 实现稍复杂 Floyd-Warshall 任意两点的最短路径 (小规模图) (O(n^3)) 直接求解任意两点最短路径矩阵 仅适合小规模图 (点多边少时劣势) 8.最小生成树、质因数分解 最小生成树 最小生成树（MST，Minimum Spanning Tree）是图论中的一个重要问题，它指的是在一个连通加权无向图中选择一些边，使得：图中所有节点都被连接。总边权和最小。不会形成环。\n基于点的最小生成树prim算法 Prim算法是一种贪心算法，它从一个起始点开始，不断将未加入的点以最小代价连接到生成树中，直到所有点都被加入。 思想： 使用一个数组 dist[] 存储生成树到每个点的最小代价。 每次选择 dist[] 中代价最小的点加入生成树。 更新 dist[]，表示当前生成树到未加入点的最小代价。 伪代码实现：无优化的朴素prim\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 Input: 图的邻接矩阵 graph[n][n] (无向图) Output: 最小生成树的权值 sum 1. 初始化: dist[] = {INF, INF, ..., INF} (长度为 n，所有元素为无穷大) intree[] = {false, ..., false} (长度为 n，表示点是否在生成树中) dist[0] = 0 (从节点 0 开始) 2. Prim 算法: sum = 0 (最小生成树的权值) for i = 0 to n-1: u = -1 # 找到未加入生成树的点中，dist 最小的点 for v = 0 to n-1: if !intree[v] and (u == -1 or dist[v] \u0026lt; dist[u]): u = v # 将 u 加入生成树 if dist[u] == INF: return -1 (图不连通) intree[u] = true sum += dist[u] # 更新 dist for v = 0 to n-1: if !intree[v] and graph[u][v] != 0: dist[v] = min(dist[v], graph[u][v]) 3. 返回 sum eg:题目描述：给定一个 $n$ 个点、$m$ 条边的无向带权图，图中可能存在重边和自环。求该图的最小生成树的边权之和，若不存在最小生成树则输出 -1。生成树：对于一个无向图，若它的一个子图是包含该无向图全部顶点的树，那么该子图是该无向图的一个生成树。最小生成树：当连接顶点之间的边有权重时，权重之和最小的生成树则为最小生成树。 输入描述：第一行：两个整数 $n, m$。 ($1 \\leq n \\leq 10^5, 1 \\leq m \\leq 10^5$)。接下来 $m$ 行：每行三个整数 $u_i, v_i, w_i$，表示点 $u_i$ 和点 $v_i$ 之间存在一条权重为 $w_i$ 的无向边。 ($1 \\leq u_i, v_i \\leq n, 0 \\leq w_i \\leq 10^6$) 输出描述：共一行，若存在最小生成树，则输出一个整数，表示最小生成树的边权之和；否则，输出 -1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e3 + 9; ll a[N][N], d[N]; // a是邻接矩阵，d是到i点的最短距离 bitset\u0026lt;N\u0026gt; intree; // 表示i节点是否放入树内 void solve() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; memset(d, 0x3f, sizeof d); memset(a, 0x3f, sizeof a); for (int i = 1; i \u0026lt;= n; ++i) a[i][i] = 0; for (int i = 1; i \u0026lt;= m; ++i) { ll u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; a[u][v] = min(a[u][v], w); a[v][u] = min(a[v][u], w); } ll ans = 0; d[1] = 0; intree[1] = true; // 起始点1，开始更新不在树内的点距离树内起始点1的最短距离 for (int j = 1; j \u0026lt;= n; ++j) { if (intree[j]) continue; d[j] = min(d[j], a[1][j]); } for (int i = 1; i \u0026lt; n; ++i) { int u = 1; // u是我们要找的距离树内任意一点最近的点 for (int j = 1; j \u0026lt;= n; ++j) { if (intree[u] || (!intree[j] \u0026amp;\u0026amp; d[j] \u0026lt; d[u])) u = j; } ans += d[u]; intree[u] = true; d[u] = 0; for (int j = 1; j \u0026lt;= n; ++j) { // 更新当前不在树内的点距离树内任意一点的最短距离 if (intree[j]) continue; d[j] = min(d[j], a[u][j]); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 伪代码实现：堆优化的prim 使用最小堆代替朴素算法中遍历 dist[] 的操作，加速最小代价点的选择过程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 Input: 图的邻接表 graph Output: 最小生成树的权值 sum 1. 初始化: dist[] = {INF, INF, ..., INF} (长度为 n，所有元素为无穷大) visited[] = {false, ..., false} dist[0] = 0 (从节点 0 开始) 创建最小堆 pq，插入 (0, 0) (格式为 (代价, 节点)) 2. Prim 算法: sum = 0 while pq 不为空: (cost, u) = pq.top() pq.pop() # 如果 u 已经在生成树中，跳过 if visited[u]: continue # 将 u 加入生成树 visited[u] = true sum += cost # 更新邻接点 for (v, weight) in graph[u]: if !visited[v] and dist[v] \u0026gt; weight: dist[v] = weight pq.push((dist[v], v)) 3. 返回 sum eg:题目描述：给定一个 $n$ 个点、$m$ 条边的无向带权图，图中可能存在重边和自环。求该图的最小生成树的边权之和，若不存在最小生成树则输出 -1。生成树：对于一个无向图，若它的一个子图是包含该无向图全部顶点的树，那么该子图是该无向图的一个生成树。最小生成树：当连接顶点之间的边有权重时，权重之和最小的生成树则为最小生成树。 输入描述：第一行：两个整数 $n, m$。 ($1 \\leq n \\leq 10^5, 1 \\leq m \\leq 10^5$)。接下来 $m$ 行：每行三个整数 $u_i, v_i, w_i$，表示点 $u_i$ 和点 $v_i$ 之间存在一条权重为 $w_i$ 的无向边。 ($1 \\leq u_i, v_i \\leq n, 0 \\leq w_i \\leq 10^6$) 输出描述：共一行，若存在最小生成树，则输出一个整数，表示最小生成树的边权之和；否则，输出 -1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e3 + 9; ll d[N]; // d是到i点的最短距离 struct Edge { ll x, w; bool operator\u0026lt;(const Edge \u0026amp;u) const { return w == u.w ? x \u0026lt; u.x : w \u0026gt; u.w; } }; vector\u0026lt;Edge\u0026gt; g[N]; // 用结构体来存图 bitset\u0026lt;N\u0026gt; intree; // 表示i节点是否放入树内 void solve() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; memset(d, 0x3f, sizeof d); for (int i = 1; i \u0026lt;= m; ++i) { ll u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; g[u].push_back({v, w}); g[v].push_back({u, w}); } ll ans = 0; priority_queue\u0026lt;Edge\u0026gt; pq; // 用优先队列来判断距离intree最近的点 pq.push({1, 0}); d[1] = 0; while (pq.size()) { int x = pq.top().x; pq.pop(); if (intree[x]) continue; intree[x] = true; ans += d[x]; // 枚举所有出边 for (auto \u0026amp;[y, w] : g[x]) if (!intree[y] \u0026amp;\u0026amp; w \u0026lt; d[y]) { d[y] = w; pq.push({y, w}); } } for (int i = 1; i \u0026lt;= n; ++i) if (!intree[i]) ans = -1; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 基于边的最小生成树kruskal算法 Kruskal算法是一种基于边的贪心算法，每次选择权值最小的边加入生成树，同时避免形成环。 一般情况下用的最多的是kruskal 思想： 将所有边按权值升序排序。 遍历排序后的边，使用并查集判断当前边是否会形成环。 如果不会形成环，就将该边加入生成树。 伪代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 Input: 边列表 edges[]，节点数 n Output: 最小生成树的权值 sum 1. 初始化: 使用并查集: parent[] = {0, 1, 2, ..., n-1} (每个点的父节点初始化为自己) size[] = {1, 1, 1, ..., 1} (每个点所在连通块的大小) 定义 find(x): 查找 x 的根 if parent[x] != x: parent[x] = find(parent[x]) return parent[x] 定义 union(x, y): 合并 x 和 y 所在连通块 root_x = find(x) root_y = find(y) if root_x != root_y: if size[root_x] \u0026lt; size[root_y]: swap(root_x, root_y) parent[root_y] = root_x size[root_x] += size[root_y] 2. Kruskal 算法: sum = 0 (最小生成树的权值) edge_count = 0 (生成树中边的数量) 将 edges[] 按权值升序排序 for (u, v, weight) in edges: if find(u) != find(v): union(u, v) sum += weight edge_count += 1 if edge_count == n - 1: break 3. 如果 edge_count \u0026lt; n - 1: return -1 (图不连通) 否则: return sum eg:题目描述：给定一个 $n$ 个点、$m$ 条边的无向带权图，图中可能存在重边和自环。求该图的最小生成树的边权之和，若不存在最小生成树则输出 -1。生成树：对于一个无向图，若它的一个子图是包含该无向图全部顶点的树，那么该子图是该无向图的一个生成树。最小生成树：当连接顶点之间的边有权重时，权重之和最小的生成树则为最小生成树。 输入描述：第一行：两个整数 $n, m$。 ($1 \\leq n \\leq 10^5, 1 \\leq m \\leq 10^5$)。接下来 $m$ 行：每行三个整数 $u_i, v_i, w_i$，表示点 $u_i$ 和点 $v_i$ 之间存在一条权重为 $w_i$ 的无向边。 ($1 \\leq u_i, v_i \\leq n, 0 \\leq w_i \\leq 10^6$) 输出描述：共一行，若存在最小生成树，则输出一个整数，表示最小生成树的边权之和；否则，输出 -1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e3 + 9; ll d[N]; // d是到i点的最短距离 struct Edge { ll u, v, w; bool operator\u0026lt;(const Edge \u0026amp;m) const { if (w != m.w) return w \u0026lt; m.w; if (u != m.u) return u \u0026lt; m.u; return v \u0026lt; m.v; } }; int pre[N]; int root(int x) { return pre[x] = (pre[x] == x ? x : root(pre[x])); } void solve() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; memset(d, 0x3f, sizeof d); vector\u0026lt;Edge\u0026gt; es; for (int i = 1; i \u0026lt;= m; ++i) { ll u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; es.push_back({u, v, w}); } sort(es.begin(), es.end()); ll ans = 0; for (int i = 1; i \u0026lt;= n; ++i) pre[i] = i; // 并查集初始化 for (auto \u0026amp;[u, v, w] : es) { if (root(u) == root(v)) continue; ans += w; pre[root(u)] = root(v); } for (int i = 1; i \u0026lt; n; ++i) if (root(i) != root(i + 1)) ans = -1; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 质因数分解 质数（素数）判断 模板\n1 2 3 4 5 6 7 8 9 10 11 12 int n;//待判断目标 checkPrime(n) { if (n \u0026lt; 2) return false; for (int i = 2i; i \u0026lt;= n / i; ++i) { if (n % i == 0) return false; } return true; } 求N的所有因数 分析：设a,b是N的因子则 [ N = a \\times b \\quad (设a \\leq b) ] 所以： [ a \\leq \\sqrt{N} \\leq b ] 则令： [b = \\frac{N}{a} ] 枚举a即可 模板题 eg：题目描述： 给定一个数字 $n$，请从小到大输出 $n$ 的所有因子。 输入描述：一个整数 $n$。 ($1 \\leq n \\leq 10^{12}$) 输出描述：一行从小到大输出 $n$ 的所有因子。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e12; void solve() { ll n; cin \u0026gt;\u0026gt; n; vector\u0026lt;ll\u0026gt; v; for (ll i = 1; i \u0026lt;= n / i; ++i) { if (n % i) continue; v.push_back(i); if (i != n / i) v.push_back(n / i); } sort(v.begin(), v.end()); for (auto \u0026amp;i : v) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 求N的所有质因子 模板题 eg：题目描述： 给定一个数字 $n$，请从小到大输出 $n$ 的所有质因子。 输入描述：一个整数 $n$。 ($1 \\leq n \\leq 10^{12}$) 输出描述：一行从小到大输出 $n$ 的所有质因子。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e12; void solve() { ll n; cin \u0026gt;\u0026gt; n; vector\u0026lt;ll\u0026gt; v; for (ll i = 2; i \u0026lt;= n / i; ++i) { if (n % i) continue; v.push_back(i); while (n % i == 0) n /= i; // 将i除干净 } if (n \u0026gt; 1) v.push_back(n); sort(v.begin(), v.end()); for (auto \u0026amp;i : v) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 9.埃氏筛法、gcd和lcm、快速幂、乘法逆元 埃氏筛法 埃氏筛法（Sieve of Eratosthenes）是一种高效计算范围内所有素数的经典算法。其基本思想是通过标记合数来筛选出素数，用于找出一个指定整数范围内的所有素数。这个算法的基本思想是：从最小的素数2开始，逐步标记其倍数为非素数，然后找到下一个未被标记的数，继续标记其倍数为非素数，如此反复，直到处理完所有小于或等于给定数的平方根的数。 埃氏筛法的步骤： 创建一个列表：包含从2到n的所有整数，其中n是要找出素数的范围。 初始化：将2标记为素数。 筛选：从2的下一个数开始，如果该数未被标记为非素数，则将其标记为素数，并将其所有倍数标记为非素数。 重复：重复步骤3，直到处理完所有小于或等于n的平方根的数。 输出：所有未被标记为非素数的数即为素数。 伪代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 埃氏筛法(n): # 创建一个布尔数组，长度为 n+1 初始化布尔数组 is_prime[0..n] 为 true # 0 和 1 不是素数 is_prime[0] = false is_prime[1] = false # 从 2 开始，逐步筛选 for i 从 2 到 √n: 如果 is_prime[i] 为 true: # 将 i 的所有倍数标记为非素数 for j 从 i*i 到 n，步长为 i: is_prime[j] = false # 遍历布尔数组，输出所有素数 for k 从 2 到 n: 如果 is_prime[k] 为 true: 输出 k 模板题 eg:题目描述:给定一个整数 $n$，求 $[1, n]$ 的所有质数。 输入格式:一个整数 $n$。 ($1 \\leq n \\leq 2 \\times 10^6$) 输出格式按照从小到大的顺序输出答案。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2e6 + 9; int n; bitset\u0026lt;N\u0026gt; vis; void solve() { cin \u0026gt;\u0026gt; n; vis[0] = vis[1] = true; for (ll i = 2; i \u0026lt;= n; ++i) { if (!vis[i]) for (ll j = 2 * i; j \u0026lt;= n; j += i) { vis[j] = true; } } for (int i = 1; i \u0026lt;= n; ++i) { if (!vis[i]) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } gcd和lcm 理论基础： 唯一分解定理，也称为算术基本定理，是数论中的一个基本定理。它指出，任何一个大于1的自然数 n 都可以写成素数的乘积形式，并且这种分解方式是唯一的，不考虑因子的顺序。 GCD与唯一分解定理 最大公约数是两个或多个整数共有的最大的能整除它们的正整数。根据唯一分解定理，任何整数都可以唯一地分解为素数的乘积。因此，两个数的GCD可以通过比较它们的素因子来确定：\n分解：将两个数分别分解为素数的乘积。 公共素因子：找出两个分解中相同的素因子。 计算GCD：将这些公共素因子的指数取最小值，然后将它们相乘。 LCM与唯一分解定理 最小公倍数是两个或多个整数的最小的公共倍数。利用唯一分解定理，我们可以类似地计算LCM： 分解：将两个数分别分解为素数的乘积。 公共素因子和独有素因子：找出两个分解中相同的素因子和不同的素因子。 计算LCM：将所有素因子的最高指数相乘。 欧几里得算法 给定两个正整数 $a, b \\in \\mathbb{N}$，且 $a \\leq b$，则它们的最大公约数可以表示为： $$ \\gcd(a, b) = \\gcd(a, b - a) $$ 伪代码实现(gcd的原理/手写gcd函数) 1 2 function gcd(a, b): { return b == 0 ? a : gcd(b, a % b); } 注：c++库函数里有__gcd(a,b)函数 即上述实现 贝祖等式: 它表明两个整数 (a) 和 (b) 的乘积等于它们的最大公约数（GCD）和最小公倍数（LCM）的乘积，这个性质可以用以下的数学公式表示： [ a \\times b = \\gcd(a, b) \\times \\text{lcm}(a, b) ] 伪代码实现（lcm的原理/手写lcm函数）\n1 2 function lcm(a,b): { return a / __gcd(a, b) * b; } eg:题目描述：给定两个正整数 $a, b$，求 $gcd(a, b)$ 和 $lcm(a, b)$。$gcd(a, b)$ 表示 $a, b$ 的最大公因数。$lcm(a, b)$ 表示 $a, b$ 的最小公倍数。 输入描述：第一行输入一个整数 $T$，表示样例的个数。 ($1 \\leq T \\leq 10^5$)。对于每个样例，两个整数 $a, b$。 ($1 \\leq a, b \\leq 2 \\times 10^9$) 输出描述：对于每一个样例，在一行输出两个整数表示 $gcd$ 和 $lcm$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e5 + 9; ll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); } ll lcm(ll a, ll b) { return a / gcd(a, b) * b; } void solve() { int q; cin \u0026gt;\u0026gt; q; while (q--) { ll a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; cout \u0026lt;\u0026lt; gcd(a, b) \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; lcm(a, b) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 快速幂 快速幂（也称为快速指数或幂运算）是一种用于高效计算指数运算的算法，其中 a 是底数，b 是指数。这个算法特别适用于指数 b 非常大时的情况。快速幂算法利用了指数的二进制表示，通过将指数分解为2的幂的和，从而减少乘法的次数。 快速幂算法的原理 快速幂算法基于以下数学原理：\n指数分解：任何正整数 $b$ 都可以表示为 2 的幂的和，即 $b = 2^0 + 2^1 + 2^2 + \\ldots + 2^k$。 幂的乘法： $a^b = a^{2^0} \\times a^{2^1} \\times a^{2^2} \\times \\ldots \\times a^{2^k}$。 步骤\n初始化结果： $res = 1$。 平方和乘法：当 $b \u0026gt; 0$ 时，执行以下步骤： 如果 $b$ 是奇数，将当前的 $a$ 值乘以结果 $res$。 将 $a$ 平方（即 $a = a \\times a$）。 将 $b$ 右移一位（即 $b = b / 2$）。 伪代码实现\n1 2 3 4 5 6 7 8 function fast_pow(a, b): res = 1 while b \u0026gt; 0: if b % 2 == 1: res = res * a a = a * a b = b / 2 return res eg:题目描述：本题有 $T$ 组测试样例。给定三个整数 $a, b, c$，求： [ a^b \\mod c ] 输入格式：第一行输入一个整数 $T$。 ($1 \\leq T \\leq 1000$) 对于每组样例一行给出三个整数 $a, b, c$。 ($1 \\leq a, b, c \\leq 10^9$) 输出格式：一个整数表示答案。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e9 + 9; ll fast_pow(ll a, ll b, ll c) { ll res = 1; while (b) { if (b % 2) res *= a % c; a *= a % c; b \u0026gt;\u0026gt;= 1; } // 这部分其实和伪代码是相同语义 只是位运算更快一点 return res; } void solve() { ll a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; cout \u0026lt;\u0026lt; fast_pow(a, b, c) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _; cin \u0026gt;\u0026gt; _; while (_--) solve(); return 0; } 乘法逆元 看到取模就有可能用逆元 用来控制数据规模 理论基础： 乘法逆元是数论中的一个概念，指的是在模运算中，一个数 $a$ 的乘法逆元是一个数 $b$，使得 $a \\times b \\mod{m}\\equiv 1 $。换句话说，$b$ 是 $a$ 在模 $m$ 下的逆，当且仅当 $a$ 和 $b$ 的乘积对 $m$ 取模后等于 1。 费马小定理 费马小定理指出，如果 $p$ 是一个质数，$a$ 是一个整数，(p是质数且a不是p的倍数)并且 $a$ 不能被 $p$ 整除，那么 $a^{p-1} \\equiv 1 \\pmod{p}$。这个定理可以推广到 $a^p \\equiv a \\pmod{p}$。 费马小定理与乘法逆元的关系 根据费马小定理，我们可以得出 $a^{p-2} \\equiv a^{-1} \\pmod{p}$，这意味着 $a^{p-2}$ 实际上是 $a$ 模 $p$ 的乘法逆元。因此，如果 $p$ 是质数，且 $a$ 不能被 $p$ 整除，那么 $a$ 模 $p$ 的乘法逆元就是 $a^{p-2}$。而 $a^{p-2}$可以通过之前学习过的快速幂来求得。 伪代码实现：费马小定理求逆元\n1 2 3 4 5 function mod_inverse(a, p): if gcd(a, p) != 1: return \u0026#34;No inverse exists\u0026#34; // a 和 p 不互质，没有逆元 else: return fast_pow(a, p - 2, p) // 使用快速幂算法计算 a^(p-2) mod p eg： 题目描述：给定一个函数形式:[ f(x) = \\frac{ax + b}{cx} ] 本题有 $T$ 组测试样例，对于每组样例：给定三个整数表示 $a, b, c$ 用于确定函数，然后有 $q$ 次询问，每次询问一个点的函数值。结果对 998244353 取模。 输入格式：第一行一个整数 $T$，表示样例数。 ($1 \\leq T \\leq 10$)。对于每个样例：第一行四个整数 $a, b, c, q$。 ($1 \\leq a, b, c \\leq 10^9, 1 \\leq q \\leq 10^4$)。接下来 $q$ 行，每行一个整数表示询问点 $x_i$。 ($1 \\leq x \\leq 10^9$) 输出格式：对于每次询问，一个整数表示取模后的结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e9 + 9; const ll p = 998244353; ll fast_pow(ll a, ll b) { ll res = 1; while (b) { if (b % 2) res = res * a % p; a = a * a % p; b \u0026gt;\u0026gt;= 1; } return res; } ll inv(ll x) // 费马小定理求逆元 { return fast_pow(x, p - 2); } ll f(ll a, ll b, ll c, ll x) { return (a * x % p + b) % p * inv(c * x % p) % p; //%p是为了缩小数据量 若不模已经到1e18了 而在数学角度上对于 } void solve() { ll a, b, c, q; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; q; while (q--) { ll x; cin \u0026gt;\u0026gt; x; cout \u0026lt;\u0026lt; f(a, b, c, x) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _; cin \u0026gt;\u0026gt; _; while (_--) solve(); return 0; } 10.组合数、01背包、完全背包 组合数 组合数，也称为二项式系数，表示为 $C(n, m)$ 或 $\\binom{n}{m}$，是指从 $n$ 个不同元素中选取 $m$ 个元素的组合方式数量，不考虑选取的顺序。组合数的计算公式是： [ C(n, m) = \\frac{n!}{m!(n-m)!} ] 伪代码实现上公式\n1 2 3 4 5 6 7 8 9 long long combination(int n, int m) { if (m \u0026gt; n) return 0; if (m \u0026gt; n - m) m = n - m; long long result = 1; for (int i = 1; i \u0026lt;= m; ++i) { result = result * (n - i + 1) / i; } return result; } 组合数的性质\n对称性：$C(n, m) = C(n, n-m)$。从 $n$ 个元素中选取 $m$ 个元素的方式数与选取 $n-m$ 个元素的方式数相同。 边界条件：$C(n, 0) = C(n, n) = 1$。选取 0 个或全部 $n$ 个元素的方式只有一种。 帕斯卡恒等式：$C(n, m) = C(n-1, m) + C(n-1, m-1)$。这个恒等式表明，从 $n$ 个元素中选取 $m$ 个元素的方式数等于从 $n-1$ 个元素中选取 $m$ 个元素的方式数加上从 $n-1$ 个元素中选取 $m-1$ 个元素的方式数。 eg:题目描述：给定两个整数 $n, m$，求一个大小 $n \\times m$ 的矩阵，其中第 $i$ 行，第 $j$ 列的元素为 $C(i, j)$。 $C(i, j)$ 表示从 $i$ 个不同的物品中选出 $j$ 个的方案数。 注意，这里的行列均为 0-index，即下标从 0 开始计数。结果对 $1e9 + 7$ 取模。 输入格式：两个整数 $n, m$。 ($1 \\leq n, m \\leq 10^3$) 输出格式：一个 $n \\times m$ 的整数矩阵表示答案。 朴素方法（递归求解）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int p = 1e9 + 7; const int N = 1e3 + 5; ll c[N][N]; void solve() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; n; ++i) c[i][0] = 1ll; for (int i = 1; i \u0026lt; n; ++i) for (int j = 1; j \u0026lt;= i \u0026amp;\u0026amp; j \u0026lt; m; ++j) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % p; for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; m; ++j) { cout \u0026lt;\u0026lt; c[i][j] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 又因为[ C(n, m) = \\frac{n!}{m!(n-m)!} ] 所以在进行取模情境下，可以对分母部分转化为逆元进行处理，结合快速幂和求逆元来做，如下题所示。 伪代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 function mod_inverse(a, p):// 使用扩展欧几里得算法求逆元 gcd, x, _ = extended_gcd(a, p) if gcd != 1: return -1 // 无逆元 else: return x % p // 模 p 下的逆元 function fast_pow(a, b, p):// 快速幂 result = 1 a = a % p while b \u0026gt; 0: if b % 2 == 1: result = (result * a) % p a = (a * a) % p b = b // 2 return result function combination(n, m, p)://组合数 if m \u0026gt; n: return 0 分母 = 1 for i from 1 to m: 分子 = (分子 * (n - i + 1)) % p 分母 = (分母 * i) % p 逆元分母 = 求逆元(分母, p) 返回 (分子 * 逆元分母) % p eg: 题目描述：有 $q$ 次询问，每次给出两个整数 $n, m$，求 $C(n, m)$。$C(n, m)$ 表示从 $n$ 个不同的物品中选出 $m$ 个的方案数。结果对 $1e9 + 7$ 取模。 输入格式：第一行一个整数 $q$。 ($1 \\leq \\leq 10^5$) 对于每个询问，两个整数 $n, m$。 ($1 \\leq m \\leq n \\leq 10^7$) 输出格式：对于每次询问，输出一个整数表示答案。 模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int p = 1e9 + 7; const int N = 1e7 + 3; ll fac[N]; ll quickMi(ll a, ll b) // 快速幂 { ll res = 1; while (b) { if (b % 2) res = res * a % p; a = a * a % p; b = b / 2; } return res; } ll inv(ll x) { return quickMi(x, p - 2); } // 快速幂求逆元 void init(int n) // 求阶乘 { fac[0] = 1; for (int i = 1; i \u0026lt;= n; ++i) fac[i] = fac[i - 1] * i % p; } ll C(ll n, ll m) { if (n \u0026lt; 0 || m \u0026lt; 0 || n \u0026lt; m) return 0; return fac[n] * inv(fac[n - m] * fac[m] % p) % p; } void solve() { init(1e7); ll n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; cout \u0026lt;\u0026lt; C(n, m) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _; cin \u0026gt;\u0026gt; _; while (_--) solve(); return 0; } 0-1背包 问题描述 给定:\n$n$ 个物品，每个物品有重量 $w_i$ 和价值 $v_i$。 背包的容量为 $W$。 要求: 选择一些物品放入背包，使得背包中物品的总重量不超过 $W$，且总价值最大。 步骤： 1.状态定义：定义 $dp[i][j]$ 为考虑前 $i$ 个物品，背包容量为 $j$ 时的最大价值。确定边界 2.初始化\n$dp[0][j] = 0$ 对于所有 $j$，因为没有物品时价值为 0。 $dp[i][0] = 0$ 对于所有 $i$，因为容量为 0 时无法放置任何物品。 3.找状态转移方程： 对于每个物品 $i$ 和每个容量 $j$:\n[ dp[i][j] = \\max(dp[i-1][j], dp[i-1][j-w_i] + v_i) ]\n如果不选择第 $i$ 个物品，则最大价值为 $dp[i-1][j]$。 如果选择第 $i$ 个物品，则最大价值为 $dp[i-1][j-w_{i}] + v_{i}$，前提是 $j \\geq w_{i}$。 4.按顺序计算：按物品 $i$ 和容量 $j$ 从小到大的顺序计算 $dp[i][j]$。\n伪代码实现\n1 2 3 4 5 6 7 8 9 function knapsack(W, w[], v[], n): 创建二维数组 dp，大小为 (n+1) x (W+1)，初始值为 0 for i from 1 to n: for j from 1 to W: if w[i-1] \u0026gt; j: dp[i][j] = dp[i-1][j] else: dp[i][j] = max(dp[i-1][j], dp[i-1][j - w[i-1]] + v[i-1]) return dp[n][W] eg： 题目描述：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。” 你能完成这个任务吗？ 输入描述：输入的第一行有两个整数 $T (1 \\leq T \\leq 1000)$ 和 $M (1 \\leq M \\leq 100)$，$T$ 代表总共能够用来采药的时间，$M$ 代表山洞里的草药的数目。 接下来的 $M$ 行每行包括两个在 1 到 100 之间（包括 1 和 100）的整数，分别表示采摘某株草药的时间和这株草药的价值。 输出描述：可能有多组测试数据，对于每组数据：输出只包括一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。\n滚动数组优化 滚动数组优化，也称为空间优化，是动态规划中的一种技术，用于减少算法的空间复杂度。在0-1背包问题中，因为实际每次参与计算的只有当前的这行和它的上一行我们可以通过只存储当前行和上一行的值来优化空间复杂度，从而降低空间复杂度。 伪代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 函数 solve(): // 初始化 dp 数组 将 dp 的所有元素初始化为 0 // 输入每株草药的时间和价值 对于 i 从 1 到 M: 读取 t[i] 和 v[i] // 动态规划 对于 i 从 1 到 M: // 遍历每一株草药 current = i \u0026amp; 1 // 当前行 previous = 1 - current // 上一行 对于 j 从 0 到 T: // 遍历每个时间限制 如果 j \u0026gt;= t[i]: // 如果当前时间能采这株草药 dp[current][j] = max(dp[previous][j], dp[previous][j - t[i]] + v[i]) 否则: // 当前时间不足以采这株草药 dp[current][j] = dp[previous][j] return dp[M \u0026amp; 1][T] // 最终结果存储在最后一行对应的列中 eg:同上题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e3 + 5; ll T, M; ll t[N], v[105]; ll dp[2][1010]; void solve() { memset(dp, 0, sizeof(dp)); // 初始化 for (int i = 1; i \u0026lt;= M; ++i) cin \u0026gt;\u0026gt; t[i] \u0026gt;\u0026gt; v[i]; for (int i = 1; i \u0026lt;= M; ++i) { int current = i \u0026amp; 1; // 表示当前行 1-current即零一行 for (int j = 0; j \u0026lt;= T; ++j) {//滚动数组优化： if (j \u0026gt;= t[i]) dp[current][j] = max(dp[1 - current][j], dp[1 - current][j - t[i]] + v[i]); else dp[current][j] = dp[1 - current][j]; } } cout \u0026lt;\u0026lt; dp[M \u0026amp; 1][T] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); while (cin \u0026gt;\u0026gt; T \u0026gt;\u0026gt; M) { if (T == 0 \u0026amp;\u0026amp; M == 0) break; solve(); } return 0; } 无穷/完全背包 问题描述给定:\n$n$ 个物品，每个物品有重量 $w_i$ 和价值 $v_i$。 背包的容量为 $W$。 要求:\n选择一些物品放入背包，使得背包中物品的总重量不超过 $W$，且总价值最大。 步骤：\n1.状态定义：定义 $dp[j]$ 为背包容量为 $j$ 时的最大价值。 2.初始化： $dp[0] = 0$：背包容量为0时，价值为0。 3.状态转移方程：对于每个物品 $i$ 和每个容量 $j$:\n[ dp[j] = \\max(dp[j], dp[j - w_i] + v_i) ]\n这个状态转移方程意味着，对于每个物品，你可以选择不放它、放1个、放2个……直到背包容量允许的最大数量。因此，你需要检查所有可能的数量，更新 $dp[j]$ 的值。 4.计算：按物品 $i$ 和容量 $j$ 从小到大的顺序计算 $dp[j]$。 为代码实现：\n1 2 3 4 5 6 function unbounded_knapsack(W, w[], v[], n): 创建一维数组 dp，大小为 W + 1，初始值为 0 for i from 1 to n: for j from w[i - 1] to W: dp[j] = max(dp[j], dp[j - w[i - 1]] + v[i - 1]) return dp[W] eg：题目描述:小e的背包容量为 $m$，现在商店里有 $n$ 种商品。由于在梦境中，他可以零元购，商店里的每种商品都有无穷件，每件商品有一个价值 $w_i$ 和体积 $v_i$。问小e最多可以带走多少价值的商品？ 输入格式:第一行两个整数表示 $m, n$。 ($1 \\leq m \\leq 10^5, 1 \\leq n \\leq 500$)接下来 $n$ 行，每行两个整数表示 $w_i, v_i$。 ($1 \\leq w_i \\leq 10^9, 1 \\leq v_i \\leq m$) 输出格式:一行一个整数表示答案。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 505; const int M = 1e5 + 5; ll m, n; ll dp[M]; ll w[N], v[N]; void solve() { memset(dp, 0, sizeof(dp)); cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; w[i] \u0026gt;\u0026gt; v[i]; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 0; j \u0026lt;= m; ++j) { dp[j] = max(dp[j], dp[j - v[i] + w[i]]); } } cout \u0026lt;\u0026lt; dp[m] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 分析背包问题的时候要注意状态转换是从当前行还是上一行\n11.多重背包的二进制优化、单调栈二分dp 多重背包的二进制优化 多重背包 多重背包问题是一种经典的动态规划问题，它与0-1背包问题类似，但区别在于多重背包问题中每种物品可以选取多次，而0-1背包问题中每种物品只能选取一次或不选取。\neg： 题目描述：小e的背包容量为 $m$，现在商店里有 $n$ 种商品。由于在梦境中，他可以零元购，但商品的数量有限，第 $i$ 种商品最多可以购买 $s_i$ 件，每件商品有一个价值 $w_i$ 和体积 $v_i$。请问小e最多可以带走多少价值的商品？ 输入描述：第一行：两个整数 $m, n$，表示背包容量、商品种数。 ($1 \\leq m, n \\leq 100$)接下来 $n$ 行：每行三个整数 $s_i, w_i, v_i$，表示第 $i$ 种商品的件数、价值、体积。 ($0 \\leq s_i, w_i, v_i \\leq 100$) 输出描述：一个整数，表示小e能带走的最大价值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 100 + 9; ll dp[N * N]; int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); ll m, n; cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) { ll s, w, v; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; w \u0026gt;\u0026gt; v; while (s--) // 跑s次0-1背包 { for (int j = m; j \u0026gt;= v; --j) dp[j] = max(dp[j], dp[j - v] + w); } } cout \u0026lt;\u0026lt; dp[m] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 上题解在数据量较小时可以满足要求，数据量变大后由于for（while（for））的时间复杂度太高，会超时。\n多重背包的二进制优化 多重背包问题的二进制优化是一种将问题转化为 01 背包问题的方法，其核心思想是利用二进制表示法将每个物品的数量拆分成多个 1 的倍数，从而减少状态的数量，提高算法效率。 多重背包问题二进制优化的原理 对于一个物品，如果它有 $s$ 个，我们可以将其拆分成 1, 2, 4, 8, \u0026hellip; 直到 $2^k - 1$（其中 $k$ 是满足 $2^k - 1 \\leq s$ 的最大整数），这样就能表示出 0 到 $s$ 的所有数量。这种方法可以减少物品数量的表示范围，从而将多重背包问题转化为 01 背包问题。 算法步骤\n二进制拆分：对于每个物品，根据其数量 $s$，使用二进制表示法将其拆分成多个 1 的倍数。例如，如果一个物品有 10 个，可以拆分成 1+2+4+3。 状态转移：将拆分后的物品视为 01 背包问题中的不同物品，使用动态规划求解。对于每个物品，从背包的最大容量向下遍历，更新 dp 数组。 代码实现：在代码中，首先对每个物品进行二进制拆分，然后使用 01 背包的状态转移方程求解。 题目描述：小e的背包容量为 $m$，现在商店里有 $n$ 种商品。由于在梦境中，他可以零元购，但商品的数量有限，第 $i$ 种商品最多可以购买 $s_i$ 件，每件商品有一个价值 $w_i$ 和体积 $v_i$。请问小e最多可以带走多少价值的商品？ 输入描述：第一行：两个整数 $m, n$，表示背包容量、商品种数。 ($1 \\leq m, n \\leq 2000$)接下来 $n$ 行：每行三个整数 $s_i, w_i, v_i$，表示第 $i$ 种商品的件数、价值、体积。 ($0 \\leq s_i, w_i, v_i \\leq 2000$) 输出描述：一个整数，表示小e能带走的最大价值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2000 + 9; ll dp[N]; int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); ll m, n; cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) { ll s, w, v; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; w \u0026gt;\u0026gt; v; vector\u0026lt;ll\u0026gt; vec; int x = 1; while (s \u0026gt;= x) // 进行二进制优化： { vec.push_back(x); s -= x; x \u0026lt;\u0026lt;= 1; } if (s) vec.push_back(s); for (auto \u0026amp;k : vec) { for (int j = m; j \u0026gt;= k * v; --j) dp[j] = max(dp[j], dp[j - k * v] + k * w); } } cout \u0026lt;\u0026lt; dp[m] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 12.DP分类与精讲线性dp、区间dp、树形dp 动态规划（DP）是算法中一种常见且重要的思想，应用广泛。以下是常见的动态规划分类以及其特点和典型应用：\n1. 线性 DP** 特点：\n问题可以分解为一个线性顺序的子问题，状态之间按照序列关系转移。 主要处理具有顺序性和前后依赖关系的问题。 状态定义：\n一般定义为 dp[i]，表示前 i 个状态的最优解，或者以第 i 个元素为结尾/起点的子问题最优解。 典型问题： 最长上升子序列（LIS）、最长公共子序列（LCS）、背包问题（0-1 背包、完全背包、分组背包）、股票交易问题、最大子序和\n最长上升子序列模板\n1 2 3 4 5 6 7 for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt; i; ++j) { if (nums[j] \u0026lt; nums[i]) { dp[i] = max(dp[i], dp[j] + 1); } } } eg: 题目描述:给定一个长度为 $n$ 的数组 $a$，求其最长上升（非降）子序列的长度。 注意：子序列不一定是连续的。 输入描述: 第一行：一个整数 $n$。 ($1 \\leq n \\leq 10^3$) 第二行：$n$ 个整数，表示 $a_1, a_2, \\ldots, a_n$。 ($1 \\leq a_i \\leq 10^9$) 输出描述:一个整数，表示答案。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e3 + 9; int n; ll a[N], dp[N]; void solve() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n; ++i) { dp[i] = 1; for (int j = 1; j \u0026lt; i; ++j) { if (a[j] \u0026lt;= a[i]) dp[i] = max(dp[i], dp[j] + 1); } } ll ans = 0; for (int i = 1; i \u0026lt;= n; ++i) ans = max(ans, dp[i]); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 数组单调栈二分优化： 实际上栈中的每个元素是一个索引 i，它表示数组 nums[i] 是当前最长上升子序列的一个结尾元素。 单调栈优化LIS的原理:\n单调栈维护：使用一个栈来维护当前找到的最长上升子序列。栈内的元素是递增的，即栈底到栈顶是严格递增的序列。 遍历数组：遍历给定的数组，对于每个元素，有两种情况：如果当前元素大于栈顶元素，说明当前元素可以接在栈顶元素后面形成更长的上升子序列，因此将当前元素入栈;如果当前元素小于或等于栈顶元素，说明需要在栈中找到一个合适的位置来替换栈顶元素，使得栈仍然保持单调递增。这可以通过二分查找来实现，找到栈中第一个大于当前元素的位置，并用当前元素替换该位置的元素。 更新栈：通过上述步骤，栈的长度即为最长上升子序列的长度。 eg: 题目描述:给定一个长度为 $n$ 的数组 $a$，求其最长上升（非降）子序列的长度。 注意：子序列不一定是连续的。 输入描述: 第一行：一个整数 $n$。 ($1 \\leq n \\leq 2×10^5$) 第二行：$n$ 个整数，表示 $a_1, a_2, \\ldots, a_n$。 ($1 \\leq a_i \\leq 10^9$) 输出描述:一个整数，表示答案。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2e5 + 9; int n; ll a[N], stk[N], top; void solve() { cin \u0026gt;\u0026gt; n; ll ans = 0; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n; ++i) { // 找最后一个 \u0026lt;= a[i]的位置+1 也就是首个 \u0026gt; a[i]的位置 int pos = upper_bound(stk + 1, stk + 1 + top, a[i]) - stk; //用upper_bound来实现二分 if (pos == top + 1) top++; stk[pos] = a[i]; ans = max(ans, top); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } eg： 题目描述：某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。输入导弹依次飞来的高度（雷达给出的高度数据是不大于30000的正整数），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。 输入描述：每笔测资一行：输入导弹依次飞来的高度，空格分隔，导弹数不超过1000。 输出描述：对于每笔测资，输出两行：第1行：1个整数，表示最多能拦截的导弹数。第2行：1个整数，表示要拦截所有导弹最少要配备的系统数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 2e5 + 9; ll a[N], stk[N], top; void solve() { // 不知道有多少输入的时候可以这样记录: int n = 0; while (cin \u0026gt;\u0026gt; a[++n]) ; n--; ll ans = 0; for (int i = 1; i \u0026lt;= n; ++i) { // 找第一个小于a[i]的位置 记录在pos中 int pos = upper_bound(stk + 1, stk + 1 + top, a[i], [](const int \u0026amp;u, const int \u0026amp;v) { return u \u0026gt; v; }) - stk; if (pos == top + 1) top++; stk[top] = a[i]; ans = max(ans, top); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 最长不升子序列的长度计算完成 // 根据狄尔沃斯定理，最少的最长不升子序列来覆盖整个数组的个数，是最长上升子序列的长度 // 因此需要再求一个最长上升子序列 ll ans2 = 0; top = 0; for (int i = 1; i \u0026lt;= n; ++i) { // 找第一个大于等于a[i]的位置 记录在pos中 int pos = lower_bound(stk + 1, stk + 1 + top, a[i]) - stk; if (pos == top + 1) top++; stk[top] = a[i]; ans2 = max(ans2, top); } cout \u0026lt;\u0026lt; ans2 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 最长不升子序列的长度计算完 } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } eg: 题目描述：小明的花店新开张，为了吸引顾客，他想在花店的门口摆上一排花，共 $m$ 盆。通过调查顾客的喜好，小明列出了顾客最喜欢的 $n$ 种花，从 1 到 $n$ 标号。为了在门口展出更多种花，规定第 $i$ 种花不能超过 $a_i$ 盆，摆花时同一种花放在一起，且不同种类的花需按标号的从小到大的顺序依次摆列。试编程计算，一共有多少种不同的摆花方案。 输入格式：第一行包含两个正整数 $n$ 和 $m$，中间用一个空格隔开。第二行有 $n$ 个整数，每两个整数之间用一个空格隔开，依次表示 $a_1, a_2, \\ldots, a_n$。 输出格式：一个整数，表示有多少种方案。注意：因为方案数可能很多，请输出方案数对 $10^6 + 7$ 取模的结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e3 + 9; const int p = 1e6 + 7; ll a[N]; ll dp[N][N]; void solve() { ll n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; for (int i = 0; i \u0026lt;= a[1]; ++i) dp[1][i] = 1; // 初始化 for (int i = 2; i \u0026lt;= n; ++i) // 到第i种花为止且以i结尾（也可能无i）的方案数 { for (int j = 0; j \u0026lt;= m; ++j) // 共放了j盆花的方案数 { for (int k = 0; k \u0026lt;= a[i] \u0026amp;\u0026amp; k \u0026lt;= j; ++k) // 最后第i种花放了k盆的方案数 { dp[i][j] = dp[i][j] + dp[i - 1][j - k]; } } } cout \u0026lt;\u0026lt; dp[n][m] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 2.区间DP 区间DP（动态规划）是一种处理涉及区间问题的动态规划方法。它通过将问题分解为更小的区间，并求解这些小区间的最优解，然后将这些解合并以得到整个大区间的最优解。以下是区间DP的一些关键点： 定义：区间DP是线性DP的一种，它以“区间长度”划分阶段，并以两个坐标（区间的左右端点）作为状态的维度。一个状态通常由被它包含且比它更小的区间状态转移而来。 核心思路：区间DP的核心思想是将一个大区间分割成多个小区间，分别求解每个小区间的最优解，然后合并这些解以得到整个大区间的最优解。 应用：区间DP常用于解决最长公共子序列、最长回文子串等问题。在区间DP中，通常需要定义一个二维数组来表示子区间的状态，并构建状态转移方程。\neg： 题目描述：有 ( n ) 堆石子排队一排，编号为 ( 1, 2, 3, \\cdots, n )，每堆石子有一个质量 ( a_i )。我们每次可以合并相邻的两堆石子，且合并需花费代价为这两堆石子的质量之和，现在要将这 ( n ) 堆石子合并成一堆。合并时由于顺序不同，合并的总代价也会有区别，请你计算出所需的最小总代价。 输入描述：第一行：一个整数 ( n )，表示石子的堆数。( ( 1 \\leq n \\leq 300 ) )第二行：( n ) 个整数，表示每堆石子的质量 ( a_i )。( ( 1 \\leq a_i \\leq 1000 ) ) 输出描述：一个整数，表示合并成一堆所需的最小总代价。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 500 + 9; const ll inf = 4e18; ll a[N], dp[N][N], prefix[N]; void solve() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n; ++i) prefix[i] = prefix[i - 1] + a[i]; // 枚举区间长度k for (int len = 2; len \u0026lt;= n; ++len) { // 枚举区间起点i 也就得到了终点j for (int i = 1, j = i + len - 1; j \u0026lt;= n; ++i, ++j) { // 初始化： dp[i][j] = inf; // 枚举区间中间的点 for (int k = i; k \u0026lt;= j; ++k) { dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + prefix[j] - prefix[i - 1]); } } } cout \u0026lt;\u0026lt; dp[1][n] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _ = 1; while (_--) solve(); return 0; } 3.树形DP 特点：\n定义在树结构上，利用子树递归求解。 常用在求树的某些性质，例如直径、最长路径、节点权值优化等。 状态定义：\n通常定义为 dp[u]，表示以节点 u 为根的子树中某种性质的最优解。 典型问题： 树的直径、树上背包问题、树的染色问题\n例子：\n树的直径：\n1 2 3 4 5 6 7 8 void dfs(int u, int parent) { for (int v : tree[u]) { if (v != parent) { dfs(v, u); dp[u] = max(dp[u], dp[v] + 1); } } } 用归属法，把一棵子树的权值和归属到根节点上 eg: 题目描述：给定一棵 ( n ) 个节点的树，每个节点 ( i (1 \\leq i \\leq n) ) 都有一个权值 ( w_i )。我们规定一个连通块的权值为，连通块中所有节点的权值之和，请你求出最大的连通块权值。注意：连通块需包含至少一个节点。 输入描述：第一行，一个整数 ( t )，表示案例个数。对于每个案例:第一行，一个整数 ( n )，表示节点数。 ( \\left(1 \\leq n \\leq 10^5\\right) ) 第二行，( n ) 个整数，表示节点权值 ( w_i )。 ( \\left(-10^4 \\leq w_i \\leq 10^4\\right) ) 接下来 ( n-1 ) 行，每行两个整数 ( u, v )，表示存在一条连接节点 ( u ) 和 ( v ) 的边。 ( (1 \\leq u, v \\leq n, u \\neq v) ) 输入保证：所有案例的 ( n ) 之和不超过 ( 2 \\times 10^5 )，即 ( 1 \\leq \\sum n \\leq 2 \\times 10^5 )。 输出描述：一个整数，表示最大连通块权值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int N = 1e5 + 9; ll dp[N]; // 表示以i为根的子树的权值和 vector\u0026lt;int\u0026gt; g[N]; ll w[N]; void dfs(int x, int pre) { dp[x] = w[x]; for (auto \u0026amp;y : g[x]) // 遍历儿子节点 { if (y == pre) continue; dfs(y, x); dp[x] = max(dp[x], dp[y] + dp[x]); } } void solve() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; w[i]; for (int i = 1; i \u0026lt;= n; ++i) { dp[i] = 0; g[i].clear(); // 初始化 } for (int i = 1; i \u0026lt; n; ++i) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; g[u].push_back(v); g[v].push_back(u); } dfs(1, -1); cout \u0026lt;\u0026lt; *max_element(dp + 1, dp + 1 + n) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int _; cin \u0026gt;\u0026gt; _; while (_--) solve(); return 0; } 4. 状态压缩 DP（状压 DP）\n特点：\n用一个整数（通常是位掩码）表示一个状态，从而压缩复杂度。 常用于组合问题，涉及子集、排列等情况。 状态定义：\n一般是 dp[mask]，表示状态为 mask 时的最优解。 典型问题： 旅行商问题（TSP）、最小路径覆盖问题、集合覆盖问题、多人游戏博弈问题\n例子：\n旅行商问题\n1 2 3 4 5 6 7 8 9 10 11 for (int mask = 0; mask \u0026lt; (1 \u0026lt;\u0026lt; n); ++mask) { for (int i = 0; i \u0026lt; n; ++i) { if (mask \u0026amp; (1 \u0026lt;\u0026lt; i)) { for (int j = 0; j \u0026lt; n; ++j) { if (mask \u0026amp; (1 \u0026lt;\u0026lt; j)) { dp[mask][i] = min(dp[mask][i], dp[mask ^ (1 \u0026lt;\u0026lt; i)][j] + dist[j][i]); } } } } } 5. 期望 DP\n特点：\n用于计算随机过程中的期望值。 通常需要将状态转移公式调整为期望形式，例如概率加权和。 状态定义：\n一般定义为 dp[i]，表示从状态 i 开始的期望值。 典型问题： 游戏中的胜率期望、骰子问题、分数期望\n例子：\n骰子问题：\n给定一个骰子，求掷出某个总点数所需的最少次数。\n1 2 3 4 5 6 for (int i = target; i \u0026gt;= 0; --i) { dp[i] = 1; for (int j = 1; j \u0026lt;= 6; ++j) { dp[i] += dp[min(target, i + j)] / 6.0; } } 6. 存在性 DP\n特点：\n判断某种状态是否可行，而非求具体值。 结果通常是 true/false 或 \u0026ldquo;Yes/No\u0026rdquo;。 状态定义：\n一般定义为 dp[i]，表示是否能达到某个状态。 典型问题： 子集和问题、判断是否可以分割成两个子集（等和划分）、游戏中的必胜或必败状态\n例子：\n子集和问题：\n给定一组数，判断是否可以选出一个子集，使其和等于某个值。\n1 2 3 4 5 6 dp[0] = true; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = target; j \u0026gt;= nums[i]; --j) { dp[j] = dp[j] || dp[j - nums[i]]; } } 7. 数位 DP 特点：\n解决与数字有关的计数问题，通常涉及某些限制条件（如不包含某个数字）。 利用数字的逐位分解，将问题转化为状态转移。 状态定义：\n一般定义为 dp[pos][state]，表示在第 pos 位时，状态为 state 的计数或方案数。 典型问题： 统计满足某些条件的数字个数、数字是否包含某些数字、数字按位奇偶分布问题\n例子：\n不含数字 4 的数的个数：\n1 2 3 4 5 6 7 8 for (int pos = 0; pos \u0026lt; length; ++pos) { for (int state = 0; state \u0026lt; 2; ++state) { for (int digit = 0; digit \u0026lt; 10; ++digit) { if (digit == 4) continue; dp[pos + 1][new_state] += dp[pos][state]; } } } 总结 分类 主要特点 典型问题 线性 DP 按序列递推 LIS, 背包问题 状压 DP 状态用位压缩表示 TSP, 子集问题 期望 DP 概率权重计算 骰子期望，随机博弈 存在性 DP 判断是否可行 子集和, 游戏决策问题 树形 DP 定义在树结构上 树直径, 树染色, 树背包 数位 DP 与数字相关的计数问题 统计数字满足的个数 动态规划本质上是通过定义状态和找出状态转移关系解决问题。掌握每种类型的核心思想和应用场景是学习动态规划的关键。\n","date":"2024-12-14T00:00:00Z","image":"https://Nanmur.github.io/p/test-chinese/Starcode-logo_hu7427521384709435736.png","permalink":"https://Nanmur.github.io/p/test-chinese/","title":"Starcode算法基础班笔记"}]